/*! For license information please see three.js.LICENSE.txt */
(()=>{"use strict";var e={d:(t,i)=>{for(var r in i)e.o(i,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:i[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{ACESFilmicToneMapping:()=>ie,AddEquation:()=>T,AddOperation:()=>K,AdditiveAnimationBlendMode:()=>Et,AdditiveBlending:()=>b,AlphaFormat:()=>Be,AlwaysDepth:()=>k,AlwaysStencilFunc:()=>ii,AmbientLight:()=>AmbientLight,AmbientLightProbe:()=>AmbientLightProbe,AnimationClip:()=>AnimationClip,AnimationLoader:()=>AnimationLoader,AnimationMixer:()=>AnimationMixer,AnimationObjectGroup:()=>AnimationObjectGroup,AnimationUtils:()=>Gs,ArcCurve:()=>ArcCurve,ArrayCamera:()=>ArrayCamera,ArrowHelper:()=>ArrowHelper,Audio:()=>Audio,AudioAnalyser:()=>AudioAnalyser,AudioContext:()=>ea,AudioListener:()=>AudioListener,AudioLoader:()=>AudioLoader,AxesHelper:()=>AxesHelper,BackSide:()=>m,BasicDepthPacking:()=>Bt,BasicShadowMap:()=>c,Bone:()=>Bone,BooleanKeyframeTrack:()=>BooleanKeyframeTrack,Box2:()=>Box2,Box3:()=>Box3,Box3Helper:()=>Box3Helper,BoxBufferGeometry:()=>BoxGeometry,BoxGeometry:()=>BoxGeometry,BoxHelper:()=>BoxHelper,BufferAttribute:()=>BufferAttribute,BufferGeometry:()=>BufferGeometry,BufferGeometryLoader:()=>BufferGeometryLoader,ByteType:()=>we,Cache:()=>Us,Camera:()=>Camera,CameraHelper:()=>CameraHelper,CanvasTexture:()=>CanvasTexture,CapsuleBufferGeometry:()=>CapsuleGeometry,CapsuleGeometry:()=>CapsuleGeometry,CatmullRomCurve3:()=>CatmullRomCurve3,CineonToneMapping:()=>te,CircleBufferGeometry:()=>CircleGeometry,CircleGeometry:()=>CircleGeometry,ClampToEdgeWrapping:()=>ue,Clock:()=>Clock,Color:()=>Color,ColorKeyframeTrack:()=>ColorKeyframeTrack,ColorManagement:()=>Mi,CompressedTexture:()=>CompressedTexture,CompressedTextureLoader:()=>CompressedTextureLoader,ConeBufferGeometry:()=>ConeGeometry,ConeGeometry:()=>ConeGeometry,CubeCamera:()=>CubeCamera,CubeReflectionMapping:()=>se,CubeRefractionMapping:()=>ae,CubeTexture:()=>CubeTexture,CubeTextureLoader:()=>CubeTextureLoader,CubeUVReflectionMapping:()=>ce,CubicBezierCurve:()=>CubicBezierCurve,CubicBezierCurve3:()=>CubicBezierCurve3,CubicInterpolant:()=>CubicInterpolant,CullFaceBack:()=>a,CullFaceFront:()=>o,CullFaceFrontBack:()=>l,CullFaceNone:()=>s,Curve:()=>Curve,CurvePath:()=>CurvePath,CustomBlending:()=>w,CustomToneMapping:()=>re,CylinderBufferGeometry:()=>CylinderGeometry,CylinderGeometry:()=>CylinderGeometry,Cylindrical:()=>Cylindrical,Data3DTexture:()=>Data3DTexture,DataArrayTexture:()=>DataArrayTexture,DataTexture:()=>DataTexture,DataTexture2DArray:()=>DataTexture2DArray,DataTexture3D:()=>DataTexture3D,DataTextureLoader:()=>DataTextureLoader,DataUtils:()=>Ga,DecrementStencilOp:()=>jt,DecrementWrapStencilOp:()=>Xt,DefaultLoadingManager:()=>ks,DepthFormat:()=>Fe,DepthStencilFormat:()=>Ge,DepthTexture:()=>DepthTexture,DirectionalLight:()=>DirectionalLight,DirectionalLightHelper:()=>DirectionalLightHelper,DiscreteInterpolant:()=>DiscreteInterpolant,DodecahedronBufferGeometry:()=>DodecahedronGeometry,DodecahedronGeometry:()=>DodecahedronGeometry,DoubleSide:()=>f,DstAlphaFactor:()=>N,DstColorFactor:()=>z,DynamicCopyUsage:()=>hi,DynamicDrawUsage:()=>ni,DynamicReadUsage:()=>oi,EdgesGeometry:()=>EdgesGeometry,EllipseCurve:()=>EllipseCurve,EqualDepth:()=>j,EqualStencilFunc:()=>Kt,EquirectangularReflectionMapping:()=>oe,EquirectangularRefractionMapping:()=>le,Euler:()=>Euler,EventDispatcher:()=>EventDispatcher,ExtrudeBufferGeometry:()=>ExtrudeGeometry,ExtrudeGeometry:()=>ExtrudeGeometry,FileLoader:()=>FileLoader,FlatShading:()=>g,Float16BufferAttribute:()=>Float16BufferAttribute,Float32BufferAttribute:()=>Float32BufferAttribute,Float64BufferAttribute:()=>Float64BufferAttribute,FloatType:()=>Le,Fog:()=>Fog,FogExp2:()=>FogExp2,Font:()=>Font,FontLoader:()=>FontLoader,FramebufferTexture:()=>FramebufferTexture,FrontSide:()=>p,Frustum:()=>Frustum,GLBufferAttribute:()=>GLBufferAttribute,GLSL1:()=>di,GLSL3:()=>pi,GreaterDepth:()=>X,GreaterEqualDepth:()=>q,GreaterEqualStencilFunc:()=>ti,GreaterStencilFunc:()=>$t,GridHelper:()=>GridHelper,Group:()=>Group,HalfFloatType:()=>Pe,HemisphereLight:()=>HemisphereLight,HemisphereLightHelper:()=>HemisphereLightHelper,HemisphereLightProbe:()=>HemisphereLightProbe,IcosahedronBufferGeometry:()=>IcosahedronGeometry,IcosahedronGeometry:()=>IcosahedronGeometry,ImageBitmapLoader:()=>ImageBitmapLoader,ImageLoader:()=>ImageLoader,ImageUtils:()=>ImageUtils,ImmediateRenderObject:()=>ImmediateRenderObject,IncrementStencilOp:()=>Ht,IncrementWrapStencilOp:()=>qt,InstancedBufferAttribute:()=>InstancedBufferAttribute,InstancedBufferGeometry:()=>InstancedBufferGeometry,InstancedInterleavedBuffer:()=>InstancedInterleavedBuffer,InstancedMesh:()=>InstancedMesh,Int16BufferAttribute:()=>Int16BufferAttribute,Int32BufferAttribute:()=>Int32BufferAttribute,Int8BufferAttribute:()=>Int8BufferAttribute,IntType:()=>Ce,InterleavedBuffer:()=>InterleavedBuffer,InterleavedBufferAttribute:()=>InterleavedBufferAttribute,Interpolant:()=>Interpolant,InterpolateDiscrete:()=>bt,InterpolateLinear:()=>Mt,InterpolateSmooth:()=>St,InvertStencilOp:()=>Yt,KeepStencilOp:()=>kt,KeyframeTrack:()=>KeyframeTrack,LOD:()=>LOD,LatheBufferGeometry:()=>LatheGeometry,LatheGeometry:()=>LatheGeometry,Layers:()=>Layers,LessDepth:()=>W,LessEqualDepth:()=>H,LessEqualStencilFunc:()=>Qt,LessStencilFunc:()=>Jt,Light:()=>Light,LightProbe:()=>LightProbe,Line:()=>Line,Line3:()=>Line3,LineBasicMaterial:()=>LineBasicMaterial,LineCurve:()=>LineCurve,LineCurve3:()=>LineCurve3,LineDashedMaterial:()=>LineDashedMaterial,LineLoop:()=>LineLoop,LineSegments:()=>LineSegments,LinearEncoding:()=>Dt,LinearFilter:()=>xe,LinearInterpolant:()=>LinearInterpolant,LinearMipMapLinearFilter:()=>Me,LinearMipMapNearestFilter:()=>_e,LinearMipmapLinearFilter:()=>be,LinearMipmapNearestFilter:()=>ye,LinearSRGBColorSpace:()=>Gt,LinearToneMapping:()=>$,Loader:()=>Loader,LoaderUtils:()=>LoaderUtils,LoadingManager:()=>LoadingManager,LoopOnce:()=>xt,LoopPingPong:()=>_t,LoopRepeat:()=>yt,LuminanceAlphaFormat:()=>ze,LuminanceFormat:()=>Oe,MOUSE:()=>r,Material:()=>Material,MaterialLoader:()=>MaterialLoader,MathUtils:()=>yi,Matrix3:()=>Matrix3,Matrix4:()=>Matrix4,MaxEquation:()=>L,Mesh:()=>Mesh,MeshBasicMaterial:()=>MeshBasicMaterial,MeshDepthMaterial:()=>MeshDepthMaterial,MeshDistanceMaterial:()=>MeshDistanceMaterial,MeshLambertMaterial:()=>MeshLambertMaterial,MeshMatcapMaterial:()=>MeshMatcapMaterial,MeshNormalMaterial:()=>MeshNormalMaterial,MeshPhongMaterial:()=>MeshPhongMaterial,MeshPhysicalMaterial:()=>MeshPhysicalMaterial,MeshStandardMaterial:()=>MeshStandardMaterial,MeshToonMaterial:()=>MeshToonMaterial,MinEquation:()=>E,MirroredRepeatWrapping:()=>de,MixOperation:()=>J,MultiplyBlending:()=>S,MultiplyOperation:()=>Z,NearestFilter:()=>pe,NearestMipMapLinearFilter:()=>ve,NearestMipMapNearestFilter:()=>fe,NearestMipmapLinearFilter:()=>ge,NearestMipmapNearestFilter:()=>me,NeverDepth:()=>U,NeverStencilFunc:()=>Zt,NoBlending:()=>y,NoColorSpace:()=>zt,NoToneMapping:()=>Q,NormalAnimationBlendMode:()=>Ct,NormalBlending:()=>_,NotEqualDepth:()=>Y,NotEqualStencilFunc:()=>ei,NumberKeyframeTrack:()=>NumberKeyframeTrack,Object3D:()=>Object3D,ObjectLoader:()=>ObjectLoader,ObjectSpaceNormalMap:()=>Ot,OctahedronBufferGeometry:()=>OctahedronGeometry,OctahedronGeometry:()=>OctahedronGeometry,OneFactor:()=>R,OneMinusDstAlphaFactor:()=>O,OneMinusDstColorFactor:()=>F,OneMinusSrcAlphaFactor:()=>V,OneMinusSrcColorFactor:()=>I,OrthographicCamera:()=>OrthographicCamera,PCFShadowMap:()=>h,PCFSoftShadowMap:()=>u,PMREMGenerator:()=>PMREMGenerator,ParametricGeometry:()=>ParametricGeometry,Path:()=>Path,PerspectiveCamera:()=>PerspectiveCamera,Plane:()=>Plane,PlaneBufferGeometry:()=>PlaneGeometry,PlaneGeometry:()=>PlaneGeometry,PlaneHelper:()=>PlaneHelper,PointLight:()=>PointLight,PointLightHelper:()=>PointLightHelper,Points:()=>Points,PointsMaterial:()=>PointsMaterial,PolarGridHelper:()=>PolarGridHelper,PolyhedronBufferGeometry:()=>PolyhedronGeometry,PolyhedronGeometry:()=>PolyhedronGeometry,PositionalAudio:()=>PositionalAudio,PropertyBinding:()=>PropertyBinding,PropertyMixer:()=>PropertyMixer,QuadraticBezierCurve:()=>QuadraticBezierCurve,QuadraticBezierCurve3:()=>QuadraticBezierCurve3,Quaternion:()=>Quaternion,QuaternionKeyframeTrack:()=>QuaternionKeyframeTrack,QuaternionLinearInterpolant:()=>QuaternionLinearInterpolant,REVISION:()=>i,RGBADepthPacking:()=>Vt,RGBAFormat:()=>Ne,RGBAIntegerFormat:()=>je,RGBA_ASTC_10x10_Format:()=>mt,RGBA_ASTC_10x5_Format:()=>ut,RGBA_ASTC_10x6_Format:()=>dt,RGBA_ASTC_10x8_Format:()=>pt,RGBA_ASTC_12x10_Format:()=>ft,RGBA_ASTC_12x12_Format:()=>gt,RGBA_ASTC_4x4_Format:()=>rt,RGBA_ASTC_5x4_Format:()=>nt,RGBA_ASTC_5x5_Format:()=>st,RGBA_ASTC_6x5_Format:()=>at,RGBA_ASTC_6x6_Format:()=>ot,RGBA_ASTC_8x5_Format:()=>lt,RGBA_ASTC_8x6_Format:()=>ct,RGBA_ASTC_8x8_Format:()=>ht,RGBA_BPTC_Format:()=>vt,RGBA_ETC2_EAC_Format:()=>it,RGBA_PVRTC_2BPPV1_Format:()=>$e,RGBA_PVRTC_4BPPV1_Format:()=>Qe,RGBA_S3TC_DXT1_Format:()=>Xe,RGBA_S3TC_DXT3_Format:()=>Ye,RGBA_S3TC_DXT5_Format:()=>Ze,RGBFormat:()=>Ve,RGB_ETC1_Format:()=>et,RGB_ETC2_Format:()=>tt,RGB_PVRTC_2BPPV1_Format:()=>Ke,RGB_PVRTC_4BPPV1_Format:()=>Je,RGB_S3TC_DXT1_Format:()=>qe,RGFormat:()=>We,RGIntegerFormat:()=>He,RawShaderMaterial:()=>RawShaderMaterial,Ray:()=>Ray,Raycaster:()=>Raycaster,RectAreaLight:()=>RectAreaLight,RedFormat:()=>Ue,RedIntegerFormat:()=>ke,ReinhardToneMapping:()=>ee,RepeatWrapping:()=>he,ReplaceStencilOp:()=>Wt,ReverseSubtractEquation:()=>C,RingBufferGeometry:()=>RingGeometry,RingGeometry:()=>RingGeometry,SRGBColorSpace:()=>Ft,Scene:()=>Scene,ShaderChunk:()=>mn,ShaderLib:()=>gn,ShaderMaterial:()=>ShaderMaterial,ShadowMaterial:()=>ShadowMaterial,Shape:()=>Shape,ShapeBufferGeometry:()=>ShapeGeometry,ShapeGeometry:()=>ShapeGeometry,ShapePath:()=>ShapePath,ShapeUtils:()=>ShapeUtils,ShortType:()=>Te,Skeleton:()=>Skeleton,SkeletonHelper:()=>SkeletonHelper,SkinnedMesh:()=>SkinnedMesh,SmoothShading:()=>x,Source:()=>Source,Sphere:()=>Sphere,SphereBufferGeometry:()=>SphereGeometry,SphereGeometry:()=>SphereGeometry,Spherical:()=>Spherical,SphericalHarmonics3:()=>SphericalHarmonics3,SplineCurve:()=>SplineCurve,SpotLight:()=>SpotLight,SpotLightHelper:()=>SpotLightHelper,Sprite:()=>Sprite,SpriteMaterial:()=>SpriteMaterial,SrcAlphaFactor:()=>B,SrcAlphaSaturateFactor:()=>G,SrcColorFactor:()=>D,StaticCopyUsage:()=>ci,StaticDrawUsage:()=>ri,StaticReadUsage:()=>ai,StereoCamera:()=>StereoCamera,StreamCopyUsage:()=>ui,StreamDrawUsage:()=>si,StreamReadUsage:()=>li,StringKeyframeTrack:()=>StringKeyframeTrack,SubtractEquation:()=>A,SubtractiveBlending:()=>M,TOUCH:()=>n,TangentSpaceNormalMap:()=>Nt,TetrahedronBufferGeometry:()=>TetrahedronGeometry,TetrahedronGeometry:()=>TetrahedronGeometry,TextGeometry:()=>TextGeometry,Texture:()=>Texture,TextureLoader:()=>TextureLoader,TorusBufferGeometry:()=>TorusGeometry,TorusGeometry:()=>TorusGeometry,TorusKnotBufferGeometry:()=>TorusKnotGeometry,TorusKnotGeometry:()=>TorusKnotGeometry,Triangle:()=>Triangle,TriangleFanDrawMode:()=>Rt,TriangleStripDrawMode:()=>Pt,TrianglesDrawMode:()=>Lt,TubeBufferGeometry:()=>TubeGeometry,TubeGeometry:()=>TubeGeometry,UVMapping:()=>ne,Uint16BufferAttribute:()=>Uint16BufferAttribute,Uint32BufferAttribute:()=>Uint32BufferAttribute,Uint8BufferAttribute:()=>Uint8BufferAttribute,Uint8ClampedBufferAttribute:()=>Uint8ClampedBufferAttribute,Uniform:()=>Uniform,UniformsGroup:()=>UniformsGroup,UniformsLib:()=>fn,UniformsUtils:()=>on,UnsignedByteType:()=>Se,UnsignedInt248Type:()=>Ie,UnsignedIntType:()=>Ee,UnsignedShort4444Type:()=>Re,UnsignedShort5551Type:()=>De,UnsignedShortType:()=>Ae,VSMShadowMap:()=>d,Vector2:()=>Vector2,Vector3:()=>Vector3,Vector4:()=>Vector4,VectorKeyframeTrack:()=>VectorKeyframeTrack,VideoTexture:()=>VideoTexture,WebGL1Renderer:()=>WebGL1Renderer,WebGL3DRenderTarget:()=>WebGL3DRenderTarget,WebGLArrayRenderTarget:()=>WebGLArrayRenderTarget,WebGLCubeRenderTarget:()=>WebGLCubeRenderTarget,WebGLMultipleRenderTargets:()=>WebGLMultipleRenderTargets,WebGLMultisampleRenderTarget:()=>WebGLMultisampleRenderTarget,WebGLRenderTarget:()=>WebGLRenderTarget,WebGLRenderer:()=>WebGLRenderer,WebGLUtils:()=>WebGLUtils,WireframeGeometry:()=>WireframeGeometry,WrapAroundEnding:()=>At,ZeroCurvatureEnding:()=>wt,ZeroFactor:()=>P,ZeroSlopeEnding:()=>Tt,ZeroStencilOp:()=>Ut,_SRGBAFormat:()=>mi,sRGBEncoding:()=>It});const i="143",r={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},n={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},s=0,a=1,o=2,l=3,c=0,h=1,u=2,d=3,p=0,m=1,f=2,g=1,x=2,y=0,_=1,b=2,M=3,S=4,w=5,T=100,A=101,C=102,E=103,L=104,P=200,R=201,D=202,I=203,B=204,V=205,N=206,O=207,z=208,F=209,G=210,U=0,k=1,W=2,H=3,j=4,q=5,X=6,Y=7,Z=0,J=1,K=2,Q=0,$=1,ee=2,te=3,ie=4,re=5,ne=300,se=301,ae=302,oe=303,le=304,ce=306,he=1e3,ue=1001,de=1002,pe=1003,me=1004,fe=1004,ge=1005,ve=1005,xe=1006,ye=1007,_e=1007,be=1008,Me=1008,Se=1009,we=1010,Te=1011,Ae=1012,Ce=1013,Ee=1014,Le=1015,Pe=1016,Re=1017,De=1018,Ie=1020,Be=1021,Ve=1022,Ne=1023,Oe=1024,ze=1025,Fe=1026,Ge=1027,Ue=1028,ke=1029,We=1030,He=1031,je=1033,qe=33776,Xe=33777,Ye=33778,Ze=33779,Je=35840,Ke=35841,Qe=35842,$e=35843,et=36196,tt=37492,it=37496,rt=37808,nt=37809,st=37810,at=37811,ot=37812,lt=37813,ct=37814,ht=37815,ut=37816,dt=37817,pt=37818,mt=37819,ft=37820,gt=37821,vt=36492,xt=2200,yt=2201,_t=2202,bt=2300,Mt=2301,St=2302,wt=2400,Tt=2401,At=2402,Ct=2500,Et=2501,Lt=0,Pt=1,Rt=2,Dt=3e3,It=3001,Bt=3200,Vt=3201,Nt=0,Ot=1,zt="",Ft="srgb",Gt="srgb-linear",Ut=0,kt=7680,Wt=7681,Ht=7682,jt=7683,qt=34055,Xt=34056,Yt=5386,Zt=512,Jt=513,Kt=514,Qt=515,$t=516,ei=517,ti=518,ii=519,ri=35044,ni=35048,si=35040,ai=35045,oi=35049,li=35041,ci=35046,hi=35050,ui=35042,di="100",pi="300 es",mi=1035;class EventDispatcher{addEventListener(e,t){void 0===this._listeners&&(this._listeners={});const i=this._listeners;void 0===i[e]&&(i[e]=[]),-1===i[e].indexOf(t)&&i[e].push(t)}hasEventListener(e,t){if(void 0===this._listeners)return!1;const i=this._listeners;return void 0!==i[e]&&-1!==i[e].indexOf(t)}removeEventListener(e,t){if(void 0===this._listeners)return;const i=this._listeners[e];if(void 0!==i){const e=i.indexOf(t);-1!==e&&i.splice(e,1)}}dispatchEvent(e){if(void 0===this._listeners)return;const t=this._listeners[e.type];if(void 0!==t){e.target=this;const i=t.slice(0);for(let t=0,r=i.length;t<r;t++)i[t].call(this,e);e.target=null}}}const fi=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let gi=1234567;const vi=Math.PI/180,xi=180/Math.PI;function generateUUID(){const e=4294967295*Math.random()|0,t=4294967295*Math.random()|0,i=4294967295*Math.random()|0,r=4294967295*Math.random()|0;return(fi[255&e]+fi[e>>8&255]+fi[e>>16&255]+fi[e>>24&255]+"-"+fi[255&t]+fi[t>>8&255]+"-"+fi[t>>16&15|64]+fi[t>>24&255]+"-"+fi[63&i|128]+fi[i>>8&255]+"-"+fi[i>>16&255]+fi[i>>24&255]+fi[255&r]+fi[r>>8&255]+fi[r>>16&255]+fi[r>>24&255]).toLowerCase()}function clamp(e,t,i){return Math.max(t,Math.min(i,e))}function euclideanModulo(e,t){return(e%t+t)%t}function lerp(e,t,i){return(1-i)*e+i*t}function isPowerOfTwo(e){return 0===(e&e-1)&&0!==e}function ceilPowerOfTwo(e){return Math.pow(2,Math.ceil(Math.log(e)/Math.LN2))}function floorPowerOfTwo(e){return Math.pow(2,Math.floor(Math.log(e)/Math.LN2))}var yi=Object.freeze({__proto__:null,DEG2RAD:vi,RAD2DEG:xi,generateUUID:generateUUID,clamp:clamp,euclideanModulo:euclideanModulo,mapLinear:function mapLinear(e,t,i,r,n){return r+(e-t)*(n-r)/(i-t)},inverseLerp:function inverseLerp(e,t,i){return e!==t?(i-e)/(t-e):0},lerp:lerp,damp:function damp(e,t,i,r){return lerp(e,t,1-Math.exp(-i*r))},pingpong:function pingpong(e,t=1){return t-Math.abs(euclideanModulo(e,2*t)-t)},smoothstep:function smoothstep(e,t,i){return e<=t?0:e>=i?1:(e=(e-t)/(i-t))*e*(3-2*e)},smootherstep:function smootherstep(e,t,i){return e<=t?0:e>=i?1:(e=(e-t)/(i-t))*e*e*(e*(6*e-15)+10)},randInt:function randInt(e,t){return e+Math.floor(Math.random()*(t-e+1))},randFloat:function randFloat(e,t){return e+Math.random()*(t-e)},randFloatSpread:function randFloatSpread(e){return e*(.5-Math.random())},seededRandom:function seededRandom(e){void 0!==e&&(gi=e);let t=gi+=1831565813;return t=Math.imul(t^t>>>15,1|t),t^=t+Math.imul(t^t>>>7,61|t),((t^t>>>14)>>>0)/4294967296},degToRad:function degToRad(e){return e*vi},radToDeg:function radToDeg(e){return e*xi},isPowerOfTwo:isPowerOfTwo,ceilPowerOfTwo:ceilPowerOfTwo,floorPowerOfTwo:floorPowerOfTwo,setQuaternionFromProperEuler:function setQuaternionFromProperEuler(e,t,i,r,n){const s=Math.cos,a=Math.sin,o=s(i/2),l=a(i/2),c=s((t+r)/2),h=a((t+r)/2),u=s((t-r)/2),d=a((t-r)/2),p=s((r-t)/2),m=a((r-t)/2);switch(n){case"XYX":e.set(o*h,l*u,l*d,o*c);break;case"YZY":e.set(l*d,o*h,l*u,o*c);break;case"ZXZ":e.set(l*u,l*d,o*h,o*c);break;case"XZX":e.set(o*h,l*m,l*p,o*c);break;case"YXY":e.set(l*p,o*h,l*m,o*c);break;case"ZYZ":e.set(l*m,l*p,o*h,o*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+n)}},normalize:function normalize(e,t){switch(t.constructor){case Float32Array:return e;case Uint16Array:return Math.round(65535*e);case Uint8Array:return Math.round(255*e);case Int16Array:return Math.round(32767*e);case Int8Array:return Math.round(127*e);default:throw new Error("Invalid component type.")}},denormalize:function denormalize$1(e,t){switch(t.constructor){case Float32Array:return e;case Uint16Array:return e/65535;case Uint8Array:return e/255;case Int16Array:return Math.max(e/32767,-1);case Int8Array:return Math.max(e/127,-1);default:throw new Error("Invalid component type.")}}});class Vector2{constructor(e=0,t=0){Vector2.prototype.isVector2=!0,this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,i=this.y,r=e.elements;return this.x=r[0]*t+r[3]*i+r[6],this.y=r[1]*t+r[4]*i+r[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(e,Math.min(t,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,i=this.y-e.y;return t*t+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const i=Math.cos(t),r=Math.sin(t),n=this.x-e.x,s=this.y-e.y;return this.x=n*i-s*r+e.x,this.y=n*r+s*i+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class Matrix3{constructor(){Matrix3.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1]}set(e,t,i,r,n,s,a,o,l){const c=this.elements;return c[0]=e,c[1]=r,c[2]=a,c[3]=t,c[4]=n,c[5]=o,c[6]=i,c[7]=s,c[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,i=e.elements;return t[0]=i[0],t[1]=i[1],t[2]=i[2],t[3]=i[3],t[4]=i[4],t[5]=i[5],t[6]=i[6],t[7]=i[7],t[8]=i[8],this}extractBasis(e,t,i){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),i.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const i=e.elements,r=t.elements,n=this.elements,s=i[0],a=i[3],o=i[6],l=i[1],c=i[4],h=i[7],u=i[2],d=i[5],p=i[8],m=r[0],f=r[3],g=r[6],x=r[1],y=r[4],_=r[7],b=r[2],M=r[5],S=r[8];return n[0]=s*m+a*x+o*b,n[3]=s*f+a*y+o*M,n[6]=s*g+a*_+o*S,n[1]=l*m+c*x+h*b,n[4]=l*f+c*y+h*M,n[7]=l*g+c*_+h*S,n[2]=u*m+d*x+p*b,n[5]=u*f+d*y+p*M,n[8]=u*g+d*_+p*S,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],i=e[1],r=e[2],n=e[3],s=e[4],a=e[5],o=e[6],l=e[7],c=e[8];return t*s*c-t*a*l-i*n*c+i*a*o+r*n*l-r*s*o}invert(){const e=this.elements,t=e[0],i=e[1],r=e[2],n=e[3],s=e[4],a=e[5],o=e[6],l=e[7],c=e[8],h=c*s-a*l,u=a*o-c*n,d=l*n-s*o,p=t*h+i*u+r*d;if(0===p)return this.set(0,0,0,0,0,0,0,0,0);const m=1/p;return e[0]=h*m,e[1]=(r*l-c*i)*m,e[2]=(a*i-r*s)*m,e[3]=u*m,e[4]=(c*t-r*o)*m,e[5]=(r*n-a*t)*m,e[6]=d*m,e[7]=(i*o-l*t)*m,e[8]=(s*t-i*n)*m,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,i,r,n,s,a){const o=Math.cos(n),l=Math.sin(n);return this.set(i*o,i*l,-i*(o*s+l*a)+s+e,-r*l,r*o,-r*(-l*s+o*a)+a+t,0,0,1),this}scale(e,t){const i=this.elements;return i[0]*=e,i[3]*=e,i[6]*=e,i[1]*=t,i[4]*=t,i[7]*=t,this}rotate(e){const t=Math.cos(e),i=Math.sin(e),r=this.elements,n=r[0],s=r[3],a=r[6],o=r[1],l=r[4],c=r[7];return r[0]=t*n+i*o,r[3]=t*s+i*l,r[6]=t*a+i*c,r[1]=-i*n+t*o,r[4]=-i*s+t*l,r[7]=-i*a+t*c,this}translate(e,t){const i=this.elements;return i[0]+=e*i[2],i[3]+=e*i[5],i[6]+=e*i[8],i[1]+=t*i[2],i[4]+=t*i[5],i[7]+=t*i[8],this}equals(e){const t=this.elements,i=e.elements;for(let r=0;r<9;r++)if(t[r]!==i[r])return!1;return!0}fromArray(e,t=0){for(let i=0;i<9;i++)this.elements[i]=e[i+t];return this}toArray(e=[],t=0){const i=this.elements;return e[t]=i[0],e[t+1]=i[1],e[t+2]=i[2],e[t+3]=i[3],e[t+4]=i[4],e[t+5]=i[5],e[t+6]=i[6],e[t+7]=i[7],e[t+8]=i[8],e}clone(){return(new this.constructor).fromArray(this.elements)}}function arrayNeedsUint32(e){for(let t=e.length-1;t>=0;--t)if(e[t]>65535)return!0;return!1}const _i={Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:Uint8ClampedArray,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array};function getTypedArray(e,t){return new _i[e](t)}function createElementNS(e){return document.createElementNS("http://www.w3.org/1999/xhtml",e)}function SRGBToLinear(e){return e<.04045?.0773993808*e:Math.pow(.9478672986*e+.0521327014,2.4)}function LinearToSRGB(e){return e<.0031308?12.92*e:1.055*Math.pow(e,.41666)-.055}const bi={[Ft]:{[Gt]:SRGBToLinear},[Gt]:{[Ft]:LinearToSRGB}},Mi={legacyMode:!0,get workingColorSpace(){return Gt},set workingColorSpace(e){console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")},convert:function(e,t,i){if(this.legacyMode||t===i||!t||!i)return e;if(bi[t]&&void 0!==bi[t][i]){const r=bi[t][i];return e.r=r(e.r),e.g=r(e.g),e.b=r(e.b),e}throw new Error("Unsupported color space conversion.")},fromWorkingColorSpace:function(e,t){return this.convert(e,this.workingColorSpace,t)},toWorkingColorSpace:function(e,t){return this.convert(e,t,this.workingColorSpace)}},Si={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},wi={r:0,g:0,b:0},Ti={h:0,s:0,l:0},Ai={h:0,s:0,l:0};function hue2rgb(e,t,i){return i<0&&(i+=1),i>1&&(i-=1),i<1/6?e+6*(t-e)*i:i<.5?t:i<2/3?e+6*(t-e)*(2/3-i):e}function toComponents(e,t){return t.r=e.r,t.g=e.g,t.b=e.b,t}class Color{constructor(e,t,i){return this.isColor=!0,this.r=1,this.g=1,this.b=1,void 0===t&&void 0===i?this.set(e):this.setRGB(e,t,i)}set(e){return e&&e.isColor?this.copy(e):"number"===typeof e?this.setHex(e):"string"===typeof e&&this.setStyle(e),this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t=Ft){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(255&e)/255,Mi.toWorkingColorSpace(this,t),this}setRGB(e,t,i,r=Gt){return this.r=e,this.g=t,this.b=i,Mi.toWorkingColorSpace(this,r),this}setHSL(e,t,i,r=Gt){if(e=euclideanModulo(e,1),t=clamp(t,0,1),i=clamp(i,0,1),0===t)this.r=this.g=this.b=i;else{const r=i<=.5?i*(1+t):i+t-i*t,n=2*i-r;this.r=hue2rgb(n,r,e+1/3),this.g=hue2rgb(n,r,e),this.b=hue2rgb(n,r,e-1/3)}return Mi.toWorkingColorSpace(this,r),this}setStyle(e,t=Ft){function handleAlpha(t){void 0!==t&&parseFloat(t)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let i;if(i=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)){let e;const r=i[1],n=i[2];switch(r){case"rgb":case"rgba":if(e=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(n))return this.r=Math.min(255,parseInt(e[1],10))/255,this.g=Math.min(255,parseInt(e[2],10))/255,this.b=Math.min(255,parseInt(e[3],10))/255,Mi.toWorkingColorSpace(this,t),handleAlpha(e[4]),this;if(e=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(n))return this.r=Math.min(100,parseInt(e[1],10))/100,this.g=Math.min(100,parseInt(e[2],10))/100,this.b=Math.min(100,parseInt(e[3],10))/100,Mi.toWorkingColorSpace(this,t),handleAlpha(e[4]),this;break;case"hsl":case"hsla":if(e=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(n)){const i=parseFloat(e[1])/360,r=parseInt(e[2],10)/100,n=parseInt(e[3],10)/100;return handleAlpha(e[4]),this.setHSL(i,r,n,t)}}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(e)){const e=i[1],r=e.length;if(3===r)return this.r=parseInt(e.charAt(0)+e.charAt(0),16)/255,this.g=parseInt(e.charAt(1)+e.charAt(1),16)/255,this.b=parseInt(e.charAt(2)+e.charAt(2),16)/255,Mi.toWorkingColorSpace(this,t),this;if(6===r)return this.r=parseInt(e.charAt(0)+e.charAt(1),16)/255,this.g=parseInt(e.charAt(2)+e.charAt(3),16)/255,this.b=parseInt(e.charAt(4)+e.charAt(5),16)/255,Mi.toWorkingColorSpace(this,t),this}return e&&e.length>0?this.setColorName(e,t):this}setColorName(e,t=Ft){const i=Si[e.toLowerCase()];return void 0!==i?this.setHex(i,t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=SRGBToLinear(e.r),this.g=SRGBToLinear(e.g),this.b=SRGBToLinear(e.b),this}copyLinearToSRGB(e){return this.r=LinearToSRGB(e.r),this.g=LinearToSRGB(e.g),this.b=LinearToSRGB(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=Ft){return Mi.fromWorkingColorSpace(toComponents(this,wi),e),clamp(255*wi.r,0,255)<<16^clamp(255*wi.g,0,255)<<8^clamp(255*wi.b,0,255)<<0}getHexString(e=Ft){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t=Gt){Mi.fromWorkingColorSpace(toComponents(this,wi),t);const i=wi.r,r=wi.g,n=wi.b,s=Math.max(i,r,n),a=Math.min(i,r,n);let o,l;const c=(a+s)/2;if(a===s)o=0,l=0;else{const e=s-a;switch(l=c<=.5?e/(s+a):e/(2-s-a),s){case i:o=(r-n)/e+(r<n?6:0);break;case r:o=(n-i)/e+2;break;case n:o=(i-r)/e+4}o/=6}return e.h=o,e.s=l,e.l=c,e}getRGB(e,t=Gt){return Mi.fromWorkingColorSpace(toComponents(this,wi),t),e.r=wi.r,e.g=wi.g,e.b=wi.b,e}getStyle(e=Ft){return Mi.fromWorkingColorSpace(toComponents(this,wi),e),e!==Ft?`color(${e} ${wi.r} ${wi.g} ${wi.b})`:`rgb(${255*wi.r|0},${255*wi.g|0},${255*wi.b|0})`}offsetHSL(e,t,i){return this.getHSL(Ti),Ti.h+=e,Ti.s+=t,Ti.l+=i,this.setHSL(Ti.h,Ti.s,Ti.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,i){return this.r=e.r+(t.r-e.r)*i,this.g=e.g+(t.g-e.g)*i,this.b=e.b+(t.b-e.b)*i,this}lerpHSL(e,t){this.getHSL(Ti),e.getHSL(Ai);const i=lerp(Ti.h,Ai.h,t),r=lerp(Ti.s,Ai.s,t),n=lerp(Ti.l,Ai.l,t);return this.setHSL(i,r,n),this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),!0===e.normalized&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}let Ci;Color.NAMES=Si;class ImageUtils{static getDataURL(e){if(/^data:/i.test(e.src))return e.src;if("undefined"==typeof HTMLCanvasElement)return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{void 0===Ci&&(Ci=createElementNS("canvas")),Ci.width=e.width,Ci.height=e.height;const i=Ci.getContext("2d");e instanceof ImageData?i.putImageData(e,0,0):i.drawImage(e,0,0,e.width,e.height),t=Ci}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}static sRGBToLinear(e){if("undefined"!==typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!==typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!==typeof ImageBitmap&&e instanceof ImageBitmap){const t=createElementNS("canvas");t.width=e.width,t.height=e.height;const i=t.getContext("2d");i.drawImage(e,0,0,e.width,e.height);const r=i.getImageData(0,0,e.width,e.height),n=r.data;for(let e=0;e<n.length;e++)n[e]=255*SRGBToLinear(n[e]/255);return i.putImageData(r,0,0),t}if(e.data){const t=e.data.slice(0);for(let e=0;e<t.length;e++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[e]=Math.floor(255*SRGBToLinear(t[e]/255)):t[e]=SRGBToLinear(t[e]);return{data:t,width:e.width,height:e.height}}return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}class Source{constructor(e=null){this.isSource=!0,this.uuid=generateUUID(),this.data=e,this.version=0}set needsUpdate(e){!0===e&&this.version++}toJSON(e){const t=void 0===e||"string"===typeof e;if(!t&&void 0!==e.images[this.uuid])return e.images[this.uuid];const i={uuid:this.uuid,url:""},r=this.data;if(null!==r){let e;if(Array.isArray(r)){e=[];for(let t=0,i=r.length;t<i;t++)r[t].isDataTexture?e.push(serializeImage(r[t].image)):e.push(serializeImage(r[t]))}else e=serializeImage(r);i.url=e}return t||(e.images[this.uuid]=i),i}}function serializeImage(e){return"undefined"!==typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!==typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!==typeof ImageBitmap&&e instanceof ImageBitmap?ImageUtils.getDataURL(e):e.data?{data:Array.from(e.data),width:e.width,height:e.height,type:e.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let Ei=0;class Texture extends EventDispatcher{constructor(e=Texture.DEFAULT_IMAGE,t=Texture.DEFAULT_MAPPING,i=ue,r=ue,n=xe,s=be,a=Ne,o=Se,l=1,c=Dt){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:Ei++}),this.uuid=generateUUID(),this.name="",this.source=new Source(e),this.mipmaps=[],this.mapping=t,this.wrapS=i,this.wrapT=r,this.magFilter=n,this.minFilter=s,this.anisotropy=l,this.format=a,this.internalFormat=null,this.type=o,this.offset=new Vector2(0,0),this.repeat=new Vector2(1,1),this.center=new Vector2(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Matrix3,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=c,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(e){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return(new this.constructor).copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.encoding=e.encoding,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}toJSON(e){const t=void 0===e||"string"===typeof e;if(!t&&void 0!==e.textures[this.uuid])return e.textures[this.uuid];const i={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return"{}"!==JSON.stringify(this.userData)&&(i.userData=this.userData),t||(e.textures[this.uuid]=i),i}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==ne)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case he:e.x=e.x-Math.floor(e.x);break;case ue:e.x=e.x<0?0:1;break;case de:1===Math.abs(Math.floor(e.x)%2)?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x)}if(e.y<0||e.y>1)switch(this.wrapT){case he:e.y=e.y-Math.floor(e.y);break;case ue:e.y=e.y<0?0:1;break;case de:1===Math.abs(Math.floor(e.y)%2)?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y)}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){!0===e&&(this.version++,this.source.needsUpdate=!0)}}Texture.DEFAULT_IMAGE=null,Texture.DEFAULT_MAPPING=ne;class Vector4{constructor(e=0,t=0,i=0,r=1){Vector4.prototype.isVector4=!0,this.x=e,this.y=t,this.z=i,this.w=r}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,i,r){return this.x=e,this.y=t,this.z=i,this.w=r,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=void 0!==e.w?e.w:1,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,i=this.y,r=this.z,n=this.w,s=e.elements;return this.x=s[0]*t+s[4]*i+s[8]*r+s[12]*n,this.y=s[1]*t+s[5]*i+s[9]*r+s[13]*n,this.z=s[2]*t+s[6]*i+s[10]*r+s[14]*n,this.w=s[3]*t+s[7]*i+s[11]*r+s[15]*n,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,i,r,n;const s=.01,a=.1,o=e.elements,l=o[0],c=o[4],h=o[8],u=o[1],d=o[5],p=o[9],m=o[2],f=o[6],g=o[10];if(Math.abs(c-u)<s&&Math.abs(h-m)<s&&Math.abs(p-f)<s){if(Math.abs(c+u)<a&&Math.abs(h+m)<a&&Math.abs(p+f)<a&&Math.abs(l+d+g-3)<a)return this.set(1,0,0,0),this;t=Math.PI;const e=(l+1)/2,o=(d+1)/2,x=(g+1)/2,y=(c+u)/4,_=(h+m)/4,b=(p+f)/4;return e>o&&e>x?e<s?(i=0,r=.707106781,n=.707106781):(i=Math.sqrt(e),r=y/i,n=_/i):o>x?o<s?(i=.707106781,r=0,n=.707106781):(r=Math.sqrt(o),i=y/r,n=b/r):x<s?(i=.707106781,r=.707106781,n=0):(n=Math.sqrt(x),i=_/n,r=b/n),this.set(i,r,n,t),this}let x=Math.sqrt((f-p)*(f-p)+(h-m)*(h-m)+(u-c)*(u-c));return Math.abs(x)<.001&&(x=1),this.x=(f-p)/x,this.y=(h-m)/x,this.z=(u-c)/x,this.w=Math.acos((l+d+g-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(e,Math.min(t,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this.z=e.z+(t.z-e.z)*i,this.w=e.w+(t.w-e.w)*i,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class WebGLRenderTarget extends EventDispatcher{constructor(e,t,i={}){super(),this.isWebGLRenderTarget=!0,this.width=e,this.height=t,this.depth=1,this.scissor=new Vector4(0,0,e,t),this.scissorTest=!1,this.viewport=new Vector4(0,0,e,t);const r={width:e,height:t,depth:1};this.texture=new Texture(r,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.encoding),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=void 0!==i.generateMipmaps&&i.generateMipmaps,this.texture.internalFormat=void 0!==i.internalFormat?i.internalFormat:null,this.texture.minFilter=void 0!==i.minFilter?i.minFilter:xe,this.depthBuffer=void 0===i.depthBuffer||i.depthBuffer,this.stencilBuffer=void 0!==i.stencilBuffer&&i.stencilBuffer,this.depthTexture=void 0!==i.depthTexture?i.depthTexture:null,this.samples=void 0!==i.samples?i.samples:0}setSize(e,t,i=1){this.width===e&&this.height===t&&this.depth===i||(this.width=e,this.height=t,this.depth=i,this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=i,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return(new this.constructor).copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.texture.isRenderTargetTexture=!0;const t=Object.assign({},e.texture.image);return this.texture.source=new Source(t),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,null!==e.depthTexture&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class DataArrayTexture extends Texture{constructor(e=null,t=1,i=1,r=1){super(null),this.isDataArrayTexture=!0,this.image={data:e,width:t,height:i,depth:r},this.magFilter=pe,this.minFilter=pe,this.wrapR=ue,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class WebGLArrayRenderTarget extends WebGLRenderTarget{constructor(e,t,i){super(e,t),this.isWebGLArrayRenderTarget=!0,this.depth=i,this.texture=new DataArrayTexture(null,e,t,i),this.texture.isRenderTargetTexture=!0}}class Data3DTexture extends Texture{constructor(e=null,t=1,i=1,r=1){super(null),this.isData3DTexture=!0,this.image={data:e,width:t,height:i,depth:r},this.magFilter=pe,this.minFilter=pe,this.wrapR=ue,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class WebGL3DRenderTarget extends WebGLRenderTarget{constructor(e,t,i){super(e,t),this.isWebGL3DRenderTarget=!0,this.depth=i,this.texture=new Data3DTexture(null,e,t,i),this.texture.isRenderTargetTexture=!0}}class WebGLMultipleRenderTargets extends WebGLRenderTarget{constructor(e,t,i,r={}){super(e,t,r),this.isWebGLMultipleRenderTargets=!0;const n=this.texture;this.texture=[];for(let s=0;s<i;s++)this.texture[s]=n.clone(),this.texture[s].isRenderTargetTexture=!0}setSize(e,t,i=1){if(this.width!==e||this.height!==t||this.depth!==i){this.width=e,this.height=t,this.depth=i;for(let r=0,n=this.texture.length;r<n;r++)this.texture[r].image.width=e,this.texture[r].image.height=t,this.texture[r].image.depth=i;this.dispose()}return this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t),this}copy(e){this.dispose(),this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,null!==e.depthTexture&&(this.depthTexture=e.depthTexture.clone()),this.texture.length=0;for(let t=0,i=e.texture.length;t<i;t++)this.texture[t]=e.texture[t].clone(),this.texture[t].isRenderTargetTexture=!0;return this}}class Quaternion{constructor(e=0,t=0,i=0,r=1){this.isQuaternion=!0,this._x=e,this._y=t,this._z=i,this._w=r}static slerpFlat(e,t,i,r,n,s,a){let o=i[r+0],l=i[r+1],c=i[r+2],h=i[r+3];const u=n[s+0],d=n[s+1],p=n[s+2],m=n[s+3];if(0===a)return e[t+0]=o,e[t+1]=l,e[t+2]=c,void(e[t+3]=h);if(1===a)return e[t+0]=u,e[t+1]=d,e[t+2]=p,void(e[t+3]=m);if(h!==m||o!==u||l!==d||c!==p){let e=1-a;const t=o*u+l*d+c*p+h*m,i=t>=0?1:-1,r=1-t*t;if(r>Number.EPSILON){const n=Math.sqrt(r),s=Math.atan2(n,t*i);e=Math.sin(e*s)/n,a=Math.sin(a*s)/n}const n=a*i;if(o=o*e+u*n,l=l*e+d*n,c=c*e+p*n,h=h*e+m*n,e===1-a){const e=1/Math.sqrt(o*o+l*l+c*c+h*h);o*=e,l*=e,c*=e,h*=e}}e[t]=o,e[t+1]=l,e[t+2]=c,e[t+3]=h}static multiplyQuaternionsFlat(e,t,i,r,n,s){const a=i[r],o=i[r+1],l=i[r+2],c=i[r+3],h=n[s],u=n[s+1],d=n[s+2],p=n[s+3];return e[t]=a*p+c*h+o*d-l*u,e[t+1]=o*p+c*u+l*h-a*d,e[t+2]=l*p+c*d+a*u-o*h,e[t+3]=c*p-a*h-o*u-l*d,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,i,r){return this._x=e,this._y=t,this._z=i,this._w=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){if(!e||!e.isEuler)throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const i=e._x,r=e._y,n=e._z,s=e._order,a=Math.cos,o=Math.sin,l=a(i/2),c=a(r/2),h=a(n/2),u=o(i/2),d=o(r/2),p=o(n/2);switch(s){case"XYZ":this._x=u*c*h+l*d*p,this._y=l*d*h-u*c*p,this._z=l*c*p+u*d*h,this._w=l*c*h-u*d*p;break;case"YXZ":this._x=u*c*h+l*d*p,this._y=l*d*h-u*c*p,this._z=l*c*p-u*d*h,this._w=l*c*h+u*d*p;break;case"ZXY":this._x=u*c*h-l*d*p,this._y=l*d*h+u*c*p,this._z=l*c*p+u*d*h,this._w=l*c*h-u*d*p;break;case"ZYX":this._x=u*c*h-l*d*p,this._y=l*d*h+u*c*p,this._z=l*c*p-u*d*h,this._w=l*c*h+u*d*p;break;case"YZX":this._x=u*c*h+l*d*p,this._y=l*d*h+u*c*p,this._z=l*c*p-u*d*h,this._w=l*c*h-u*d*p;break;case"XZY":this._x=u*c*h-l*d*p,this._y=l*d*h-u*c*p,this._z=l*c*p+u*d*h,this._w=l*c*h+u*d*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+s)}return!1!==t&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const i=t/2,r=Math.sin(i);return this._x=e.x*r,this._y=e.y*r,this._z=e.z*r,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,i=t[0],r=t[4],n=t[8],s=t[1],a=t[5],o=t[9],l=t[2],c=t[6],h=t[10],u=i+a+h;if(u>0){const e=.5/Math.sqrt(u+1);this._w=.25/e,this._x=(c-o)*e,this._y=(n-l)*e,this._z=(s-r)*e}else if(i>a&&i>h){const e=2*Math.sqrt(1+i-a-h);this._w=(c-o)/e,this._x=.25*e,this._y=(r+s)/e,this._z=(n+l)/e}else if(a>h){const e=2*Math.sqrt(1+a-i-h);this._w=(n-l)/e,this._x=(r+s)/e,this._y=.25*e,this._z=(o+c)/e}else{const e=2*Math.sqrt(1+h-i-a);this._w=(s-r)/e,this._x=(n+l)/e,this._y=(o+c)/e,this._z=.25*e}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let i=e.dot(t)+1;return i<Number.EPSILON?(i=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=i):(this._x=0,this._y=-e.z,this._z=e.y,this._w=i)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=i),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(clamp(this.dot(e),-1,1)))}rotateTowards(e,t){const i=this.angleTo(e);if(0===i)return this;const r=Math.min(1,t/i);return this.slerp(e,r),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return 0===e?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e){return this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const i=e._x,r=e._y,n=e._z,s=e._w,a=t._x,o=t._y,l=t._z,c=t._w;return this._x=i*c+s*a+r*l-n*o,this._y=r*c+s*o+n*a-i*l,this._z=n*c+s*l+i*o-r*a,this._w=s*c-i*a-r*o-n*l,this._onChangeCallback(),this}slerp(e,t){if(0===t)return this;if(1===t)return this.copy(e);const i=this._x,r=this._y,n=this._z,s=this._w;let a=s*e._w+i*e._x+r*e._y+n*e._z;if(a<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,a=-a):this.copy(e),a>=1)return this._w=s,this._x=i,this._y=r,this._z=n,this;const o=1-a*a;if(o<=Number.EPSILON){const e=1-t;return this._w=e*s+t*this._w,this._x=e*i+t*this._x,this._y=e*r+t*this._y,this._z=e*n+t*this._z,this.normalize(),this._onChangeCallback(),this}const l=Math.sqrt(o),c=Math.atan2(l,a),h=Math.sin((1-t)*c)/l,u=Math.sin(t*c)/l;return this._w=s*h+this._w*u,this._x=i*h+this._x*u,this._y=r*h+this._y*u,this._z=n*h+this._z*u,this._onChangeCallback(),this}slerpQuaternions(e,t,i){return this.copy(e).slerp(t,i)}random(){const e=Math.random(),t=Math.sqrt(1-e),i=Math.sqrt(e),r=2*Math.PI*Math.random(),n=2*Math.PI*Math.random();return this.set(t*Math.cos(r),i*Math.sin(n),i*Math.cos(n),t*Math.sin(r))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class Vector3{constructor(e=0,t=0,i=0){Vector3.prototype.isVector3=!0,this.x=e,this.y=t,this.z=i}set(e,t,i){return void 0===i&&(i=this.z),this.x=e,this.y=t,this.z=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return this.applyQuaternion(Pi.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(Pi.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,i=this.y,r=this.z,n=e.elements;return this.x=n[0]*t+n[3]*i+n[6]*r,this.y=n[1]*t+n[4]*i+n[7]*r,this.z=n[2]*t+n[5]*i+n[8]*r,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,i=this.y,r=this.z,n=e.elements,s=1/(n[3]*t+n[7]*i+n[11]*r+n[15]);return this.x=(n[0]*t+n[4]*i+n[8]*r+n[12])*s,this.y=(n[1]*t+n[5]*i+n[9]*r+n[13])*s,this.z=(n[2]*t+n[6]*i+n[10]*r+n[14])*s,this}applyQuaternion(e){const t=this.x,i=this.y,r=this.z,n=e.x,s=e.y,a=e.z,o=e.w,l=o*t+s*r-a*i,c=o*i+a*t-n*r,h=o*r+n*i-s*t,u=-n*t-s*i-a*r;return this.x=l*o+u*-n+c*-a-h*-s,this.y=c*o+u*-s+h*-n-l*-a,this.z=h*o+u*-a+l*-s-c*-n,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,i=this.y,r=this.z,n=e.elements;return this.x=n[0]*t+n[4]*i+n[8]*r,this.y=n[1]*t+n[5]*i+n[9]*r,this.z=n[2]*t+n[6]*i+n[10]*r,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(e,Math.min(t,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,i){return this.x=e.x+(t.x-e.x)*i,this.y=e.y+(t.y-e.y)*i,this.z=e.z+(t.z-e.z)*i,this}cross(e){return this.crossVectors(this,e)}crossVectors(e,t){const i=e.x,r=e.y,n=e.z,s=t.x,a=t.y,o=t.z;return this.x=r*o-n*a,this.y=n*s-i*o,this.z=i*a-r*s,this}projectOnVector(e){const t=e.lengthSq();if(0===t)return this.set(0,0,0);const i=e.dot(this)/t;return this.copy(e).multiplyScalar(i)}projectOnPlane(e){return Li.copy(this).projectOnVector(e),this.sub(Li)}reflect(e){return this.sub(Li.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(0===t)return Math.PI/2;const i=this.dot(e)/t;return Math.acos(clamp(i,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,i=this.y-e.y,r=this.z-e.z;return t*t+i*i+r*r}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,i){const r=Math.sin(t)*e;return this.x=r*Math.sin(i),this.y=Math.cos(t)*e,this.z=r*Math.cos(i),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,i){return this.x=e*Math.sin(t),this.y=i,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),i=this.setFromMatrixColumn(e,1).length(),r=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=i,this.z=r,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,4*t)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,3*t)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=2*(Math.random()-.5),t=Math.random()*Math.PI*2,i=Math.sqrt(1-e**2);return this.x=i*Math.cos(t),this.y=i*Math.sin(t),this.z=e,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const Li=new Vector3,Pi=new Quaternion;class Box3{constructor(e=new Vector3(1/0,1/0,1/0),t=new Vector3(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){let t=1/0,i=1/0,r=1/0,n=-1/0,s=-1/0,a=-1/0;for(let o=0,l=e.length;o<l;o+=3){const l=e[o],c=e[o+1],h=e[o+2];l<t&&(t=l),c<i&&(i=c),h<r&&(r=h),l>n&&(n=l),c>s&&(s=c),h>a&&(a=h)}return this.min.set(t,i,r),this.max.set(n,s,a),this}setFromBufferAttribute(e){let t=1/0,i=1/0,r=1/0,n=-1/0,s=-1/0,a=-1/0;for(let o=0,l=e.count;o<l;o++){const l=e.getX(o),c=e.getY(o),h=e.getZ(o);l<t&&(t=l),c<i&&(i=c),h<r&&(r=h),l>n&&(n=l),c>s&&(s=c),h>a&&(a=h)}return this.min.set(t,i,r),this.max.set(n,s,a),this}setFromPoints(e){this.makeEmpty();for(let t=0,i=e.length;t<i;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const i=Di.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(i),this.max.copy(e).add(i),this}setFromObject(e,t=!1){return this.makeEmpty(),this.expandByObject(e,t)}clone(){return(new this.constructor).copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,t=!1){e.updateWorldMatrix(!1,!1);const i=e.geometry;if(void 0!==i)if(t&&void 0!=i.attributes&&void 0!==i.attributes.position){const t=i.attributes.position;for(let i=0,r=t.count;i<r;i++)Di.fromBufferAttribute(t,i).applyMatrix4(e.matrixWorld),this.expandByPoint(Di)}else null===i.boundingBox&&i.computeBoundingBox(),Ii.copy(i.boundingBox),Ii.applyMatrix4(e.matrixWorld),this.union(Ii);const r=e.children;for(let n=0,s=r.length;n<s;n++)this.expandByObject(r[n],t);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,Di),Di.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,i;return e.normal.x>0?(t=e.normal.x*this.min.x,i=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,i=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,i+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,i+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,i+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,i+=e.normal.z*this.min.z),t<=-e.constant&&i>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(Gi),Ui.subVectors(this.max,Gi),Bi.subVectors(e.a,Gi),Vi.subVectors(e.b,Gi),Ni.subVectors(e.c,Gi),Oi.subVectors(Vi,Bi),zi.subVectors(Ni,Vi),Fi.subVectors(Bi,Ni);let t=[0,-Oi.z,Oi.y,0,-zi.z,zi.y,0,-Fi.z,Fi.y,Oi.z,0,-Oi.x,zi.z,0,-zi.x,Fi.z,0,-Fi.x,-Oi.y,Oi.x,0,-zi.y,zi.x,0,-Fi.y,Fi.x,0];return!!satForAxes(t,Bi,Vi,Ni,Ui)&&(t=[1,0,0,0,1,0,0,0,1],!!satForAxes(t,Bi,Vi,Ni,Ui)&&(ki.crossVectors(Oi,zi),t=[ki.x,ki.y,ki.z],satForAxes(t,Bi,Vi,Ni,Ui)))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return Di.copy(e).clamp(this.min,this.max).sub(e).length()}getBoundingSphere(e){return this.getCenter(e.center),e.radius=.5*this.getSize(Di).length(),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()||(Ri[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),Ri[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),Ri[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),Ri[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),Ri[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),Ri[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),Ri[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),Ri[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(Ri)),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const Ri=[new Vector3,new Vector3,new Vector3,new Vector3,new Vector3,new Vector3,new Vector3,new Vector3],Di=new Vector3,Ii=new Box3,Bi=new Vector3,Vi=new Vector3,Ni=new Vector3,Oi=new Vector3,zi=new Vector3,Fi=new Vector3,Gi=new Vector3,Ui=new Vector3,ki=new Vector3,Wi=new Vector3;function satForAxes(e,t,i,r,n){for(let s=0,a=e.length-3;s<=a;s+=3){Wi.fromArray(e,s);const a=n.x*Math.abs(Wi.x)+n.y*Math.abs(Wi.y)+n.z*Math.abs(Wi.z),o=t.dot(Wi),l=i.dot(Wi),c=r.dot(Wi);if(Math.max(-Math.max(o,l,c),Math.min(o,l,c))>a)return!1}return!0}const Hi=new Box3,ji=new Vector3,qi=new Vector3,Xi=new Vector3;class Sphere{constructor(e=new Vector3,t=-1){this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const i=this.center;void 0!==t?i.copy(t):Hi.setFromPoints(e).getCenter(i);let r=0;for(let n=0,s=e.length;n<s;n++)r=Math.max(r,i.distanceToSquared(e[n]));return this.radius=Math.sqrt(r),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const i=this.center.distanceToSquared(e);return t.copy(e),i>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){Xi.subVectors(e,this.center);const t=Xi.lengthSq();if(t>this.radius*this.radius){const e=Math.sqrt(t),i=.5*(e-this.radius);this.center.add(Xi.multiplyScalar(i/e)),this.radius+=i}return this}union(e){return!0===this.center.equals(e.center)?qi.set(0,0,1).multiplyScalar(e.radius):qi.subVectors(e.center,this.center).normalize().multiplyScalar(e.radius),this.expandByPoint(ji.copy(e.center).add(qi)),this.expandByPoint(ji.copy(e.center).sub(qi)),this}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return(new this.constructor).copy(this)}}const Yi=new Vector3,Zi=new Vector3,Ji=new Vector3,Ki=new Vector3,Qi=new Vector3,$i=new Vector3,er=new Vector3;class Ray{constructor(e=new Vector3,t=new Vector3(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.direction).multiplyScalar(e).add(this.origin)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,Yi)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const i=t.dot(this.direction);return i<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(i).add(this.origin)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=Yi.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(Yi.copy(this.direction).multiplyScalar(t).add(this.origin),Yi.distanceToSquared(e))}distanceSqToSegment(e,t,i,r){Zi.copy(e).add(t).multiplyScalar(.5),Ji.copy(t).sub(e).normalize(),Ki.copy(this.origin).sub(Zi);const n=.5*e.distanceTo(t),s=-this.direction.dot(Ji),a=Ki.dot(this.direction),o=-Ki.dot(Ji),l=Ki.lengthSq(),c=Math.abs(1-s*s);let h,u,d,p;if(c>0)if(h=s*o-a,u=s*a-o,p=n*c,h>=0)if(u>=-p)if(u<=p){const e=1/c;h*=e,u*=e,d=h*(h+s*u+2*a)+u*(s*h+u+2*o)+l}else u=n,h=Math.max(0,-(s*u+a)),d=-h*h+u*(u+2*o)+l;else u=-n,h=Math.max(0,-(s*u+a)),d=-h*h+u*(u+2*o)+l;else u<=-p?(h=Math.max(0,-(-s*n+a)),u=h>0?-n:Math.min(Math.max(-n,-o),n),d=-h*h+u*(u+2*o)+l):u<=p?(h=0,u=Math.min(Math.max(-n,-o),n),d=u*(u+2*o)+l):(h=Math.max(0,-(s*n+a)),u=h>0?n:Math.min(Math.max(-n,-o),n),d=-h*h+u*(u+2*o)+l);else u=s>0?-n:n,h=Math.max(0,-(s*u+a)),d=-h*h+u*(u+2*o)+l;return i&&i.copy(this.direction).multiplyScalar(h).add(this.origin),r&&r.copy(Ji).multiplyScalar(u).add(Zi),d}intersectSphere(e,t){Yi.subVectors(e.center,this.origin);const i=Yi.dot(this.direction),r=Yi.dot(Yi)-i*i,n=e.radius*e.radius;if(r>n)return null;const s=Math.sqrt(n-r),a=i-s,o=i+s;return a<0&&o<0?null:a<0?this.at(o,t):this.at(a,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(0===t)return 0===e.distanceToPoint(this.origin)?0:null;const i=-(this.origin.dot(e.normal)+e.constant)/t;return i>=0?i:null}intersectPlane(e,t){const i=this.distanceToPlane(e);return null===i?null:this.at(i,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);if(0===t)return!0;return e.normal.dot(this.direction)*t<0}intersectBox(e,t){let i,r,n,s,a,o;const l=1/this.direction.x,c=1/this.direction.y,h=1/this.direction.z,u=this.origin;return l>=0?(i=(e.min.x-u.x)*l,r=(e.max.x-u.x)*l):(i=(e.max.x-u.x)*l,r=(e.min.x-u.x)*l),c>=0?(n=(e.min.y-u.y)*c,s=(e.max.y-u.y)*c):(n=(e.max.y-u.y)*c,s=(e.min.y-u.y)*c),i>s||n>r?null:((n>i||i!==i)&&(i=n),(s<r||r!==r)&&(r=s),h>=0?(a=(e.min.z-u.z)*h,o=(e.max.z-u.z)*h):(a=(e.max.z-u.z)*h,o=(e.min.z-u.z)*h),i>o||a>r?null:((a>i||i!==i)&&(i=a),(o<r||r!==r)&&(r=o),r<0?null:this.at(i>=0?i:r,t)))}intersectsBox(e){return null!==this.intersectBox(e,Yi)}intersectTriangle(e,t,i,r,n){Qi.subVectors(t,e),$i.subVectors(i,e),er.crossVectors(Qi,$i);let s,a=this.direction.dot(er);if(a>0){if(r)return null;s=1}else{if(!(a<0))return null;s=-1,a=-a}Ki.subVectors(this.origin,e);const o=s*this.direction.dot($i.crossVectors(Ki,$i));if(o<0)return null;const l=s*this.direction.dot(Qi.cross(Ki));if(l<0)return null;if(o+l>a)return null;const c=-s*Ki.dot(er);return c<0?null:this.at(c/a,n)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return(new this.constructor).copy(this)}}class Matrix4{constructor(){Matrix4.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}set(e,t,i,r,n,s,a,o,l,c,h,u,d,p,m,f){const g=this.elements;return g[0]=e,g[4]=t,g[8]=i,g[12]=r,g[1]=n,g[5]=s,g[9]=a,g[13]=o,g[2]=l,g[6]=c,g[10]=h,g[14]=u,g[3]=d,g[7]=p,g[11]=m,g[15]=f,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new Matrix4).fromArray(this.elements)}copy(e){const t=this.elements,i=e.elements;return t[0]=i[0],t[1]=i[1],t[2]=i[2],t[3]=i[3],t[4]=i[4],t[5]=i[5],t[6]=i[6],t[7]=i[7],t[8]=i[8],t[9]=i[9],t[10]=i[10],t[11]=i[11],t[12]=i[12],t[13]=i[13],t[14]=i[14],t[15]=i[15],this}copyPosition(e){const t=this.elements,i=e.elements;return t[12]=i[12],t[13]=i[13],t[14]=i[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,i){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this}makeBasis(e,t,i){return this.set(e.x,t.x,i.x,0,e.y,t.y,i.y,0,e.z,t.z,i.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,i=e.elements,r=1/tr.setFromMatrixColumn(e,0).length(),n=1/tr.setFromMatrixColumn(e,1).length(),s=1/tr.setFromMatrixColumn(e,2).length();return t[0]=i[0]*r,t[1]=i[1]*r,t[2]=i[2]*r,t[3]=0,t[4]=i[4]*n,t[5]=i[5]*n,t[6]=i[6]*n,t[7]=0,t[8]=i[8]*s,t[9]=i[9]*s,t[10]=i[10]*s,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){const t=this.elements,i=e.x,r=e.y,n=e.z,s=Math.cos(i),a=Math.sin(i),o=Math.cos(r),l=Math.sin(r),c=Math.cos(n),h=Math.sin(n);if("XYZ"===e.order){const e=s*c,i=s*h,r=a*c,n=a*h;t[0]=o*c,t[4]=-o*h,t[8]=l,t[1]=i+r*l,t[5]=e-n*l,t[9]=-a*o,t[2]=n-e*l,t[6]=r+i*l,t[10]=s*o}else if("YXZ"===e.order){const e=o*c,i=o*h,r=l*c,n=l*h;t[0]=e+n*a,t[4]=r*a-i,t[8]=s*l,t[1]=s*h,t[5]=s*c,t[9]=-a,t[2]=i*a-r,t[6]=n+e*a,t[10]=s*o}else if("ZXY"===e.order){const e=o*c,i=o*h,r=l*c,n=l*h;t[0]=e-n*a,t[4]=-s*h,t[8]=r+i*a,t[1]=i+r*a,t[5]=s*c,t[9]=n-e*a,t[2]=-s*l,t[6]=a,t[10]=s*o}else if("ZYX"===e.order){const e=s*c,i=s*h,r=a*c,n=a*h;t[0]=o*c,t[4]=r*l-i,t[8]=e*l+n,t[1]=o*h,t[5]=n*l+e,t[9]=i*l-r,t[2]=-l,t[6]=a*o,t[10]=s*o}else if("YZX"===e.order){const e=s*o,i=s*l,r=a*o,n=a*l;t[0]=o*c,t[4]=n-e*h,t[8]=r*h+i,t[1]=h,t[5]=s*c,t[9]=-a*c,t[2]=-l*c,t[6]=i*h+r,t[10]=e-n*h}else if("XZY"===e.order){const e=s*o,i=s*l,r=a*o,n=a*l;t[0]=o*c,t[4]=-h,t[8]=l*c,t[1]=e*h+n,t[5]=s*c,t[9]=i*h-r,t[2]=r*h-i,t[6]=a*c,t[10]=n*h+e}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(rr,e,nr)}lookAt(e,t,i){const r=this.elements;return or.subVectors(e,t),0===or.lengthSq()&&(or.z=1),or.normalize(),sr.crossVectors(i,or),0===sr.lengthSq()&&(1===Math.abs(i.z)?or.x+=1e-4:or.z+=1e-4,or.normalize(),sr.crossVectors(i,or)),sr.normalize(),ar.crossVectors(or,sr),r[0]=sr.x,r[4]=ar.x,r[8]=or.x,r[1]=sr.y,r[5]=ar.y,r[9]=or.y,r[2]=sr.z,r[6]=ar.z,r[10]=or.z,this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const i=e.elements,r=t.elements,n=this.elements,s=i[0],a=i[4],o=i[8],l=i[12],c=i[1],h=i[5],u=i[9],d=i[13],p=i[2],m=i[6],f=i[10],g=i[14],x=i[3],y=i[7],_=i[11],b=i[15],M=r[0],S=r[4],w=r[8],T=r[12],A=r[1],C=r[5],E=r[9],L=r[13],P=r[2],R=r[6],D=r[10],I=r[14],B=r[3],V=r[7],N=r[11],O=r[15];return n[0]=s*M+a*A+o*P+l*B,n[4]=s*S+a*C+o*R+l*V,n[8]=s*w+a*E+o*D+l*N,n[12]=s*T+a*L+o*I+l*O,n[1]=c*M+h*A+u*P+d*B,n[5]=c*S+h*C+u*R+d*V,n[9]=c*w+h*E+u*D+d*N,n[13]=c*T+h*L+u*I+d*O,n[2]=p*M+m*A+f*P+g*B,n[6]=p*S+m*C+f*R+g*V,n[10]=p*w+m*E+f*D+g*N,n[14]=p*T+m*L+f*I+g*O,n[3]=x*M+y*A+_*P+b*B,n[7]=x*S+y*C+_*R+b*V,n[11]=x*w+y*E+_*D+b*N,n[15]=x*T+y*L+_*I+b*O,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],i=e[4],r=e[8],n=e[12],s=e[1],a=e[5],o=e[9],l=e[13],c=e[2],h=e[6],u=e[10],d=e[14];return e[3]*(+n*o*h-r*l*h-n*a*u+i*l*u+r*a*d-i*o*d)+e[7]*(+t*o*d-t*l*u+n*s*u-r*s*d+r*l*c-n*o*c)+e[11]*(+t*l*h-t*a*d-n*s*h+i*s*d+n*a*c-i*l*c)+e[15]*(-r*a*c-t*o*h+t*a*u+r*s*h-i*s*u+i*o*c)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,i){const r=this.elements;return e.isVector3?(r[12]=e.x,r[13]=e.y,r[14]=e.z):(r[12]=e,r[13]=t,r[14]=i),this}invert(){const e=this.elements,t=e[0],i=e[1],r=e[2],n=e[3],s=e[4],a=e[5],o=e[6],l=e[7],c=e[8],h=e[9],u=e[10],d=e[11],p=e[12],m=e[13],f=e[14],g=e[15],x=h*f*l-m*u*l+m*o*d-a*f*d-h*o*g+a*u*g,y=p*u*l-c*f*l-p*o*d+s*f*d+c*o*g-s*u*g,_=c*m*l-p*h*l+p*a*d-s*m*d-c*a*g+s*h*g,b=p*h*o-c*m*o-p*a*u+s*m*u+c*a*f-s*h*f,M=t*x+i*y+r*_+n*b;if(0===M)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const S=1/M;return e[0]=x*S,e[1]=(m*u*n-h*f*n-m*r*d+i*f*d+h*r*g-i*u*g)*S,e[2]=(a*f*n-m*o*n+m*r*l-i*f*l-a*r*g+i*o*g)*S,e[3]=(h*o*n-a*u*n-h*r*l+i*u*l+a*r*d-i*o*d)*S,e[4]=y*S,e[5]=(c*f*n-p*u*n+p*r*d-t*f*d-c*r*g+t*u*g)*S,e[6]=(p*o*n-s*f*n-p*r*l+t*f*l+s*r*g-t*o*g)*S,e[7]=(s*u*n-c*o*n+c*r*l-t*u*l-s*r*d+t*o*d)*S,e[8]=_*S,e[9]=(p*h*n-c*m*n-p*i*d+t*m*d+c*i*g-t*h*g)*S,e[10]=(s*m*n-p*a*n+p*i*l-t*m*l-s*i*g+t*a*g)*S,e[11]=(c*a*n-s*h*n-c*i*l+t*h*l+s*i*d-t*a*d)*S,e[12]=b*S,e[13]=(c*m*r-p*h*r+p*i*u-t*m*u-c*i*f+t*h*f)*S,e[14]=(p*a*r-s*m*r-p*i*o+t*m*o+s*i*f-t*a*f)*S,e[15]=(s*h*r-c*a*r+c*i*o-t*h*o-s*i*u+t*a*u)*S,this}scale(e){const t=this.elements,i=e.x,r=e.y,n=e.z;return t[0]*=i,t[4]*=r,t[8]*=n,t[1]*=i,t[5]*=r,t[9]*=n,t[2]*=i,t[6]*=r,t[10]*=n,t[3]*=i,t[7]*=r,t[11]*=n,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],i=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],r=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,i,r))}makeTranslation(e,t,i){return this.set(1,0,0,e,0,1,0,t,0,0,1,i,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),i=Math.sin(e);return this.set(1,0,0,0,0,t,-i,0,0,i,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),i=Math.sin(e);return this.set(t,0,i,0,0,1,0,0,-i,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),i=Math.sin(e);return this.set(t,-i,0,0,i,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const i=Math.cos(t),r=Math.sin(t),n=1-i,s=e.x,a=e.y,o=e.z,l=n*s,c=n*a;return this.set(l*s+i,l*a-r*o,l*o+r*a,0,l*a+r*o,c*a+i,c*o-r*s,0,l*o-r*a,c*o+r*s,n*o*o+i,0,0,0,0,1),this}makeScale(e,t,i){return this.set(e,0,0,0,0,t,0,0,0,0,i,0,0,0,0,1),this}makeShear(e,t,i,r,n,s){return this.set(1,i,n,0,e,1,s,0,t,r,1,0,0,0,0,1),this}compose(e,t,i){const r=this.elements,n=t._x,s=t._y,a=t._z,o=t._w,l=n+n,c=s+s,h=a+a,u=n*l,d=n*c,p=n*h,m=s*c,f=s*h,g=a*h,x=o*l,y=o*c,_=o*h,b=i.x,M=i.y,S=i.z;return r[0]=(1-(m+g))*b,r[1]=(d+_)*b,r[2]=(p-y)*b,r[3]=0,r[4]=(d-_)*M,r[5]=(1-(u+g))*M,r[6]=(f+x)*M,r[7]=0,r[8]=(p+y)*S,r[9]=(f-x)*S,r[10]=(1-(u+m))*S,r[11]=0,r[12]=e.x,r[13]=e.y,r[14]=e.z,r[15]=1,this}decompose(e,t,i){const r=this.elements;let n=tr.set(r[0],r[1],r[2]).length();const s=tr.set(r[4],r[5],r[6]).length(),a=tr.set(r[8],r[9],r[10]).length();this.determinant()<0&&(n=-n),e.x=r[12],e.y=r[13],e.z=r[14],ir.copy(this);const o=1/n,l=1/s,c=1/a;return ir.elements[0]*=o,ir.elements[1]*=o,ir.elements[2]*=o,ir.elements[4]*=l,ir.elements[5]*=l,ir.elements[6]*=l,ir.elements[8]*=c,ir.elements[9]*=c,ir.elements[10]*=c,t.setFromRotationMatrix(ir),i.x=n,i.y=s,i.z=a,this}makePerspective(e,t,i,r,n,s){const a=this.elements,o=2*n/(t-e),l=2*n/(i-r),c=(t+e)/(t-e),h=(i+r)/(i-r),u=-(s+n)/(s-n),d=-2*s*n/(s-n);return a[0]=o,a[4]=0,a[8]=c,a[12]=0,a[1]=0,a[5]=l,a[9]=h,a[13]=0,a[2]=0,a[6]=0,a[10]=u,a[14]=d,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(e,t,i,r,n,s){const a=this.elements,o=1/(t-e),l=1/(i-r),c=1/(s-n),h=(t+e)*o,u=(i+r)*l,d=(s+n)*c;return a[0]=2*o,a[4]=0,a[8]=0,a[12]=-h,a[1]=0,a[5]=2*l,a[9]=0,a[13]=-u,a[2]=0,a[6]=0,a[10]=-2*c,a[14]=-d,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(e){const t=this.elements,i=e.elements;for(let r=0;r<16;r++)if(t[r]!==i[r])return!1;return!0}fromArray(e,t=0){for(let i=0;i<16;i++)this.elements[i]=e[i+t];return this}toArray(e=[],t=0){const i=this.elements;return e[t]=i[0],e[t+1]=i[1],e[t+2]=i[2],e[t+3]=i[3],e[t+4]=i[4],e[t+5]=i[5],e[t+6]=i[6],e[t+7]=i[7],e[t+8]=i[8],e[t+9]=i[9],e[t+10]=i[10],e[t+11]=i[11],e[t+12]=i[12],e[t+13]=i[13],e[t+14]=i[14],e[t+15]=i[15],e}}const tr=new Vector3,ir=new Matrix4,rr=new Vector3(0,0,0),nr=new Vector3(1,1,1),sr=new Vector3,ar=new Vector3,or=new Vector3,lr=new Matrix4,cr=new Quaternion;class Euler{constructor(e=0,t=0,i=0,r=Euler.DefaultOrder){this.isEuler=!0,this._x=e,this._y=t,this._z=i,this._order=r}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,i,r=this._order){return this._x=e,this._y=t,this._z=i,this._order=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,i=!0){const r=e.elements,n=r[0],s=r[4],a=r[8],o=r[1],l=r[5],c=r[9],h=r[2],u=r[6],d=r[10];switch(t){case"XYZ":this._y=Math.asin(clamp(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-c,d),this._z=Math.atan2(-s,n)):(this._x=Math.atan2(u,l),this._z=0);break;case"YXZ":this._x=Math.asin(-clamp(c,-1,1)),Math.abs(c)<.9999999?(this._y=Math.atan2(a,d),this._z=Math.atan2(o,l)):(this._y=Math.atan2(-h,n),this._z=0);break;case"ZXY":this._x=Math.asin(clamp(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(-h,d),this._z=Math.atan2(-s,l)):(this._y=0,this._z=Math.atan2(o,n));break;case"ZYX":this._y=Math.asin(-clamp(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(u,d),this._z=Math.atan2(o,n)):(this._x=0,this._z=Math.atan2(-s,l));break;case"YZX":this._z=Math.asin(clamp(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-c,l),this._y=Math.atan2(-h,n)):(this._x=0,this._y=Math.atan2(a,d));break;case"XZY":this._z=Math.asin(-clamp(s,-1,1)),Math.abs(s)<.9999999?(this._x=Math.atan2(u,l),this._y=Math.atan2(a,n)):(this._x=Math.atan2(-c,d),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,!0===i&&this._onChangeCallback(),this}setFromQuaternion(e,t,i){return lr.makeRotationFromQuaternion(e),this.setFromRotationMatrix(lr,t,i)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return cr.setFromEuler(this),this.setFromQuaternion(cr,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],void 0!==e[3]&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}toVector3(){console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")}}Euler.DefaultOrder="XYZ",Euler.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class Layers{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return 0!==(this.mask&e.mask)}isEnabled(e){return 0!==(this.mask&(1<<e|0))}}let hr=0;const ur=new Vector3,dr=new Quaternion,pr=new Matrix4,mr=new Vector3,fr=new Vector3,gr=new Vector3,vr=new Quaternion,xr=new Vector3(1,0,0),yr=new Vector3(0,1,0),_r=new Vector3(0,0,1),br={type:"added"},Mr={type:"removed"};class Object3D extends EventDispatcher{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:hr++}),this.uuid=generateUUID(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Object3D.DefaultUp.clone();const e=new Vector3,t=new Euler,i=new Quaternion,r=new Vector3(1,1,1);t._onChange((function onRotationChange(){i.setFromEuler(t,!1)})),i._onChange((function onQuaternionChange(){t.setFromQuaternion(i,void 0,!1)})),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:i},scale:{configurable:!0,enumerable:!0,value:r},modelViewMatrix:{value:new Matrix4},normalMatrix:{value:new Matrix3}}),this.matrix=new Matrix4,this.matrixWorld=new Matrix4,this.matrixAutoUpdate=Object3D.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new Layers,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return dr.setFromAxisAngle(e,t),this.quaternion.multiply(dr),this}rotateOnWorldAxis(e,t){return dr.setFromAxisAngle(e,t),this.quaternion.premultiply(dr),this}rotateX(e){return this.rotateOnAxis(xr,e)}rotateY(e){return this.rotateOnAxis(yr,e)}rotateZ(e){return this.rotateOnAxis(_r,e)}translateOnAxis(e,t){return ur.copy(e).applyQuaternion(this.quaternion),this.position.add(ur.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(xr,e)}translateY(e){return this.translateOnAxis(yr,e)}translateZ(e){return this.translateOnAxis(_r,e)}localToWorld(e){return e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return e.applyMatrix4(pr.copy(this.matrixWorld).invert())}lookAt(e,t,i){e.isVector3?mr.copy(e):mr.set(e,t,i);const r=this.parent;this.updateWorldMatrix(!0,!1),fr.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?pr.lookAt(fr,mr,this.up):pr.lookAt(mr,fr,this.up),this.quaternion.setFromRotationMatrix(pr),r&&(pr.extractRotation(r.matrixWorld),dr.setFromRotationMatrix(pr),this.quaternion.premultiply(dr.invert()))}add(e){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(null!==e.parent&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(br)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.remove(arguments[e]);return this}const t=this.children.indexOf(e);return-1!==t&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(Mr)),this}removeFromParent(){const e=this.parent;return null!==e&&e.remove(this),this}clear(){for(let e=0;e<this.children.length;e++){const t=this.children[e];t.parent=null,t.dispatchEvent(Mr)}return this.children.length=0,this}attach(e){return this.updateWorldMatrix(!0,!1),pr.copy(this.matrixWorld).invert(),null!==e.parent&&(e.parent.updateWorldMatrix(!0,!1),pr.multiply(e.parent.matrixWorld)),e.applyMatrix4(pr),this.add(e),e.updateWorldMatrix(!1,!0),this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let i=0,r=this.children.length;i<r;i++){const r=this.children[i].getObjectByProperty(e,t);if(void 0!==r)return r}}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(fr,e,gr),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(fr,vr,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let i=0,r=t.length;i<r;i++)t[i].traverse(e)}traverseVisible(e){if(!1===this.visible)return;e(this);const t=this.children;for(let i=0,r=t.length;i<r;i++)t[i].traverseVisible(e)}traverseAncestors(e){const t=this.parent;null!==t&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let i=0,r=t.length;i<r;i++)t[i].updateMatrixWorld(e)}updateWorldMatrix(e,t){const i=this.parent;if(!0===e&&null!==i&&i.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===t){const e=this.children;for(let t=0,i=e.length;t<i;t++)e[t].updateWorldMatrix(!1,!0)}}toJSON(e){const t=void 0===e||"string"===typeof e,i={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},i.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const r={};function serialize(t,i){return void 0===t[i.uuid]&&(t[i.uuid]=i.toJSON(e)),i.uuid}if(r.uuid=this.uuid,r.type=this.type,""!==this.name&&(r.name=this.name),!0===this.castShadow&&(r.castShadow=!0),!0===this.receiveShadow&&(r.receiveShadow=!0),!1===this.visible&&(r.visible=!1),!1===this.frustumCulled&&(r.frustumCulled=!1),0!==this.renderOrder&&(r.renderOrder=this.renderOrder),"{}"!==JSON.stringify(this.userData)&&(r.userData=this.userData),r.layers=this.layers.mask,r.matrix=this.matrix.toArray(),!1===this.matrixAutoUpdate&&(r.matrixAutoUpdate=!1),this.isInstancedMesh&&(r.type="InstancedMesh",r.count=this.count,r.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(r.instanceColor=this.instanceColor.toJSON())),this.isScene)this.background&&(this.background.isColor?r.background=this.background.toJSON():this.background.isTexture&&(r.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&!0!==this.environment.isRenderTargetTexture&&(r.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){r.geometry=serialize(e.geometries,this.geometry);const t=this.geometry.parameters;if(void 0!==t&&void 0!==t.shapes){const i=t.shapes;if(Array.isArray(i))for(let t=0,r=i.length;t<r;t++){const r=i[t];serialize(e.shapes,r)}else serialize(e.shapes,i)}}if(this.isSkinnedMesh&&(r.bindMode=this.bindMode,r.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(serialize(e.skeletons,this.skeleton),r.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){const t=[];for(let i=0,r=this.material.length;i<r;i++)t.push(serialize(e.materials,this.material[i]));r.material=t}else r.material=serialize(e.materials,this.material);if(this.children.length>0){r.children=[];for(let t=0;t<this.children.length;t++)r.children.push(this.children[t].toJSON(e).object)}if(this.animations.length>0){r.animations=[];for(let t=0;t<this.animations.length;t++){const i=this.animations[t];r.animations.push(serialize(e.animations,i))}}if(t){const t=extractFromCache(e.geometries),r=extractFromCache(e.materials),n=extractFromCache(e.textures),s=extractFromCache(e.images),a=extractFromCache(e.shapes),o=extractFromCache(e.skeletons),l=extractFromCache(e.animations),c=extractFromCache(e.nodes);t.length>0&&(i.geometries=t),r.length>0&&(i.materials=r),n.length>0&&(i.textures=n),s.length>0&&(i.images=s),a.length>0&&(i.shapes=a),o.length>0&&(i.skeletons=o),l.length>0&&(i.animations=l),c.length>0&&(i.nodes=c)}return i.object=r,i;function extractFromCache(e){const t=[];for(const i in e){const r=e[i];delete r.metadata,t.push(r)}return t}}clone(e){return(new this.constructor).copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.userData=JSON.parse(JSON.stringify(e.userData)),!0===t)for(let i=0;i<e.children.length;i++){const t=e.children[i];this.add(t.clone())}return this}}Object3D.DefaultUp=new Vector3(0,1,0),Object3D.DefaultMatrixAutoUpdate=!0;const Sr=new Vector3,wr=new Vector3,Tr=new Vector3,Ar=new Vector3,Cr=new Vector3,Er=new Vector3,Lr=new Vector3,Pr=new Vector3,Rr=new Vector3,Dr=new Vector3;class Triangle{constructor(e=new Vector3,t=new Vector3,i=new Vector3){this.a=e,this.b=t,this.c=i}static getNormal(e,t,i,r){r.subVectors(i,t),Sr.subVectors(e,t),r.cross(Sr);const n=r.lengthSq();return n>0?r.multiplyScalar(1/Math.sqrt(n)):r.set(0,0,0)}static getBarycoord(e,t,i,r,n){Sr.subVectors(r,t),wr.subVectors(i,t),Tr.subVectors(e,t);const s=Sr.dot(Sr),a=Sr.dot(wr),o=Sr.dot(Tr),l=wr.dot(wr),c=wr.dot(Tr),h=s*l-a*a;if(0===h)return n.set(-2,-1,-1);const u=1/h,d=(l*o-a*c)*u,p=(s*c-a*o)*u;return n.set(1-d-p,p,d)}static containsPoint(e,t,i,r){return this.getBarycoord(e,t,i,r,Ar),Ar.x>=0&&Ar.y>=0&&Ar.x+Ar.y<=1}static getUV(e,t,i,r,n,s,a,o){return this.getBarycoord(e,t,i,r,Ar),o.set(0,0),o.addScaledVector(n,Ar.x),o.addScaledVector(s,Ar.y),o.addScaledVector(a,Ar.z),o}static isFrontFacing(e,t,i,r){return Sr.subVectors(i,t),wr.subVectors(e,t),Sr.cross(wr).dot(r)<0}set(e,t,i){return this.a.copy(e),this.b.copy(t),this.c.copy(i),this}setFromPointsAndIndices(e,t,i,r){return this.a.copy(e[t]),this.b.copy(e[i]),this.c.copy(e[r]),this}setFromAttributeAndIndices(e,t,i,r){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,i),this.c.fromBufferAttribute(e,r),this}clone(){return(new this.constructor).copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return Sr.subVectors(this.c,this.b),wr.subVectors(this.a,this.b),.5*Sr.cross(wr).length()}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return Triangle.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return Triangle.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,i,r,n){return Triangle.getUV(e,this.a,this.b,this.c,t,i,r,n)}containsPoint(e){return Triangle.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return Triangle.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const i=this.a,r=this.b,n=this.c;let s,a;Cr.subVectors(r,i),Er.subVectors(n,i),Pr.subVectors(e,i);const o=Cr.dot(Pr),l=Er.dot(Pr);if(o<=0&&l<=0)return t.copy(i);Rr.subVectors(e,r);const c=Cr.dot(Rr),h=Er.dot(Rr);if(c>=0&&h<=c)return t.copy(r);const u=o*h-c*l;if(u<=0&&o>=0&&c<=0)return s=o/(o-c),t.copy(i).addScaledVector(Cr,s);Dr.subVectors(e,n);const d=Cr.dot(Dr),p=Er.dot(Dr);if(p>=0&&d<=p)return t.copy(n);const m=d*l-o*p;if(m<=0&&l>=0&&p<=0)return a=l/(l-p),t.copy(i).addScaledVector(Er,a);const f=c*p-d*h;if(f<=0&&h-c>=0&&d-p>=0)return Lr.subVectors(n,r),a=(h-c)/(h-c+(d-p)),t.copy(r).addScaledVector(Lr,a);const g=1/(f+m+u);return s=m*g,a=u*g,t.copy(i).addScaledVector(Cr,s).addScaledVector(Er,a)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}let Ir=0;class Material extends EventDispatcher{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:Ir++}),this.uuid=generateUUID(),this.name="",this.type="Material",this.blending=_,this.side=p,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=B,this.blendDst=V,this.blendEquation=T,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=H,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=ii,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=kt,this.stencilZFail=kt,this.stencilZPass=kt,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!==e>0&&this.version++,this._alphaTest=e}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(void 0!==e)for(const t in e){const i=e[t];if(void 0===i){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}if("shading"===t){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=i===g;continue}const r=this[t];void 0!==r?r&&r.isColor?r.set(i):r&&r.isVector3&&i&&i.isVector3?r.copy(i):this[t]=i:console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.")}}toJSON(e){const t=void 0===e||"string"===typeof e;t&&(e={textures:{},images:{}});const i={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function extractFromCache(e){const t=[];for(const i in e){const r=e[i];delete r.metadata,t.push(r)}return t}if(i.uuid=this.uuid,i.type=this.type,""!==this.name&&(i.name=this.name),this.color&&this.color.isColor&&(i.color=this.color.getHex()),void 0!==this.roughness&&(i.roughness=this.roughness),void 0!==this.metalness&&(i.metalness=this.metalness),void 0!==this.sheen&&(i.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(i.sheenColor=this.sheenColor.getHex()),void 0!==this.sheenRoughness&&(i.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(i.emissive=this.emissive.getHex()),this.emissiveIntensity&&1!==this.emissiveIntensity&&(i.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(i.specular=this.specular.getHex()),void 0!==this.specularIntensity&&(i.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(i.specularColor=this.specularColor.getHex()),void 0!==this.shininess&&(i.shininess=this.shininess),void 0!==this.clearcoat&&(i.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(i.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(i.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(i.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(i.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,i.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),void 0!==this.iridescence&&(i.iridescence=this.iridescence),void 0!==this.iridescenceIOR&&(i.iridescenceIOR=this.iridescenceIOR),void 0!==this.iridescenceThicknessRange&&(i.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(i.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(i.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(i.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(i.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(i.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(i.lightMap=this.lightMap.toJSON(e).uuid,i.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(i.aoMap=this.aoMap.toJSON(e).uuid,i.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(i.bumpMap=this.bumpMap.toJSON(e).uuid,i.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(i.normalMap=this.normalMap.toJSON(e).uuid,i.normalMapType=this.normalMapType,i.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(i.displacementMap=this.displacementMap.toJSON(e).uuid,i.displacementScale=this.displacementScale,i.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(i.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(i.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(i.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(i.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(i.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(i.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(i.envMap=this.envMap.toJSON(e).uuid,void 0!==this.combine&&(i.combine=this.combine)),void 0!==this.envMapIntensity&&(i.envMapIntensity=this.envMapIntensity),void 0!==this.reflectivity&&(i.reflectivity=this.reflectivity),void 0!==this.refractionRatio&&(i.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(i.gradientMap=this.gradientMap.toJSON(e).uuid),void 0!==this.transmission&&(i.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(i.transmissionMap=this.transmissionMap.toJSON(e).uuid),void 0!==this.thickness&&(i.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(i.thicknessMap=this.thicknessMap.toJSON(e).uuid),void 0!==this.attenuationDistance&&(i.attenuationDistance=this.attenuationDistance),void 0!==this.attenuationColor&&(i.attenuationColor=this.attenuationColor.getHex()),void 0!==this.size&&(i.size=this.size),null!==this.shadowSide&&(i.shadowSide=this.shadowSide),void 0!==this.sizeAttenuation&&(i.sizeAttenuation=this.sizeAttenuation),this.blending!==_&&(i.blending=this.blending),this.side!==p&&(i.side=this.side),this.vertexColors&&(i.vertexColors=!0),this.opacity<1&&(i.opacity=this.opacity),!0===this.transparent&&(i.transparent=this.transparent),i.depthFunc=this.depthFunc,i.depthTest=this.depthTest,i.depthWrite=this.depthWrite,i.colorWrite=this.colorWrite,i.stencilWrite=this.stencilWrite,i.stencilWriteMask=this.stencilWriteMask,i.stencilFunc=this.stencilFunc,i.stencilRef=this.stencilRef,i.stencilFuncMask=this.stencilFuncMask,i.stencilFail=this.stencilFail,i.stencilZFail=this.stencilZFail,i.stencilZPass=this.stencilZPass,void 0!==this.rotation&&0!==this.rotation&&(i.rotation=this.rotation),!0===this.polygonOffset&&(i.polygonOffset=!0),0!==this.polygonOffsetFactor&&(i.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(i.polygonOffsetUnits=this.polygonOffsetUnits),void 0!==this.linewidth&&1!==this.linewidth&&(i.linewidth=this.linewidth),void 0!==this.dashSize&&(i.dashSize=this.dashSize),void 0!==this.gapSize&&(i.gapSize=this.gapSize),void 0!==this.scale&&(i.scale=this.scale),!0===this.dithering&&(i.dithering=!0),this.alphaTest>0&&(i.alphaTest=this.alphaTest),!0===this.alphaToCoverage&&(i.alphaToCoverage=this.alphaToCoverage),!0===this.premultipliedAlpha&&(i.premultipliedAlpha=this.premultipliedAlpha),!0===this.wireframe&&(i.wireframe=this.wireframe),this.wireframeLinewidth>1&&(i.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(i.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(i.wireframeLinejoin=this.wireframeLinejoin),!0===this.flatShading&&(i.flatShading=this.flatShading),!1===this.visible&&(i.visible=!1),!1===this.toneMapped&&(i.toneMapped=!1),!1===this.fog&&(i.fog=!1),"{}"!==JSON.stringify(this.userData)&&(i.userData=this.userData),t){const t=extractFromCache(e.textures),r=extractFromCache(e.images);t.length>0&&(i.textures=t),r.length>0&&(i.images=r)}return i}clone(){return(new this.constructor).copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let i=null;if(null!==t){const e=t.length;i=new Array(e);for(let r=0;r!==e;++r)i[r]=t[r].clone()}return this.clippingPlanes=i,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){!0===e&&this.version++}}class MeshBasicMaterial extends Material{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new Color(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Z,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}const Br=new Vector3,Vr=new Vector2;class BufferAttribute{constructor(e,t,i){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=e,this.itemSize=t,this.count=void 0!==e?e.length/t:0,this.normalized=!0===i,this.usage=ri,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(e){!0===e&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this}copyAt(e,t,i){e*=this.itemSize,i*=t.itemSize;for(let r=0,n=this.itemSize;r<n;r++)this.array[e+r]=t.array[i+r];return this}copyArray(e){return this.array.set(e),this}copyColorsArray(e){const t=this.array;let i=0;for(let r=0,n=e.length;r<n;r++){let n=e[r];void 0===n&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",r),n=new Color),t[i++]=n.r,t[i++]=n.g,t[i++]=n.b}return this}copyVector2sArray(e){const t=this.array;let i=0;for(let r=0,n=e.length;r<n;r++){let n=e[r];void 0===n&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",r),n=new Vector2),t[i++]=n.x,t[i++]=n.y}return this}copyVector3sArray(e){const t=this.array;let i=0;for(let r=0,n=e.length;r<n;r++){let n=e[r];void 0===n&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",r),n=new Vector3),t[i++]=n.x,t[i++]=n.y,t[i++]=n.z}return this}copyVector4sArray(e){const t=this.array;let i=0;for(let r=0,n=e.length;r<n;r++){let n=e[r];void 0===n&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",r),n=new Vector4),t[i++]=n.x,t[i++]=n.y,t[i++]=n.z,t[i++]=n.w}return this}applyMatrix3(e){if(2===this.itemSize)for(let t=0,i=this.count;t<i;t++)Vr.fromBufferAttribute(this,t),Vr.applyMatrix3(e),this.setXY(t,Vr.x,Vr.y);else if(3===this.itemSize)for(let t=0,i=this.count;t<i;t++)Br.fromBufferAttribute(this,t),Br.applyMatrix3(e),this.setXYZ(t,Br.x,Br.y,Br.z);return this}applyMatrix4(e){for(let t=0,i=this.count;t<i;t++)Br.fromBufferAttribute(this,t),Br.applyMatrix4(e),this.setXYZ(t,Br.x,Br.y,Br.z);return this}applyNormalMatrix(e){for(let t=0,i=this.count;t<i;t++)Br.fromBufferAttribute(this,t),Br.applyNormalMatrix(e),this.setXYZ(t,Br.x,Br.y,Br.z);return this}transformDirection(e){for(let t=0,i=this.count;t<i;t++)Br.fromBufferAttribute(this,t),Br.transformDirection(e),this.setXYZ(t,Br.x,Br.y,Br.z);return this}set(e,t=0){return this.array.set(e,t),this}getX(e){return this.array[e*this.itemSize]}setX(e,t){return this.array[e*this.itemSize]=t,this}getY(e){return this.array[e*this.itemSize+1]}setY(e,t){return this.array[e*this.itemSize+1]=t,this}getZ(e){return this.array[e*this.itemSize+2]}setZ(e,t){return this.array[e*this.itemSize+2]=t,this}getW(e){return this.array[e*this.itemSize+3]}setW(e,t){return this.array[e*this.itemSize+3]=t,this}setXY(e,t,i){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=i,this}setXYZ(e,t,i,r){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=i,this.array[e+2]=r,this}setXYZW(e,t,i,r,n){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=i,this.array[e+2]=r,this.array[e+3]=n,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return""!==this.name&&(e.name=this.name),this.usage!==ri&&(e.usage=this.usage),0===this.updateRange.offset&&-1===this.updateRange.count||(e.updateRange=this.updateRange),e}}class Int8BufferAttribute extends BufferAttribute{constructor(e,t,i){super(new Int8Array(e),t,i)}}class Uint8BufferAttribute extends BufferAttribute{constructor(e,t,i){super(new Uint8Array(e),t,i)}}class Uint8ClampedBufferAttribute extends BufferAttribute{constructor(e,t,i){super(new Uint8ClampedArray(e),t,i)}}class Int16BufferAttribute extends BufferAttribute{constructor(e,t,i){super(new Int16Array(e),t,i)}}class Uint16BufferAttribute extends BufferAttribute{constructor(e,t,i){super(new Uint16Array(e),t,i)}}class Int32BufferAttribute extends BufferAttribute{constructor(e,t,i){super(new Int32Array(e),t,i)}}class Uint32BufferAttribute extends BufferAttribute{constructor(e,t,i){super(new Uint32Array(e),t,i)}}class Float16BufferAttribute extends BufferAttribute{constructor(e,t,i){super(new Uint16Array(e),t,i),this.isFloat16BufferAttribute=!0}}class Float32BufferAttribute extends BufferAttribute{constructor(e,t,i){super(new Float32Array(e),t,i)}}class Float64BufferAttribute extends BufferAttribute{constructor(e,t,i){super(new Float64Array(e),t,i)}}let Nr=0;const Or=new Matrix4,zr=new Object3D,Fr=new Vector3,Gr=new Box3,Ur=new Box3,kr=new Vector3;class BufferGeometry extends EventDispatcher{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:Nr++}),this.uuid=generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(arrayNeedsUint32(e)?Uint32BufferAttribute:Uint16BufferAttribute)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return void 0!==this.attributes[e]}addGroup(e,t,i=0){this.groups.push({start:e,count:t,materialIndex:i})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;void 0!==t&&(t.applyMatrix4(e),t.needsUpdate=!0);const i=this.attributes.normal;if(void 0!==i){const t=(new Matrix3).getNormalMatrix(e);i.applyNormalMatrix(t),i.needsUpdate=!0}const r=this.attributes.tangent;return void 0!==r&&(r.transformDirection(e),r.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(e){return Or.makeRotationFromQuaternion(e),this.applyMatrix4(Or),this}rotateX(e){return Or.makeRotationX(e),this.applyMatrix4(Or),this}rotateY(e){return Or.makeRotationY(e),this.applyMatrix4(Or),this}rotateZ(e){return Or.makeRotationZ(e),this.applyMatrix4(Or),this}translate(e,t,i){return Or.makeTranslation(e,t,i),this.applyMatrix4(Or),this}scale(e,t,i){return Or.makeScale(e,t,i),this.applyMatrix4(Or),this}lookAt(e){return zr.lookAt(e),zr.updateMatrix(),this.applyMatrix4(zr.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Fr).negate(),this.translate(Fr.x,Fr.y,Fr.z),this}setFromPoints(e){const t=[];for(let i=0,r=e.length;i<r;i++){const r=e[i];t.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new Float32BufferAttribute(t,3)),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new Box3);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new Vector3(-1/0,-1/0,-1/0),new Vector3(1/0,1/0,1/0));if(void 0!==e){if(this.boundingBox.setFromBufferAttribute(e),t)for(let i=0,r=t.length;i<r;i++){const e=t[i];Gr.setFromBufferAttribute(e),this.morphTargetsRelative?(kr.addVectors(this.boundingBox.min,Gr.min),this.boundingBox.expandByPoint(kr),kr.addVectors(this.boundingBox.max,Gr.max),this.boundingBox.expandByPoint(kr)):(this.boundingBox.expandByPoint(Gr.min),this.boundingBox.expandByPoint(Gr.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new Sphere);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new Vector3,1/0);if(e){const i=this.boundingSphere.center;if(Gr.setFromBufferAttribute(e),t)for(let e=0,n=t.length;e<n;e++){const i=t[e];Ur.setFromBufferAttribute(i),this.morphTargetsRelative?(kr.addVectors(Gr.min,Ur.min),Gr.expandByPoint(kr),kr.addVectors(Gr.max,Ur.max),Gr.expandByPoint(kr)):(Gr.expandByPoint(Ur.min),Gr.expandByPoint(Ur.max))}Gr.getCenter(i);let r=0;for(let t=0,n=e.count;t<n;t++)kr.fromBufferAttribute(e,t),r=Math.max(r,i.distanceToSquared(kr));if(t)for(let n=0,s=t.length;n<s;n++){const s=t[n],a=this.morphTargetsRelative;for(let t=0,n=s.count;t<n;t++)kr.fromBufferAttribute(s,t),a&&(Fr.fromBufferAttribute(e,t),kr.add(Fr)),r=Math.max(r,i.distanceToSquared(kr))}this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(null===e||void 0===t.position||void 0===t.normal||void 0===t.uv)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const i=e.array,r=t.position.array,n=t.normal.array,s=t.uv.array,a=r.length/3;!1===this.hasAttribute("tangent")&&this.setAttribute("tangent",new BufferAttribute(new Float32Array(4*a),4));const o=this.getAttribute("tangent").array,l=[],c=[];for(let w=0;w<a;w++)l[w]=new Vector3,c[w]=new Vector3;const h=new Vector3,u=new Vector3,d=new Vector3,p=new Vector2,m=new Vector2,f=new Vector2,g=new Vector3,x=new Vector3;function handleTriangle(e,t,i){h.fromArray(r,3*e),u.fromArray(r,3*t),d.fromArray(r,3*i),p.fromArray(s,2*e),m.fromArray(s,2*t),f.fromArray(s,2*i),u.sub(h),d.sub(h),m.sub(p),f.sub(p);const n=1/(m.x*f.y-f.x*m.y);isFinite(n)&&(g.copy(u).multiplyScalar(f.y).addScaledVector(d,-m.y).multiplyScalar(n),x.copy(d).multiplyScalar(m.x).addScaledVector(u,-f.x).multiplyScalar(n),l[e].add(g),l[t].add(g),l[i].add(g),c[e].add(x),c[t].add(x),c[i].add(x))}let y=this.groups;0===y.length&&(y=[{start:0,count:i.length}]);for(let w=0,T=y.length;w<T;++w){const e=y[w],t=e.start;for(let r=t,n=t+e.count;r<n;r+=3)handleTriangle(i[r+0],i[r+1],i[r+2])}const _=new Vector3,b=new Vector3,M=new Vector3,S=new Vector3;function handleVertex(e){M.fromArray(n,3*e),S.copy(M);const t=l[e];_.copy(t),_.sub(M.multiplyScalar(M.dot(t))).normalize(),b.crossVectors(S,t);const i=b.dot(c[e])<0?-1:1;o[4*e]=_.x,o[4*e+1]=_.y,o[4*e+2]=_.z,o[4*e+3]=i}for(let w=0,T=y.length;w<T;++w){const e=y[w],t=e.start;for(let r=t,n=t+e.count;r<n;r+=3)handleVertex(i[r+0]),handleVertex(i[r+1]),handleVertex(i[r+2])}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(void 0!==t){let i=this.getAttribute("normal");if(void 0===i)i=new BufferAttribute(new Float32Array(3*t.count),3),this.setAttribute("normal",i);else for(let e=0,t=i.count;e<t;e++)i.setXYZ(e,0,0,0);const r=new Vector3,n=new Vector3,s=new Vector3,a=new Vector3,o=new Vector3,l=new Vector3,c=new Vector3,h=new Vector3;if(e)for(let u=0,d=e.count;u<d;u+=3){const d=e.getX(u+0),p=e.getX(u+1),m=e.getX(u+2);r.fromBufferAttribute(t,d),n.fromBufferAttribute(t,p),s.fromBufferAttribute(t,m),c.subVectors(s,n),h.subVectors(r,n),c.cross(h),a.fromBufferAttribute(i,d),o.fromBufferAttribute(i,p),l.fromBufferAttribute(i,m),a.add(c),o.add(c),l.add(c),i.setXYZ(d,a.x,a.y,a.z),i.setXYZ(p,o.x,o.y,o.z),i.setXYZ(m,l.x,l.y,l.z)}else for(let e=0,u=t.count;e<u;e+=3)r.fromBufferAttribute(t,e+0),n.fromBufferAttribute(t,e+1),s.fromBufferAttribute(t,e+2),c.subVectors(s,n),h.subVectors(r,n),c.cross(h),i.setXYZ(e+0,c.x,c.y,c.z),i.setXYZ(e+1,c.x,c.y,c.z),i.setXYZ(e+2,c.x,c.y,c.z);this.normalizeNormals(),i.needsUpdate=!0}}merge(e,t){if(!e||!e.isBufferGeometry)return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",e);void 0===t&&(t=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const i=this.attributes;for(const r in i){if(void 0===e.attributes[r])continue;const n=i[r].array,s=e.attributes[r],a=s.array,o=s.itemSize*t,l=Math.min(a.length,n.length-o);for(let e=0,t=o;e<l;e++,t++)n[t]=a[e]}return this}normalizeNormals(){const e=this.attributes.normal;for(let t=0,i=e.count;t<i;t++)kr.fromBufferAttribute(e,t),kr.normalize(),e.setXYZ(t,kr.x,kr.y,kr.z)}toNonIndexed(){function convertBufferAttribute(e,t){const i=e.array,r=e.itemSize,n=e.normalized,s=new i.constructor(t.length*r);let a=0,o=0;for(let l=0,c=t.length;l<c;l++){a=e.isInterleavedBufferAttribute?t[l]*e.data.stride+e.offset:t[l]*r;for(let e=0;e<r;e++)s[o++]=i[a++]}return new BufferAttribute(s,r,n)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new BufferGeometry,t=this.index.array,i=this.attributes;for(const s in i){const r=convertBufferAttribute(i[s],t);e.setAttribute(s,r)}const r=this.morphAttributes;for(const s in r){const i=[],n=r[s];for(let e=0,r=n.length;e<r;e++){const r=convertBufferAttribute(n[e],t);i.push(r)}e.morphAttributes[s]=i}e.morphTargetsRelative=this.morphTargetsRelative;const n=this.groups;for(let s=0,a=n.length;s<a;s++){const t=n[s];e.addGroup(t.start,t.count,t.materialIndex)}return e}toJSON(){const e={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,""!==this.name&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),void 0!==this.parameters){const t=this.parameters;for(const i in t)void 0!==t[i]&&(e[i]=t[i]);return e}e.data={attributes:{}};const t=this.index;null!==t&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const i=this.attributes;for(const o in i){const t=i[o];e.data.attributes[o]=t.toJSON(e.data)}const r={};let n=!1;for(const o in this.morphAttributes){const t=this.morphAttributes[o],i=[];for(let r=0,n=t.length;r<n;r++){const n=t[r];i.push(n.toJSON(e.data))}i.length>0&&(r[o]=i,n=!0)}n&&(e.data.morphAttributes=r,e.data.morphTargetsRelative=this.morphTargetsRelative);const s=this.groups;s.length>0&&(e.data.groups=JSON.parse(JSON.stringify(s)));const a=this.boundingSphere;return null!==a&&(e.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),e}clone(){return(new this.constructor).copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const i=e.index;null!==i&&this.setIndex(i.clone(t));const r=e.attributes;for(const l in r){const e=r[l];this.setAttribute(l,e.clone(t))}const n=e.morphAttributes;for(const l in n){const e=[],i=n[l];for(let r=0,n=i.length;r<n;r++)e.push(i[r].clone(t));this.morphAttributes[l]=e}this.morphTargetsRelative=e.morphTargetsRelative;const s=e.groups;for(let l=0,c=s.length;l<c;l++){const e=s[l];this.addGroup(e.start,e.count,e.materialIndex)}const a=e.boundingBox;null!==a&&(this.boundingBox=a.clone());const o=e.boundingSphere;return null!==o&&(this.boundingSphere=o.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,void 0!==e.parameters&&(this.parameters=Object.assign({},e.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}const Wr=new Matrix4,Hr=new Ray,jr=new Sphere,qr=new Vector3,Xr=new Vector3,Yr=new Vector3,Zr=new Vector3,Jr=new Vector3,Kr=new Vector3,Qr=new Vector3,$r=new Vector3,en=new Vector3,tn=new Vector2,rn=new Vector2,nn=new Vector2,sn=new Vector3,an=new Vector3;class Mesh extends Object3D{constructor(e=new BufferGeometry,t=new MeshBasicMaterial){super(),this.isMesh=!0,this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),void 0!==e.morphTargetInfluences&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),void 0!==e.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=e.material,this.geometry=e.geometry,this}updateMorphTargets(){const e=this.geometry.morphAttributes,t=Object.keys(e);if(t.length>0){const i=e[t[0]];if(void 0!==i){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,t=i.length;e<t;e++){const t=i[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[t]=e}}}}raycast(e,t){const i=this.geometry,r=this.material,n=this.matrixWorld;if(void 0===r)return;if(null===i.boundingSphere&&i.computeBoundingSphere(),jr.copy(i.boundingSphere),jr.applyMatrix4(n),!1===e.ray.intersectsSphere(jr))return;if(Wr.copy(n).invert(),Hr.copy(e.ray).applyMatrix4(Wr),null!==i.boundingBox&&!1===Hr.intersectsBox(i.boundingBox))return;let s;const a=i.index,o=i.attributes.position,l=i.morphAttributes.position,c=i.morphTargetsRelative,h=i.attributes.uv,u=i.attributes.uv2,d=i.groups,p=i.drawRange;if(null!==a)if(Array.isArray(r))for(let m=0,f=d.length;m<f;m++){const i=d[m],n=r[i.materialIndex];for(let r=Math.max(i.start,p.start),d=Math.min(a.count,Math.min(i.start+i.count,p.start+p.count));r<d;r+=3){const d=a.getX(r),p=a.getX(r+1),m=a.getX(r+2);s=checkBufferGeometryIntersection(this,n,e,Hr,o,l,c,h,u,d,p,m),s&&(s.faceIndex=Math.floor(r/3),s.face.materialIndex=i.materialIndex,t.push(s))}}else{for(let i=Math.max(0,p.start),n=Math.min(a.count,p.start+p.count);i<n;i+=3){const n=a.getX(i),d=a.getX(i+1),p=a.getX(i+2);s=checkBufferGeometryIntersection(this,r,e,Hr,o,l,c,h,u,n,d,p),s&&(s.faceIndex=Math.floor(i/3),t.push(s))}}else if(void 0!==o)if(Array.isArray(r))for(let m=0,f=d.length;m<f;m++){const i=d[m],n=r[i.materialIndex];for(let r=Math.max(i.start,p.start),a=Math.min(o.count,Math.min(i.start+i.count,p.start+p.count));r<a;r+=3){s=checkBufferGeometryIntersection(this,n,e,Hr,o,l,c,h,u,r,r+1,r+2),s&&(s.faceIndex=Math.floor(r/3),s.face.materialIndex=i.materialIndex,t.push(s))}}else{for(let i=Math.max(0,p.start),n=Math.min(o.count,p.start+p.count);i<n;i+=3){s=checkBufferGeometryIntersection(this,r,e,Hr,o,l,c,h,u,i,i+1,i+2),s&&(s.faceIndex=Math.floor(i/3),t.push(s))}}}}function checkBufferGeometryIntersection(e,t,i,r,n,s,a,o,l,c,h,u){qr.fromBufferAttribute(n,c),Xr.fromBufferAttribute(n,h),Yr.fromBufferAttribute(n,u);const d=e.morphTargetInfluences;if(s&&d){Qr.set(0,0,0),$r.set(0,0,0),en.set(0,0,0);for(let e=0,t=s.length;e<t;e++){const t=d[e],i=s[e];0!==t&&(Zr.fromBufferAttribute(i,c),Jr.fromBufferAttribute(i,h),Kr.fromBufferAttribute(i,u),a?(Qr.addScaledVector(Zr,t),$r.addScaledVector(Jr,t),en.addScaledVector(Kr,t)):(Qr.addScaledVector(Zr.sub(qr),t),$r.addScaledVector(Jr.sub(Xr),t),en.addScaledVector(Kr.sub(Yr),t)))}qr.add(Qr),Xr.add($r),Yr.add(en)}e.isSkinnedMesh&&(e.boneTransform(c,qr),e.boneTransform(h,Xr),e.boneTransform(u,Yr));const p=function checkIntersection(e,t,i,r,n,s,a,o){let l;if(l=t.side===m?r.intersectTriangle(a,s,n,!0,o):r.intersectTriangle(n,s,a,t.side!==f,o),null===l)return null;an.copy(o),an.applyMatrix4(e.matrixWorld);const c=i.ray.origin.distanceTo(an);return c<i.near||c>i.far?null:{distance:c,point:an.clone(),object:e}}(e,t,i,r,qr,Xr,Yr,sn);if(p){o&&(tn.fromBufferAttribute(o,c),rn.fromBufferAttribute(o,h),nn.fromBufferAttribute(o,u),p.uv=Triangle.getUV(sn,qr,Xr,Yr,tn,rn,nn,new Vector2)),l&&(tn.fromBufferAttribute(l,c),rn.fromBufferAttribute(l,h),nn.fromBufferAttribute(l,u),p.uv2=Triangle.getUV(sn,qr,Xr,Yr,tn,rn,nn,new Vector2));const e={a:c,b:h,c:u,normal:new Vector3,materialIndex:0};Triangle.getNormal(qr,Xr,Yr,e.normal),p.face=e}return p}class BoxGeometry extends BufferGeometry{constructor(e=1,t=1,i=1,r=1,n=1,s=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:i,widthSegments:r,heightSegments:n,depthSegments:s};const a=this;r=Math.floor(r),n=Math.floor(n),s=Math.floor(s);const o=[],l=[],c=[],h=[];let u=0,d=0;function buildPlane(e,t,i,r,n,s,p,m,f,g,x){const y=s/f,_=p/g,b=s/2,M=p/2,S=m/2,w=f+1,T=g+1;let A=0,C=0;const E=new Vector3;for(let a=0;a<T;a++){const s=a*_-M;for(let o=0;o<w;o++){const u=o*y-b;E[e]=u*r,E[t]=s*n,E[i]=S,l.push(E.x,E.y,E.z),E[e]=0,E[t]=0,E[i]=m>0?1:-1,c.push(E.x,E.y,E.z),h.push(o/f),h.push(1-a/g),A+=1}}for(let a=0;a<g;a++)for(let e=0;e<f;e++){const t=u+e+w*a,i=u+e+w*(a+1),r=u+(e+1)+w*(a+1),n=u+(e+1)+w*a;o.push(t,i,n),o.push(i,r,n),C+=6}a.addGroup(d,C,x),d+=C,u+=A}buildPlane("z","y","x",-1,-1,i,t,e,s,n,0),buildPlane("z","y","x",1,-1,i,t,-e,s,n,1),buildPlane("x","z","y",1,1,e,i,t,r,s,2),buildPlane("x","z","y",1,-1,e,i,-t,r,s,3),buildPlane("x","y","z",1,-1,e,t,i,r,n,4),buildPlane("x","y","z",-1,-1,e,t,-i,r,n,5),this.setIndex(o),this.setAttribute("position",new Float32BufferAttribute(l,3)),this.setAttribute("normal",new Float32BufferAttribute(c,3)),this.setAttribute("uv",new Float32BufferAttribute(h,2))}static fromJSON(e){return new BoxGeometry(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function cloneUniforms(e){const t={};for(const i in e){t[i]={};for(const r in e[i]){const n=e[i][r];n&&(n.isColor||n.isMatrix3||n.isMatrix4||n.isVector2||n.isVector3||n.isVector4||n.isTexture||n.isQuaternion)?t[i][r]=n.clone():Array.isArray(n)?t[i][r]=n.slice():t[i][r]=n}}return t}function mergeUniforms(e){const t={};for(let i=0;i<e.length;i++){const r=cloneUniforms(e[i]);for(const e in r)t[e]=r[e]}return t}const on={clone:cloneUniforms,merge:mergeUniforms};class ShaderMaterial extends Material{constructor(e){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",this.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==e&&(void 0!==e.attributes&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(e))}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=cloneUniforms(e.uniforms),this.uniformsGroups=function cloneUniformsGroups(e){const t=[];for(let i=0;i<e.length;i++)t.push(e[i].clone());return t}(e.uniformsGroups),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const r in this.uniforms){const i=this.uniforms[r].value;i&&i.isTexture?t.uniforms[r]={type:"t",value:i.toJSON(e).uuid}:i&&i.isColor?t.uniforms[r]={type:"c",value:i.getHex()}:i&&i.isVector2?t.uniforms[r]={type:"v2",value:i.toArray()}:i&&i.isVector3?t.uniforms[r]={type:"v3",value:i.toArray()}:i&&i.isVector4?t.uniforms[r]={type:"v4",value:i.toArray()}:i&&i.isMatrix3?t.uniforms[r]={type:"m3",value:i.toArray()}:i&&i.isMatrix4?t.uniforms[r]={type:"m4",value:i.toArray()}:t.uniforms[r]={value:i}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;const i={};for(const r in this.extensions)!0===this.extensions[r]&&(i[r]=!0);return Object.keys(i).length>0&&(t.extensions=i),t}}class Camera extends Object3D{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new Matrix4,this.projectionMatrix=new Matrix4,this.projectionMatrixInverse=new Matrix4}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(-t[8],-t[9],-t[10]).normalize()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return(new this.constructor).copy(this)}}class PerspectiveCamera extends Camera{constructor(e=50,t=1,i=.1,r=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=i,this.far=r,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=null===e.view?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=2*xi*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(.5*vi*this.fov);return.5*this.getFilmHeight()/e}getEffectiveFOV(){return 2*xi*Math.atan(Math.tan(.5*vi*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(e,t,i,r,n,s){this.aspect=e/t,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=i,this.view.offsetY=r,this.view.width=n,this.view.height=s,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(.5*vi*this.fov)/this.zoom,i=2*t,r=this.aspect*i,n=-.5*r;const s=this.view;if(null!==this.view&&this.view.enabled){const e=s.fullWidth,a=s.fullHeight;n+=s.offsetX*r/e,t-=s.offsetY*i/a,r*=s.width/e,i*=s.height/a}const a=this.filmOffset;0!==a&&(n+=e*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(n,n+r,t,t-i,e,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,null!==this.view&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}const ln=90;class CubeCamera extends Object3D{constructor(e,t,i){if(super(),this.type="CubeCamera",!0!==i.isWebGLCubeRenderTarget)return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");this.renderTarget=i;const r=new PerspectiveCamera(ln,1,e,t);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new Vector3(1,0,0)),this.add(r);const n=new PerspectiveCamera(ln,1,e,t);n.layers=this.layers,n.up.set(0,-1,0),n.lookAt(new Vector3(-1,0,0)),this.add(n);const s=new PerspectiveCamera(ln,1,e,t);s.layers=this.layers,s.up.set(0,0,1),s.lookAt(new Vector3(0,1,0)),this.add(s);const a=new PerspectiveCamera(ln,1,e,t);a.layers=this.layers,a.up.set(0,0,-1),a.lookAt(new Vector3(0,-1,0)),this.add(a);const o=new PerspectiveCamera(ln,1,e,t);o.layers=this.layers,o.up.set(0,-1,0),o.lookAt(new Vector3(0,0,1)),this.add(o);const l=new PerspectiveCamera(ln,1,e,t);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new Vector3(0,0,-1)),this.add(l)}update(e,t){null===this.parent&&this.updateMatrixWorld();const i=this.renderTarget,[r,n,s,a,o,l]=this.children,c=e.getRenderTarget(),h=e.toneMapping,u=e.xr.enabled;e.toneMapping=Q,e.xr.enabled=!1;const d=i.texture.generateMipmaps;i.texture.generateMipmaps=!1,e.setRenderTarget(i,0),e.render(t,r),e.setRenderTarget(i,1),e.render(t,n),e.setRenderTarget(i,2),e.render(t,s),e.setRenderTarget(i,3),e.render(t,a),e.setRenderTarget(i,4),e.render(t,o),i.texture.generateMipmaps=d,e.setRenderTarget(i,5),e.render(t,l),e.setRenderTarget(c),e.toneMapping=h,e.xr.enabled=u,i.texture.needsPMREMUpdate=!0}}class CubeTexture extends Texture{constructor(e,t,i,r,n,s,a,o,l,c){super(e=void 0!==e?e:[],t=void 0!==t?t:se,i,r,n,s,a,o,l,c),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}class WebGLCubeRenderTarget extends WebGLRenderTarget{constructor(e,t={}){super(e,e,t),this.isWebGLCubeRenderTarget=!0;const i={width:e,height:e,depth:1},r=[i,i,i,i,i,i];this.texture=new CubeTexture(r,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=void 0!==t.generateMipmaps&&t.generateMipmaps,this.texture.minFilter=void 0!==t.minFilter?t.minFilter:xe}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const i={uniforms:{tEquirect:{value:null}},vertexShader:"\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",fragmentShader:"\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"},r=new BoxGeometry(5,5,5),n=new ShaderMaterial({name:"CubemapFromEquirect",uniforms:cloneUniforms(i.uniforms),vertexShader:i.vertexShader,fragmentShader:i.fragmentShader,side:m,blending:y});n.uniforms.tEquirect.value=t;const s=new Mesh(r,n),a=t.minFilter;t.minFilter===be&&(t.minFilter=xe);return new CubeCamera(1,10,this).update(e,s),t.minFilter=a,s.geometry.dispose(),s.material.dispose(),this}clear(e,t,i,r){const n=e.getRenderTarget();for(let s=0;s<6;s++)e.setRenderTarget(this,s),e.clear(t,i,r);e.setRenderTarget(n)}}const cn=new Vector3,hn=new Vector3,un=new Matrix3;class Plane{constructor(e=new Vector3(1,0,0),t=0){this.isPlane=!0,this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,i,r){return this.normal.set(e,t,i),this.constant=r,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,i){const r=cn.subVectors(i,t).cross(hn.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(r,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)}intersectLine(e,t){const i=e.delta(cn),r=this.normal.dot(i);if(0===r)return 0===this.distanceToPoint(e.start)?t.copy(e.start):null;const n=-(e.start.dot(this.normal)+this.constant)/r;return n<0||n>1?null:t.copy(i).multiplyScalar(n).add(e.start)}intersectsLine(e){const t=this.distanceToPoint(e.start),i=this.distanceToPoint(e.end);return t<0&&i>0||i<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const i=t||un.getNormalMatrix(e),r=this.coplanarPoint(cn).applyMatrix4(e),n=this.normal.applyMatrix3(i).normalize();return this.constant=-r.dot(n),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return(new this.constructor).copy(this)}}const dn=new Sphere,pn=new Vector3;class Frustum{constructor(e=new Plane,t=new Plane,i=new Plane,r=new Plane,n=new Plane,s=new Plane){this.planes=[e,t,i,r,n,s]}set(e,t,i,r,n,s){const a=this.planes;return a[0].copy(e),a[1].copy(t),a[2].copy(i),a[3].copy(r),a[4].copy(n),a[5].copy(s),this}copy(e){const t=this.planes;for(let i=0;i<6;i++)t[i].copy(e.planes[i]);return this}setFromProjectionMatrix(e){const t=this.planes,i=e.elements,r=i[0],n=i[1],s=i[2],a=i[3],o=i[4],l=i[5],c=i[6],h=i[7],u=i[8],d=i[9],p=i[10],m=i[11],f=i[12],g=i[13],x=i[14],y=i[15];return t[0].setComponents(a-r,h-o,m-u,y-f).normalize(),t[1].setComponents(a+r,h+o,m+u,y+f).normalize(),t[2].setComponents(a+n,h+l,m+d,y+g).normalize(),t[3].setComponents(a-n,h-l,m-d,y-g).normalize(),t[4].setComponents(a-s,h-c,m-p,y-x).normalize(),t[5].setComponents(a+s,h+c,m+p,y+x).normalize(),this}intersectsObject(e){const t=e.geometry;return null===t.boundingSphere&&t.computeBoundingSphere(),dn.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere(dn)}intersectsSprite(e){return dn.center.set(0,0,0),dn.radius=.7071067811865476,dn.applyMatrix4(e.matrixWorld),this.intersectsSphere(dn)}intersectsSphere(e){const t=this.planes,i=e.center,r=-e.radius;for(let n=0;n<6;n++){if(t[n].distanceToPoint(i)<r)return!1}return!0}intersectsBox(e){const t=this.planes;for(let i=0;i<6;i++){const r=t[i];if(pn.x=r.normal.x>0?e.max.x:e.min.x,pn.y=r.normal.y>0?e.max.y:e.min.y,pn.z=r.normal.z>0?e.max.z:e.min.z,r.distanceToPoint(pn)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let i=0;i<6;i++)if(t[i].distanceToPoint(e)<0)return!1;return!0}clone(){return(new this.constructor).copy(this)}}function WebGLAnimation(){let e=null,t=!1,i=null,r=null;function onAnimationFrame(t,n){i(t,n),r=e.requestAnimationFrame(onAnimationFrame)}return{start:function(){!0!==t&&null!==i&&(r=e.requestAnimationFrame(onAnimationFrame),t=!0)},stop:function(){e.cancelAnimationFrame(r),t=!1},setAnimationLoop:function(e){i=e},setContext:function(t){e=t}}}function WebGLAttributes(e,t){const i=t.isWebGL2,r=new WeakMap;return{get:function get(e){return e.isInterleavedBufferAttribute&&(e=e.data),r.get(e)},remove:function remove(t){t.isInterleavedBufferAttribute&&(t=t.data);const i=r.get(t);i&&(e.deleteBuffer(i.buffer),r.delete(t))},update:function update(t,n){if(t.isGLBufferAttribute){const e=r.get(t);return void((!e||e.version<t.version)&&r.set(t,{buffer:t.buffer,type:t.type,bytesPerElement:t.elementSize,version:t.version}))}t.isInterleavedBufferAttribute&&(t=t.data);const s=r.get(t);void 0===s?r.set(t,function createBuffer(t,r){const n=t.array,s=t.usage,a=e.createBuffer();let o;if(e.bindBuffer(r,a),e.bufferData(r,n,s),t.onUploadCallback(),n instanceof Float32Array)o=5126;else if(n instanceof Uint16Array)if(t.isFloat16BufferAttribute){if(!i)throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");o=5131}else o=5123;else if(n instanceof Int16Array)o=5122;else if(n instanceof Uint32Array)o=5125;else if(n instanceof Int32Array)o=5124;else if(n instanceof Int8Array)o=5120;else if(n instanceof Uint8Array)o=5121;else{if(!(n instanceof Uint8ClampedArray))throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+n);o=5121}return{buffer:a,type:o,bytesPerElement:n.BYTES_PER_ELEMENT,version:t.version}}(t,n)):s.version<t.version&&(!function updateBuffer(t,r,n){const s=r.array,a=r.updateRange;e.bindBuffer(n,t),-1===a.count?e.bufferSubData(n,0,s):(i?e.bufferSubData(n,a.offset*s.BYTES_PER_ELEMENT,s,a.offset,a.count):e.bufferSubData(n,a.offset*s.BYTES_PER_ELEMENT,s.subarray(a.offset,a.offset+a.count)),a.count=-1)}(s.buffer,t,n),s.version=t.version)}}}class PlaneGeometry extends BufferGeometry{constructor(e=1,t=1,i=1,r=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:i,heightSegments:r};const n=e/2,s=t/2,a=Math.floor(i),o=Math.floor(r),l=a+1,c=o+1,h=e/a,u=t/o,d=[],p=[],m=[],f=[];for(let g=0;g<c;g++){const e=g*u-s;for(let t=0;t<l;t++){const i=t*h-n;p.push(i,-e,0),m.push(0,0,1),f.push(t/a),f.push(1-g/o)}}for(let g=0;g<o;g++)for(let e=0;e<a;e++){const t=e+l*g,i=e+l*(g+1),r=e+1+l*(g+1),n=e+1+l*g;d.push(t,i,n),d.push(i,r,n)}this.setIndex(d),this.setAttribute("position",new Float32BufferAttribute(p,3)),this.setAttribute("normal",new Float32BufferAttribute(m,3)),this.setAttribute("uv",new Float32BufferAttribute(f,2))}static fromJSON(e){return new PlaneGeometry(e.width,e.height,e.widthSegments,e.heightSegments)}}const mn={alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",alphatest_pars_fragment:"#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",iridescence_fragment:"#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\t return vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:"vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",lightmap_fragment:"#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_vertex:"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",map_fragment:"#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphcolor_vertex:"#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",normal_fragment_begin:"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",normal_fragment_maps:"#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",normal_pars_fragment:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_pars_vertex:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_vertex:"#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",clearcoat_normal_fragment_begin:"#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",iridescence_pars_fragment:"#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",output_fragment:"#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",shadowmap_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmission_fragment:"#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",transmission_pars_fragment:"#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",uv_pars_fragment:"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",uv_pars_vertex:"#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",uv_vertex:"#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",background_frag:"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",cube_frag:"#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshlambert_frag:"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshnormal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",meshnormal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",shadow_vert:"#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"},fn={common:{diffuse:{value:new Color(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new Matrix3},uv2Transform:{value:new Matrix3},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new Vector2(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Color(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Color(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Matrix3}},sprite:{diffuse:{value:new Color(16777215)},opacity:{value:1},center:{value:new Vector2(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Matrix3}}},gn={basic:{uniforms:mergeUniforms([fn.common,fn.specularmap,fn.envmap,fn.aomap,fn.lightmap,fn.fog]),vertexShader:mn.meshbasic_vert,fragmentShader:mn.meshbasic_frag},lambert:{uniforms:mergeUniforms([fn.common,fn.specularmap,fn.envmap,fn.aomap,fn.lightmap,fn.emissivemap,fn.fog,fn.lights,{emissive:{value:new Color(0)}}]),vertexShader:mn.meshlambert_vert,fragmentShader:mn.meshlambert_frag},phong:{uniforms:mergeUniforms([fn.common,fn.specularmap,fn.envmap,fn.aomap,fn.lightmap,fn.emissivemap,fn.bumpmap,fn.normalmap,fn.displacementmap,fn.fog,fn.lights,{emissive:{value:new Color(0)},specular:{value:new Color(1118481)},shininess:{value:30}}]),vertexShader:mn.meshphong_vert,fragmentShader:mn.meshphong_frag},standard:{uniforms:mergeUniforms([fn.common,fn.envmap,fn.aomap,fn.lightmap,fn.emissivemap,fn.bumpmap,fn.normalmap,fn.displacementmap,fn.roughnessmap,fn.metalnessmap,fn.fog,fn.lights,{emissive:{value:new Color(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:mn.meshphysical_vert,fragmentShader:mn.meshphysical_frag},toon:{uniforms:mergeUniforms([fn.common,fn.aomap,fn.lightmap,fn.emissivemap,fn.bumpmap,fn.normalmap,fn.displacementmap,fn.gradientmap,fn.fog,fn.lights,{emissive:{value:new Color(0)}}]),vertexShader:mn.meshtoon_vert,fragmentShader:mn.meshtoon_frag},matcap:{uniforms:mergeUniforms([fn.common,fn.bumpmap,fn.normalmap,fn.displacementmap,fn.fog,{matcap:{value:null}}]),vertexShader:mn.meshmatcap_vert,fragmentShader:mn.meshmatcap_frag},points:{uniforms:mergeUniforms([fn.points,fn.fog]),vertexShader:mn.points_vert,fragmentShader:mn.points_frag},dashed:{uniforms:mergeUniforms([fn.common,fn.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:mn.linedashed_vert,fragmentShader:mn.linedashed_frag},depth:{uniforms:mergeUniforms([fn.common,fn.displacementmap]),vertexShader:mn.depth_vert,fragmentShader:mn.depth_frag},normal:{uniforms:mergeUniforms([fn.common,fn.bumpmap,fn.normalmap,fn.displacementmap,{opacity:{value:1}}]),vertexShader:mn.meshnormal_vert,fragmentShader:mn.meshnormal_frag},sprite:{uniforms:mergeUniforms([fn.sprite,fn.fog]),vertexShader:mn.sprite_vert,fragmentShader:mn.sprite_frag},background:{uniforms:{uvTransform:{value:new Matrix3},t2D:{value:null}},vertexShader:mn.background_vert,fragmentShader:mn.background_frag},cube:{uniforms:mergeUniforms([fn.envmap,{opacity:{value:1}}]),vertexShader:mn.cube_vert,fragmentShader:mn.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:mn.equirect_vert,fragmentShader:mn.equirect_frag},distanceRGBA:{uniforms:mergeUniforms([fn.common,fn.displacementmap,{referencePosition:{value:new Vector3},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:mn.distanceRGBA_vert,fragmentShader:mn.distanceRGBA_frag},shadow:{uniforms:mergeUniforms([fn.lights,fn.fog,{color:{value:new Color(0)},opacity:{value:1}}]),vertexShader:mn.shadow_vert,fragmentShader:mn.shadow_frag}};function WebGLBackground(e,t,i,r,n,s){const a=new Color(0);let o,l,c=!0===n?0:1,h=null,u=0,d=null;function setClear(e,t){i.buffers.color.setClear(e.r,e.g,e.b,t,s)}return{getClearColor:function(){return a},setClearColor:function(e,t=1){a.set(e),c=t,setClear(a,c)},getClearAlpha:function(){return c},setClearAlpha:function(e){c=e,setClear(a,c)},render:function render(i,n){let s=!1,f=!0===n.isScene?n.background:null;f&&f.isTexture&&(f=t.get(f));const g=e.xr,x=g.getSession&&g.getSession();x&&"additive"===x.environmentBlendMode&&(f=null),null===f?setClear(a,c):f&&f.isColor&&(setClear(f,1),s=!0),(e.autoClear||s)&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),f&&(f.isCubeTexture||f.mapping===ce)?(void 0===l&&(l=new Mesh(new BoxGeometry(1,1,1),new ShaderMaterial({name:"BackgroundCubeMaterial",uniforms:cloneUniforms(gn.cube.uniforms),vertexShader:gn.cube.vertexShader,fragmentShader:gn.cube.fragmentShader,side:m,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),l.geometry.deleteAttribute("uv"),l.onBeforeRender=function(e,t,i){this.matrixWorld.copyPosition(i.matrixWorld)},Object.defineProperty(l.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),r.update(l)),l.material.uniforms.envMap.value=f,l.material.uniforms.flipEnvMap.value=f.isCubeTexture&&!1===f.isRenderTargetTexture?-1:1,h===f&&u===f.version&&d===e.toneMapping||(l.material.needsUpdate=!0,h=f,u=f.version,d=e.toneMapping),l.layers.enableAll(),i.unshift(l,l.geometry,l.material,0,0,null)):f&&f.isTexture&&(void 0===o&&(o=new Mesh(new PlaneGeometry(2,2),new ShaderMaterial({name:"BackgroundMaterial",uniforms:cloneUniforms(gn.background.uniforms),vertexShader:gn.background.vertexShader,fragmentShader:gn.background.fragmentShader,side:p,depthTest:!1,depthWrite:!1,fog:!1})),o.geometry.deleteAttribute("normal"),Object.defineProperty(o.material,"map",{get:function(){return this.uniforms.t2D.value}}),r.update(o)),o.material.uniforms.t2D.value=f,!0===f.matrixAutoUpdate&&f.updateMatrix(),o.material.uniforms.uvTransform.value.copy(f.matrix),h===f&&u===f.version&&d===e.toneMapping||(o.material.needsUpdate=!0,h=f,u=f.version,d=e.toneMapping),o.layers.enableAll(),i.unshift(o,o.geometry,o.material,0,0,null))}}}function WebGLBindingStates(e,t,i,r){const n=e.getParameter(34921),s=r.isWebGL2?null:t.get("OES_vertex_array_object"),a=r.isWebGL2||null!==s,o={},l=createBindingState(null);let c=l,h=!1;function bindVertexArrayObject(t){return r.isWebGL2?e.bindVertexArray(t):s.bindVertexArrayOES(t)}function deleteVertexArrayObject(t){return r.isWebGL2?e.deleteVertexArray(t):s.deleteVertexArrayOES(t)}function createBindingState(e){const t=[],i=[],r=[];for(let s=0;s<n;s++)t[s]=0,i[s]=0,r[s]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:t,enabledAttributes:i,attributeDivisors:r,object:e,attributes:{},index:null}}function initAttributes(){const e=c.newAttributes;for(let t=0,i=e.length;t<i;t++)e[t]=0}function enableAttribute(e){enableAttributeAndDivisor(e,0)}function enableAttributeAndDivisor(i,n){const s=c.newAttributes,a=c.enabledAttributes,o=c.attributeDivisors;if(s[i]=1,0===a[i]&&(e.enableVertexAttribArray(i),a[i]=1),o[i]!==n){(r.isWebGL2?e:t.get("ANGLE_instanced_arrays"))[r.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](i,n),o[i]=n}}function disableUnusedAttributes(){const t=c.newAttributes,i=c.enabledAttributes;for(let r=0,n=i.length;r<n;r++)i[r]!==t[r]&&(e.disableVertexAttribArray(r),i[r]=0)}function vertexAttribPointer(t,i,n,s,a,o){!0!==r.isWebGL2||5124!==n&&5125!==n?e.vertexAttribPointer(t,i,n,s,a,o):e.vertexAttribIPointer(t,i,n,a,o)}function reset(){resetDefaultState(),h=!0,c!==l&&(c=l,bindVertexArrayObject(c.object))}function resetDefaultState(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:function setup(n,l,u,d,p){let m=!1;if(a){const t=function getBindingState(t,i,n){const a=!0===n.wireframe;let l=o[t.id];void 0===l&&(l={},o[t.id]=l);let c=l[i.id];void 0===c&&(c={},l[i.id]=c);let h=c[a];void 0===h&&(h=createBindingState(function createVertexArrayObject(){return r.isWebGL2?e.createVertexArray():s.createVertexArrayOES()}()),c[a]=h);return h}(d,u,l);c!==t&&(c=t,bindVertexArrayObject(c.object)),m=function needsUpdate(e,t,i,r){const n=c.attributes,s=t.attributes;let a=0;const o=i.getAttributes();for(const l in o){if(o[l].location>=0){const t=n[l];let i=s[l];if(void 0===i&&("instanceMatrix"===l&&e.instanceMatrix&&(i=e.instanceMatrix),"instanceColor"===l&&e.instanceColor&&(i=e.instanceColor)),void 0===t)return!0;if(t.attribute!==i)return!0;if(i&&t.data!==i.data)return!0;a++}}return c.attributesNum!==a||c.index!==r}(n,d,u,p),m&&function saveCache(e,t,i,r){const n={},s=t.attributes;let a=0;const o=i.getAttributes();for(const l in o){if(o[l].location>=0){let t=s[l];void 0===t&&("instanceMatrix"===l&&e.instanceMatrix&&(t=e.instanceMatrix),"instanceColor"===l&&e.instanceColor&&(t=e.instanceColor));const i={};i.attribute=t,t&&t.data&&(i.data=t.data),n[l]=i,a++}}c.attributes=n,c.attributesNum=a,c.index=r}(n,d,u,p)}else{const e=!0===l.wireframe;c.geometry===d.id&&c.program===u.id&&c.wireframe===e||(c.geometry=d.id,c.program=u.id,c.wireframe=e,m=!0)}null!==p&&i.update(p,34963),(m||h)&&(h=!1,function setupVertexAttributes(n,s,a,o){if(!1===r.isWebGL2&&(n.isInstancedMesh||o.isInstancedBufferGeometry)&&null===t.get("ANGLE_instanced_arrays"))return;initAttributes();const l=o.attributes,c=a.getAttributes(),h=s.defaultAttributeValues;for(const t in c){const r=c[t];if(r.location>=0){let s=l[t];if(void 0===s&&("instanceMatrix"===t&&n.instanceMatrix&&(s=n.instanceMatrix),"instanceColor"===t&&n.instanceColor&&(s=n.instanceColor)),void 0!==s){const t=s.normalized,a=s.itemSize,l=i.get(s);if(void 0===l)continue;const c=l.buffer,h=l.type,u=l.bytesPerElement;if(s.isInterleavedBufferAttribute){const i=s.data,l=i.stride,d=s.offset;if(i.isInstancedInterleavedBuffer){for(let e=0;e<r.locationSize;e++)enableAttributeAndDivisor(r.location+e,i.meshPerAttribute);!0!==n.isInstancedMesh&&void 0===o._maxInstanceCount&&(o._maxInstanceCount=i.meshPerAttribute*i.count)}else for(let e=0;e<r.locationSize;e++)enableAttribute(r.location+e);e.bindBuffer(34962,c);for(let e=0;e<r.locationSize;e++)vertexAttribPointer(r.location+e,a/r.locationSize,h,t,l*u,(d+a/r.locationSize*e)*u)}else{if(s.isInstancedBufferAttribute){for(let e=0;e<r.locationSize;e++)enableAttributeAndDivisor(r.location+e,s.meshPerAttribute);!0!==n.isInstancedMesh&&void 0===o._maxInstanceCount&&(o._maxInstanceCount=s.meshPerAttribute*s.count)}else for(let e=0;e<r.locationSize;e++)enableAttribute(r.location+e);e.bindBuffer(34962,c);for(let e=0;e<r.locationSize;e++)vertexAttribPointer(r.location+e,a/r.locationSize,h,t,a*u,a/r.locationSize*e*u)}}else if(void 0!==h){const i=h[t];if(void 0!==i)switch(i.length){case 2:e.vertexAttrib2fv(r.location,i);break;case 3:e.vertexAttrib3fv(r.location,i);break;case 4:e.vertexAttrib4fv(r.location,i);break;default:e.vertexAttrib1fv(r.location,i)}}}}disableUnusedAttributes()}(n,l,u,d),null!==p&&e.bindBuffer(34963,i.get(p).buffer))},reset:reset,resetDefaultState:resetDefaultState,dispose:function dispose(){reset();for(const e in o){const t=o[e];for(const e in t){const i=t[e];for(const e in i)deleteVertexArrayObject(i[e].object),delete i[e];delete t[e]}delete o[e]}},releaseStatesOfGeometry:function releaseStatesOfGeometry(e){if(void 0===o[e.id])return;const t=o[e.id];for(const i in t){const e=t[i];for(const t in e)deleteVertexArrayObject(e[t].object),delete e[t];delete t[i]}delete o[e.id]},releaseStatesOfProgram:function releaseStatesOfProgram(e){for(const t in o){const i=o[t];if(void 0===i[e.id])continue;const r=i[e.id];for(const e in r)deleteVertexArrayObject(r[e].object),delete r[e];delete i[e.id]}},initAttributes:initAttributes,enableAttribute:enableAttribute,disableUnusedAttributes:disableUnusedAttributes}}function WebGLBufferRenderer(e,t,i,r){const n=r.isWebGL2;let s;this.setMode=function setMode(e){s=e},this.render=function render(t,r){e.drawArrays(s,t,r),i.update(r,s,1)},this.renderInstances=function renderInstances(r,a,o){if(0===o)return;let l,c;if(n)l=e,c="drawArraysInstanced";else if(l=t.get("ANGLE_instanced_arrays"),c="drawArraysInstancedANGLE",null===l)return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");l[c](s,r,a,o),i.update(a,s,o)}}function WebGLCapabilities(e,t,i){let r;function getMaxPrecision(t){if("highp"===t){if(e.getShaderPrecisionFormat(35633,36338).precision>0&&e.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";t="mediump"}return"mediump"===t&&e.getShaderPrecisionFormat(35633,36337).precision>0&&e.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const n="undefined"!==typeof WebGL2RenderingContext&&e instanceof WebGL2RenderingContext||"undefined"!==typeof WebGL2ComputeRenderingContext&&e instanceof WebGL2ComputeRenderingContext;let s=void 0!==i.precision?i.precision:"highp";const a=getMaxPrecision(s);a!==s&&(console.warn("THREE.WebGLRenderer:",s,"not supported, using",a,"instead."),s=a);const o=n||t.has("WEBGL_draw_buffers"),l=!0===i.logarithmicDepthBuffer,c=e.getParameter(34930),h=e.getParameter(35660),u=e.getParameter(3379),d=e.getParameter(34076),p=e.getParameter(34921),m=e.getParameter(36347),f=e.getParameter(36348),g=e.getParameter(36349),x=h>0,y=n||t.has("OES_texture_float");return{isWebGL2:n,drawBuffers:o,getMaxAnisotropy:function getMaxAnisotropy(){if(void 0!==r)return r;if(!0===t.has("EXT_texture_filter_anisotropic")){const i=t.get("EXT_texture_filter_anisotropic");r=e.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else r=0;return r},getMaxPrecision:getMaxPrecision,precision:s,logarithmicDepthBuffer:l,maxTextures:c,maxVertexTextures:h,maxTextureSize:u,maxCubemapSize:d,maxAttributes:p,maxVertexUniforms:m,maxVaryings:f,maxFragmentUniforms:g,vertexTextures:x,floatFragmentTextures:y,floatVertexTextures:x&&y,maxSamples:n?e.getParameter(36183):0}}function WebGLClipping(e){const t=this;let i=null,r=0,n=!1,s=!1;const a=new Plane,o=new Matrix3,l={value:null,needsUpdate:!1};function resetGlobalState(){l.value!==i&&(l.value=i,l.needsUpdate=r>0),t.numPlanes=r,t.numIntersection=0}function projectPlanes(e,i,r,n){const s=null!==e?e.length:0;let c=null;if(0!==s){if(c=l.value,!0!==n||null===c){const t=r+4*s,n=i.matrixWorldInverse;o.getNormalMatrix(n),(null===c||c.length<t)&&(c=new Float32Array(t));for(let i=0,l=r;i!==s;++i,l+=4)a.copy(e[i]).applyMatrix4(n,o),a.normal.toArray(c,l),c[l+3]=a.constant}l.value=c,l.needsUpdate=!0}return t.numPlanes=s,t.numIntersection=0,c}this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(e,t,s){const a=0!==e.length||t||0!==r||n;return n=t,i=projectPlanes(e,s,0),r=e.length,a},this.beginShadows=function(){s=!0,projectPlanes(null)},this.endShadows=function(){s=!1,resetGlobalState()},this.setState=function(t,a,o){const c=t.clippingPlanes,h=t.clipIntersection,u=t.clipShadows,d=e.get(t);if(!n||null===c||0===c.length||s&&!u)s?projectPlanes(null):resetGlobalState();else{const e=s?0:r,t=4*e;let n=d.clippingState||null;l.value=n,n=projectPlanes(c,a,t,o);for(let r=0;r!==t;++r)n[r]=i[r];d.clippingState=n,this.numIntersection=h?this.numPlanes:0,this.numPlanes+=e}}}function WebGLCubeMaps(e){let t=new WeakMap;function mapTextureMapping(e,t){return t===oe?e.mapping=se:t===le&&(e.mapping=ae),e}function onTextureDispose(e){const i=e.target;i.removeEventListener("dispose",onTextureDispose);const r=t.get(i);void 0!==r&&(t.delete(i),r.dispose())}return{get:function get(i){if(i&&i.isTexture&&!1===i.isRenderTargetTexture){const r=i.mapping;if(r===oe||r===le){if(t.has(i)){return mapTextureMapping(t.get(i).texture,i.mapping)}{const r=i.image;if(r&&r.height>0){const n=new WebGLCubeRenderTarget(r.height/2);return n.fromEquirectangularTexture(e,i),t.set(i,n),i.addEventListener("dispose",onTextureDispose),mapTextureMapping(n.texture,i.mapping)}return null}}}return i},dispose:function dispose(){t=new WeakMap}}}gn.physical={uniforms:mergeUniforms([gn.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new Vector2(1,1)},clearcoatNormalMap:{value:null},iridescence:{value:0},iridescenceMap:{value:null},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},sheen:{value:0},sheenColor:{value:new Color(0)},sheenColorMap:{value:null},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new Vector2},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new Color(0)},specularIntensity:{value:1},specularIntensityMap:{value:null},specularColor:{value:new Color(1,1,1)},specularColorMap:{value:null}}]),vertexShader:mn.meshphysical_vert,fragmentShader:mn.meshphysical_frag};class OrthographicCamera extends Camera{constructor(e=-1,t=1,i=1,r=-1,n=.1,s=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=i,this.bottom=r,this.near=n,this.far=s,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=null===e.view?null:Object.assign({},e.view),this}setViewOffset(e,t,i,r,n,s){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=i,this.view.offsetY=r,this.view.width=n,this.view.height=s,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),i=(this.right+this.left)/2,r=(this.top+this.bottom)/2;let n=i-e,s=i+e,a=r+t,o=r-t;if(null!==this.view&&this.view.enabled){const e=(this.right-this.left)/this.view.fullWidth/this.zoom,t=(this.top-this.bottom)/this.view.fullHeight/this.zoom;n+=e*this.view.offsetX,s=n+e*this.view.width,a-=t*this.view.offsetY,o=a-t*this.view.height}this.projectionMatrix.makeOrthographic(n,s,a,o,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,null!==this.view&&(t.object.view=Object.assign({},this.view)),t}}const vn=4,xn=[.125,.215,.35,.446,.526,.582],yn=20,_n=new OrthographicCamera,bn=new Color;let Mn=null;const Sn=(1+Math.sqrt(5))/2,wn=1/Sn,Tn=[new Vector3(1,1,1),new Vector3(-1,1,1),new Vector3(1,1,-1),new Vector3(-1,1,-1),new Vector3(0,Sn,wn),new Vector3(0,Sn,-wn),new Vector3(wn,0,Sn),new Vector3(-wn,0,Sn),new Vector3(Sn,wn,0),new Vector3(-Sn,wn,0)];class PMREMGenerator{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,i=.1,r=100){Mn=this._renderer.getRenderTarget(),this._setSize(256);const n=this._allocateTargets();return n.depthBuffer=!0,this._sceneToCubeUV(e,i,r,n),t>0&&this._blur(n,0,0,t),this._applyPMREM(n),this._cleanup(n),n}fromEquirectangular(e,t=null){return this._fromTexture(e,t)}fromCubemap(e,t=null){return this._fromTexture(e,t)}compileCubemapShader(){null===this._cubemapMaterial&&(this._cubemapMaterial=_getCubemapMaterial(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){null===this._equirectMaterial&&(this._equirectMaterial=_getEquirectMaterial(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),null!==this._cubemapMaterial&&this._cubemapMaterial.dispose(),null!==this._equirectMaterial&&this._equirectMaterial.dispose()}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){null!==this._blurMaterial&&this._blurMaterial.dispose(),null!==this._pingPongRenderTarget&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(Mn),e.scissorTest=!1,_setViewport(e,0,0,e.width,e.height)}_fromTexture(e,t){e.mapping===se||e.mapping===ae?this._setSize(0===e.image.length?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),Mn=this._renderer.getRenderTarget();const i=t||this._allocateTargets();return this._textureToCubeUV(e,i),this._applyPMREM(i),this._cleanup(i),i}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,i={magFilter:xe,minFilter:xe,generateMipmaps:!1,type:Pe,format:Ne,encoding:Dt,depthBuffer:!1},r=_createRenderTarget(e,t,i);if(null===this._pingPongRenderTarget||this._pingPongRenderTarget.width!==e){null!==this._pingPongRenderTarget&&this._dispose(),this._pingPongRenderTarget=_createRenderTarget(e,t,i);const{_lodMax:r}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=function _createPlanes(e){const t=[],i=[],r=[];let n=e;const s=e-vn+1+xn.length;for(let a=0;a<s;a++){const s=Math.pow(2,n);i.push(s);let o=1/s;a>e-vn?o=xn[a-e+vn-1]:0===a&&(o=0),r.push(o);const l=1/(s-2),c=-l,h=1+l,u=[c,c,h,c,h,h,c,c,h,h,c,h],d=6,p=6,m=3,f=2,g=1,x=new Float32Array(m*p*d),y=new Float32Array(f*p*d),_=new Float32Array(g*p*d);for(let e=0;e<d;e++){const t=e%3*2/3-1,i=e>2?0:-1,r=[t,i,0,t+2/3,i,0,t+2/3,i+1,0,t,i,0,t+2/3,i+1,0,t,i+1,0];x.set(r,m*p*e),y.set(u,f*p*e);const n=[e,e,e,e,e,e];_.set(n,g*p*e)}const b=new BufferGeometry;b.setAttribute("position",new BufferAttribute(x,m)),b.setAttribute("uv",new BufferAttribute(y,f)),b.setAttribute("faceIndex",new BufferAttribute(_,g)),t.push(b),n>vn&&n--}return{lodPlanes:t,sizeLods:i,sigmas:r}}(r)),this._blurMaterial=function _getBlurShader(e,t,i){const r=new Float32Array(yn),n=new Vector3(0,1,0),s=new ShaderMaterial({name:"SphericalGaussianBlur",defines:{n:yn,CUBEUV_TEXEL_WIDTH:1/t,CUBEUV_TEXEL_HEIGHT:1/i,CUBEUV_MAX_MIP:`${e}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:r},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:n}},vertexShader:_getCommonVertexShader(),fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",blending:y,depthTest:!1,depthWrite:!1});return s}(r,e,t)}return r}_compileMaterial(e){const t=new Mesh(this._lodPlanes[0],e);this._renderer.compile(t,_n)}_sceneToCubeUV(e,t,i,r){const n=new PerspectiveCamera(90,1,t,i),s=[1,-1,1,1,1,1],a=[1,1,1,-1,-1,-1],o=this._renderer,l=o.autoClear,c=o.toneMapping;o.getClearColor(bn),o.toneMapping=Q,o.autoClear=!1;const h=new MeshBasicMaterial({name:"PMREM.Background",side:m,depthWrite:!1,depthTest:!1}),u=new Mesh(new BoxGeometry,h);let d=!1;const p=e.background;p?p.isColor&&(h.color.copy(p),e.background=null,d=!0):(h.color.copy(bn),d=!0);for(let m=0;m<6;m++){const t=m%3;0===t?(n.up.set(0,s[m],0),n.lookAt(a[m],0,0)):1===t?(n.up.set(0,0,s[m]),n.lookAt(0,a[m],0)):(n.up.set(0,s[m],0),n.lookAt(0,0,a[m]));const i=this._cubeSize;_setViewport(r,t*i,m>2?i:0,i,i),o.setRenderTarget(r),d&&o.render(u,n),o.render(e,n)}u.geometry.dispose(),u.material.dispose(),o.toneMapping=c,o.autoClear=l,e.background=p}_textureToCubeUV(e,t){const i=this._renderer,r=e.mapping===se||e.mapping===ae;r?(null===this._cubemapMaterial&&(this._cubemapMaterial=_getCubemapMaterial()),this._cubemapMaterial.uniforms.flipEnvMap.value=!1===e.isRenderTargetTexture?-1:1):null===this._equirectMaterial&&(this._equirectMaterial=_getEquirectMaterial());const n=r?this._cubemapMaterial:this._equirectMaterial,s=new Mesh(this._lodPlanes[0],n);n.uniforms.envMap.value=e;const a=this._cubeSize;_setViewport(t,0,0,3*a,2*a),i.setRenderTarget(t),i.render(s,_n)}_applyPMREM(e){const t=this._renderer,i=t.autoClear;t.autoClear=!1;for(let r=1;r<this._lodPlanes.length;r++){const t=Math.sqrt(this._sigmas[r]*this._sigmas[r]-this._sigmas[r-1]*this._sigmas[r-1]),i=Tn[(r-1)%Tn.length];this._blur(e,r-1,r,t,i)}t.autoClear=i}_blur(e,t,i,r,n){const s=this._pingPongRenderTarget;this._halfBlur(e,s,t,i,r,"latitudinal",n),this._halfBlur(s,e,i,i,r,"longitudinal",n)}_halfBlur(e,t,i,r,n,s,a){const o=this._renderer,l=this._blurMaterial;"latitudinal"!==s&&"longitudinal"!==s&&console.error("blur direction must be either latitudinal or longitudinal!");const c=new Mesh(this._lodPlanes[r],l),h=l.uniforms,u=this._sizeLods[i]-1,d=isFinite(n)?Math.PI/(2*u):2*Math.PI/(2*yn-1),p=n/d,m=isFinite(n)?1+Math.floor(3*p):yn;m>yn&&console.warn(`sigmaRadians, ${n}, is too large and will clip, as it requested ${m} samples when the maximum is set to ${yn}`);const f=[];let g=0;for(let _=0;_<yn;++_){const e=_/p,t=Math.exp(-e*e/2);f.push(t),0===_?g+=t:_<m&&(g+=2*t)}for(let _=0;_<f.length;_++)f[_]=f[_]/g;h.envMap.value=e.texture,h.samples.value=m,h.weights.value=f,h.latitudinal.value="latitudinal"===s,a&&(h.poleAxis.value=a);const{_lodMax:x}=this;h.dTheta.value=d,h.mipInt.value=x-i;const y=this._sizeLods[r];_setViewport(t,3*y*(r>x-vn?r-x+vn:0),4*(this._cubeSize-y),3*y,2*y),o.setRenderTarget(t),o.render(c,_n)}}function _createRenderTarget(e,t,i){const r=new WebGLRenderTarget(e,t,i);return r.texture.mapping=ce,r.texture.name="PMREM.cubeUv",r.scissorTest=!0,r}function _setViewport(e,t,i,r,n){e.viewport.set(t,i,r,n),e.scissor.set(t,i,r,n)}function _getEquirectMaterial(){return new ShaderMaterial({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:_getCommonVertexShader(),fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",blending:y,depthTest:!1,depthWrite:!1})}function _getCubemapMaterial(){return new ShaderMaterial({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:_getCommonVertexShader(),fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",blending:y,depthTest:!1,depthWrite:!1})}function _getCommonVertexShader(){return"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"}function WebGLCubeUVMaps(e){let t=new WeakMap,i=null;function onTextureDispose(e){const i=e.target;i.removeEventListener("dispose",onTextureDispose);const r=t.get(i);void 0!==r&&(t.delete(i),r.dispose())}return{get:function get(r){if(r&&r.isTexture){const n=r.mapping,s=n===oe||n===le,a=n===se||n===ae;if(s||a){if(r.isRenderTargetTexture&&!0===r.needsPMREMUpdate){r.needsPMREMUpdate=!1;let n=t.get(r);return null===i&&(i=new PMREMGenerator(e)),n=s?i.fromEquirectangular(r,n):i.fromCubemap(r,n),t.set(r,n),n.texture}if(t.has(r))return t.get(r).texture;{const n=r.image;if(s&&n&&n.height>0||a&&n&&function isCubeTextureComplete(e){let t=0;const i=6;for(let r=0;r<i;r++)void 0!==e[r]&&t++;return t===i}(n)){null===i&&(i=new PMREMGenerator(e));const n=s?i.fromEquirectangular(r):i.fromCubemap(r);return t.set(r,n),r.addEventListener("dispose",onTextureDispose),n.texture}return null}}}return r},dispose:function dispose(){t=new WeakMap,null!==i&&(i.dispose(),i=null)}}}function WebGLExtensions(e){const t={};function getExtension(i){if(void 0!==t[i])return t[i];let r;switch(i){case"WEBGL_depth_texture":r=e.getExtension("WEBGL_depth_texture")||e.getExtension("MOZ_WEBGL_depth_texture")||e.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":r=e.getExtension("EXT_texture_filter_anisotropic")||e.getExtension("MOZ_EXT_texture_filter_anisotropic")||e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":r=e.getExtension("WEBGL_compressed_texture_s3tc")||e.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":r=e.getExtension("WEBGL_compressed_texture_pvrtc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:r=e.getExtension(i)}return t[i]=r,r}return{has:function(e){return null!==getExtension(e)},init:function(e){e.isWebGL2?getExtension("EXT_color_buffer_float"):(getExtension("WEBGL_depth_texture"),getExtension("OES_texture_float"),getExtension("OES_texture_half_float"),getExtension("OES_texture_half_float_linear"),getExtension("OES_standard_derivatives"),getExtension("OES_element_index_uint"),getExtension("OES_vertex_array_object"),getExtension("ANGLE_instanced_arrays")),getExtension("OES_texture_float_linear"),getExtension("EXT_color_buffer_half_float"),getExtension("WEBGL_multisampled_render_to_texture")},get:function(e){const t=getExtension(e);return null===t&&console.warn("THREE.WebGLRenderer: "+e+" extension not supported."),t}}}function WebGLGeometries(e,t,i,r){const n={},s=new WeakMap;function onGeometryDispose(e){const a=e.target;null!==a.index&&t.remove(a.index);for(const i in a.attributes)t.remove(a.attributes[i]);a.removeEventListener("dispose",onGeometryDispose),delete n[a.id];const o=s.get(a);o&&(t.remove(o),s.delete(a)),r.releaseStatesOfGeometry(a),!0===a.isInstancedBufferGeometry&&delete a._maxInstanceCount,i.memory.geometries--}function updateWireframeAttribute(e){const i=[],r=e.index,n=e.attributes.position;let a=0;if(null!==r){const e=r.array;a=r.version;for(let t=0,r=e.length;t<r;t+=3){const r=e[t+0],n=e[t+1],s=e[t+2];i.push(r,n,n,s,s,r)}}else{const e=n.array;a=n.version;for(let t=0,r=e.length/3-1;t<r;t+=3){const e=t+0,r=t+1,n=t+2;i.push(e,r,r,n,n,e)}}const o=new(arrayNeedsUint32(i)?Uint32BufferAttribute:Uint16BufferAttribute)(i,1);o.version=a;const l=s.get(e);l&&t.remove(l),s.set(e,o)}return{get:function get(e,t){return!0===n[t.id]||(t.addEventListener("dispose",onGeometryDispose),n[t.id]=!0,i.memory.geometries++),t},update:function update(e){const i=e.attributes;for(const n in i)t.update(i[n],34962);const r=e.morphAttributes;for(const n in r){const e=r[n];for(let i=0,r=e.length;i<r;i++)t.update(e[i],34962)}},getWireframeAttribute:function getWireframeAttribute(e){const t=s.get(e);if(t){const i=e.index;null!==i&&t.version<i.version&&updateWireframeAttribute(e)}else updateWireframeAttribute(e);return s.get(e)}}}function WebGLIndexedBufferRenderer(e,t,i,r){const n=r.isWebGL2;let s,a,o;this.setMode=function setMode(e){s=e},this.setIndex=function setIndex(e){a=e.type,o=e.bytesPerElement},this.render=function render(t,r){e.drawElements(s,r,a,t*o),i.update(r,s,1)},this.renderInstances=function renderInstances(r,l,c){if(0===c)return;let h,u;if(n)h=e,u="drawElementsInstanced";else if(h=t.get("ANGLE_instanced_arrays"),u="drawElementsInstancedANGLE",null===h)return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");h[u](s,l,a,r*o,c),i.update(l,s,c)}}function WebGLInfo(e){const t={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:t,programs:null,autoReset:!0,reset:function reset(){t.frame++,t.calls=0,t.triangles=0,t.points=0,t.lines=0},update:function update(e,i,r){switch(t.calls++,i){case 4:t.triangles+=r*(e/3);break;case 1:t.lines+=r*(e/2);break;case 3:t.lines+=r*(e-1);break;case 2:t.lines+=r*e;break;case 0:t.points+=r*e;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",i)}}}}function numericalSort(e,t){return e[0]-t[0]}function absNumericalSort(e,t){return Math.abs(t[1])-Math.abs(e[1])}function denormalize(e,t){let i=1;const r=t.isInterleavedBufferAttribute?t.data.array:t.array;r instanceof Int8Array?i=127:r instanceof Uint8Array?i=255:r instanceof Uint16Array?i=65535:r instanceof Int16Array?i=32767:r instanceof Int32Array?i=2147483647:console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",r),e.divideScalar(i)}function WebGLMorphtargets(e,t,i){const r={},n=new Float32Array(8),s=new WeakMap,a=new Vector4,o=[];for(let l=0;l<8;l++)o[l]=[l,0];return{update:function update(l,c,h,u){const d=l.morphTargetInfluences;if(!0===t.isWebGL2){const p=c.morphAttributes.position||c.morphAttributes.normal||c.morphAttributes.color,m=void 0!==p?p.length:0;let f=s.get(c);if(void 0===f||f.count!==m){void 0!==f&&f.texture.dispose();const y=void 0!==c.morphAttributes.position,_=void 0!==c.morphAttributes.normal,b=void 0!==c.morphAttributes.color,M=c.morphAttributes.position||[],S=c.morphAttributes.normal||[],w=c.morphAttributes.color||[];let T=0;!0===y&&(T=1),!0===_&&(T=2),!0===b&&(T=3);let A=c.attributes.position.count*T,C=1;A>t.maxTextureSize&&(C=Math.ceil(A/t.maxTextureSize),A=t.maxTextureSize);const E=new Float32Array(A*C*4*m),L=new DataArrayTexture(E,A,C,m);L.type=Le,L.needsUpdate=!0;const P=4*T;for(let R=0;R<m;R++){const D=M[R],I=S[R],B=w[R],V=A*C*4*R;for(let N=0;N<D.count;N++){const O=N*P;!0===y&&(a.fromBufferAttribute(D,N),!0===D.normalized&&denormalize(a,D),E[V+O+0]=a.x,E[V+O+1]=a.y,E[V+O+2]=a.z,E[V+O+3]=0),!0===_&&(a.fromBufferAttribute(I,N),!0===I.normalized&&denormalize(a,I),E[V+O+4]=a.x,E[V+O+5]=a.y,E[V+O+6]=a.z,E[V+O+7]=0),!0===b&&(a.fromBufferAttribute(B,N),!0===B.normalized&&denormalize(a,B),E[V+O+8]=a.x,E[V+O+9]=a.y,E[V+O+10]=a.z,E[V+O+11]=4===B.itemSize?a.w:1)}}function disposeTexture(){L.dispose(),s.delete(c),c.removeEventListener("dispose",disposeTexture)}f={count:m,texture:L,size:new Vector2(A,C)},s.set(c,f),c.addEventListener("dispose",disposeTexture)}let g=0;for(let z=0;z<d.length;z++)g+=d[z];const x=c.morphTargetsRelative?1:1-g;u.getUniforms().setValue(e,"morphTargetBaseInfluence",x),u.getUniforms().setValue(e,"morphTargetInfluences",d),u.getUniforms().setValue(e,"morphTargetsTexture",f.texture,i),u.getUniforms().setValue(e,"morphTargetsTextureSize",f.size)}else{const F=void 0===d?0:d.length;let G=r[c.id];if(void 0===G||G.length!==F){G=[];for(let j=0;j<F;j++)G[j]=[j,0];r[c.id]=G}for(let q=0;q<F;q++){const X=G[q];X[0]=q,X[1]=d[q]}G.sort(absNumericalSort);for(let Y=0;Y<8;Y++)Y<F&&G[Y][1]?(o[Y][0]=G[Y][0],o[Y][1]=G[Y][1]):(o[Y][0]=Number.MAX_SAFE_INTEGER,o[Y][1]=0);o.sort(numericalSort);const U=c.morphAttributes.position,k=c.morphAttributes.normal;let W=0;for(let Z=0;Z<8;Z++){const J=o[Z],K=J[0],Q=J[1];K!==Number.MAX_SAFE_INTEGER&&Q?(U&&c.getAttribute("morphTarget"+Z)!==U[K]&&c.setAttribute("morphTarget"+Z,U[K]),k&&c.getAttribute("morphNormal"+Z)!==k[K]&&c.setAttribute("morphNormal"+Z,k[K]),n[Z]=Q,W+=Q):(U&&!0===c.hasAttribute("morphTarget"+Z)&&c.deleteAttribute("morphTarget"+Z),k&&!0===c.hasAttribute("morphNormal"+Z)&&c.deleteAttribute("morphNormal"+Z),n[Z]=0)}const H=c.morphTargetsRelative?1:1-W;u.getUniforms().setValue(e,"morphTargetBaseInfluence",H),u.getUniforms().setValue(e,"morphTargetInfluences",n)}}}}function WebGLObjects(e,t,i,r){let n=new WeakMap;function onInstancedMeshDispose(e){const t=e.target;t.removeEventListener("dispose",onInstancedMeshDispose),i.remove(t.instanceMatrix),null!==t.instanceColor&&i.remove(t.instanceColor)}return{update:function update(e){const s=r.render.frame,a=e.geometry,o=t.get(e,a);return n.get(o)!==s&&(t.update(o),n.set(o,s)),e.isInstancedMesh&&(!1===e.hasEventListener("dispose",onInstancedMeshDispose)&&e.addEventListener("dispose",onInstancedMeshDispose),i.update(e.instanceMatrix,34962),null!==e.instanceColor&&i.update(e.instanceColor,34962)),o},dispose:function dispose(){n=new WeakMap}}}const An=new Texture,Cn=new DataArrayTexture,En=new Data3DTexture,Ln=new CubeTexture,Pn=[],Rn=[],Dn=new Float32Array(16),In=new Float32Array(9),Bn=new Float32Array(4);function flatten(e,t,i){const r=e[0];if(r<=0||r>0)return e;const n=t*i;let s=Pn[n];if(void 0===s&&(s=new Float32Array(n),Pn[n]=s),0!==t){r.toArray(s,0);for(let r=1,n=0;r!==t;++r)n+=i,e[r].toArray(s,n)}return s}function arraysEqual(e,t){if(e.length!==t.length)return!1;for(let i=0,r=e.length;i<r;i++)if(e[i]!==t[i])return!1;return!0}function copyArray(e,t){for(let i=0,r=t.length;i<r;i++)e[i]=t[i]}function allocTexUnits(e,t){let i=Rn[t];void 0===i&&(i=new Int32Array(t),Rn[t]=i);for(let r=0;r!==t;++r)i[r]=e.allocateTextureUnit();return i}function setValueV1f(e,t){const i=this.cache;i[0]!==t&&(e.uniform1f(this.addr,t),i[0]=t)}function setValueV2f(e,t){const i=this.cache;if(void 0!==t.x)i[0]===t.x&&i[1]===t.y||(e.uniform2f(this.addr,t.x,t.y),i[0]=t.x,i[1]=t.y);else{if(arraysEqual(i,t))return;e.uniform2fv(this.addr,t),copyArray(i,t)}}function setValueV3f(e,t){const i=this.cache;if(void 0!==t.x)i[0]===t.x&&i[1]===t.y&&i[2]===t.z||(e.uniform3f(this.addr,t.x,t.y,t.z),i[0]=t.x,i[1]=t.y,i[2]=t.z);else if(void 0!==t.r)i[0]===t.r&&i[1]===t.g&&i[2]===t.b||(e.uniform3f(this.addr,t.r,t.g,t.b),i[0]=t.r,i[1]=t.g,i[2]=t.b);else{if(arraysEqual(i,t))return;e.uniform3fv(this.addr,t),copyArray(i,t)}}function setValueV4f(e,t){const i=this.cache;if(void 0!==t.x)i[0]===t.x&&i[1]===t.y&&i[2]===t.z&&i[3]===t.w||(e.uniform4f(this.addr,t.x,t.y,t.z,t.w),i[0]=t.x,i[1]=t.y,i[2]=t.z,i[3]=t.w);else{if(arraysEqual(i,t))return;e.uniform4fv(this.addr,t),copyArray(i,t)}}function setValueM2(e,t){const i=this.cache,r=t.elements;if(void 0===r){if(arraysEqual(i,t))return;e.uniformMatrix2fv(this.addr,!1,t),copyArray(i,t)}else{if(arraysEqual(i,r))return;Bn.set(r),e.uniformMatrix2fv(this.addr,!1,Bn),copyArray(i,r)}}function setValueM3(e,t){const i=this.cache,r=t.elements;if(void 0===r){if(arraysEqual(i,t))return;e.uniformMatrix3fv(this.addr,!1,t),copyArray(i,t)}else{if(arraysEqual(i,r))return;In.set(r),e.uniformMatrix3fv(this.addr,!1,In),copyArray(i,r)}}function setValueM4(e,t){const i=this.cache,r=t.elements;if(void 0===r){if(arraysEqual(i,t))return;e.uniformMatrix4fv(this.addr,!1,t),copyArray(i,t)}else{if(arraysEqual(i,r))return;Dn.set(r),e.uniformMatrix4fv(this.addr,!1,Dn),copyArray(i,r)}}function setValueV1i(e,t){const i=this.cache;i[0]!==t&&(e.uniform1i(this.addr,t),i[0]=t)}function setValueV2i(e,t){const i=this.cache;arraysEqual(i,t)||(e.uniform2iv(this.addr,t),copyArray(i,t))}function setValueV3i(e,t){const i=this.cache;arraysEqual(i,t)||(e.uniform3iv(this.addr,t),copyArray(i,t))}function setValueV4i(e,t){const i=this.cache;arraysEqual(i,t)||(e.uniform4iv(this.addr,t),copyArray(i,t))}function setValueV1ui(e,t){const i=this.cache;i[0]!==t&&(e.uniform1ui(this.addr,t),i[0]=t)}function setValueV2ui(e,t){const i=this.cache;arraysEqual(i,t)||(e.uniform2uiv(this.addr,t),copyArray(i,t))}function setValueV3ui(e,t){const i=this.cache;arraysEqual(i,t)||(e.uniform3uiv(this.addr,t),copyArray(i,t))}function setValueV4ui(e,t){const i=this.cache;arraysEqual(i,t)||(e.uniform4uiv(this.addr,t),copyArray(i,t))}function setValueT1(e,t,i){const r=this.cache,n=i.allocateTextureUnit();r[0]!==n&&(e.uniform1i(this.addr,n),r[0]=n),i.setTexture2D(t||An,n)}function setValueT3D1(e,t,i){const r=this.cache,n=i.allocateTextureUnit();r[0]!==n&&(e.uniform1i(this.addr,n),r[0]=n),i.setTexture3D(t||En,n)}function setValueT6(e,t,i){const r=this.cache,n=i.allocateTextureUnit();r[0]!==n&&(e.uniform1i(this.addr,n),r[0]=n),i.setTextureCube(t||Ln,n)}function setValueT2DArray1(e,t,i){const r=this.cache,n=i.allocateTextureUnit();r[0]!==n&&(e.uniform1i(this.addr,n),r[0]=n),i.setTexture2DArray(t||Cn,n)}function setValueV1fArray(e,t){e.uniform1fv(this.addr,t)}function setValueV2fArray(e,t){const i=flatten(t,this.size,2);e.uniform2fv(this.addr,i)}function setValueV3fArray(e,t){const i=flatten(t,this.size,3);e.uniform3fv(this.addr,i)}function setValueV4fArray(e,t){const i=flatten(t,this.size,4);e.uniform4fv(this.addr,i)}function setValueM2Array(e,t){const i=flatten(t,this.size,4);e.uniformMatrix2fv(this.addr,!1,i)}function setValueM3Array(e,t){const i=flatten(t,this.size,9);e.uniformMatrix3fv(this.addr,!1,i)}function setValueM4Array(e,t){const i=flatten(t,this.size,16);e.uniformMatrix4fv(this.addr,!1,i)}function setValueV1iArray(e,t){e.uniform1iv(this.addr,t)}function setValueV2iArray(e,t){e.uniform2iv(this.addr,t)}function setValueV3iArray(e,t){e.uniform3iv(this.addr,t)}function setValueV4iArray(e,t){e.uniform4iv(this.addr,t)}function setValueV1uiArray(e,t){e.uniform1uiv(this.addr,t)}function setValueV2uiArray(e,t){e.uniform2uiv(this.addr,t)}function setValueV3uiArray(e,t){e.uniform3uiv(this.addr,t)}function setValueV4uiArray(e,t){e.uniform4uiv(this.addr,t)}function setValueT1Array(e,t,i){const r=t.length,n=allocTexUnits(i,r);e.uniform1iv(this.addr,n);for(let s=0;s!==r;++s)i.setTexture2D(t[s]||An,n[s])}function setValueT3DArray(e,t,i){const r=t.length,n=allocTexUnits(i,r);e.uniform1iv(this.addr,n);for(let s=0;s!==r;++s)i.setTexture3D(t[s]||En,n[s])}function setValueT6Array(e,t,i){const r=t.length,n=allocTexUnits(i,r);e.uniform1iv(this.addr,n);for(let s=0;s!==r;++s)i.setTextureCube(t[s]||Ln,n[s])}function setValueT2DArrayArray(e,t,i){const r=t.length,n=allocTexUnits(i,r);e.uniform1iv(this.addr,n);for(let s=0;s!==r;++s)i.setTexture2DArray(t[s]||Cn,n[s])}class SingleUniform{constructor(e,t,i){this.id=e,this.addr=i,this.cache=[],this.setValue=function getSingularSetter(e){switch(e){case 5126:return setValueV1f;case 35664:return setValueV2f;case 35665:return setValueV3f;case 35666:return setValueV4f;case 35674:return setValueM2;case 35675:return setValueM3;case 35676:return setValueM4;case 5124:case 35670:return setValueV1i;case 35667:case 35671:return setValueV2i;case 35668:case 35672:return setValueV3i;case 35669:case 35673:return setValueV4i;case 5125:return setValueV1ui;case 36294:return setValueV2ui;case 36295:return setValueV3ui;case 36296:return setValueV4ui;case 35678:case 36198:case 36298:case 36306:case 35682:return setValueT1;case 35679:case 36299:case 36307:return setValueT3D1;case 35680:case 36300:case 36308:case 36293:return setValueT6;case 36289:case 36303:case 36311:case 36292:return setValueT2DArray1}}(t.type)}}class PureArrayUniform{constructor(e,t,i){this.id=e,this.addr=i,this.cache=[],this.size=t.size,this.setValue=function getPureArraySetter(e){switch(e){case 5126:return setValueV1fArray;case 35664:return setValueV2fArray;case 35665:return setValueV3fArray;case 35666:return setValueV4fArray;case 35674:return setValueM2Array;case 35675:return setValueM3Array;case 35676:return setValueM4Array;case 5124:case 35670:return setValueV1iArray;case 35667:case 35671:return setValueV2iArray;case 35668:case 35672:return setValueV3iArray;case 35669:case 35673:return setValueV4iArray;case 5125:return setValueV1uiArray;case 36294:return setValueV2uiArray;case 36295:return setValueV3uiArray;case 36296:return setValueV4uiArray;case 35678:case 36198:case 36298:case 36306:case 35682:return setValueT1Array;case 35679:case 36299:case 36307:return setValueT3DArray;case 35680:case 36300:case 36308:case 36293:return setValueT6Array;case 36289:case 36303:case 36311:case 36292:return setValueT2DArrayArray}}(t.type)}}class StructuredUniform{constructor(e){this.id=e,this.seq=[],this.map={}}setValue(e,t,i){const r=this.seq;for(let n=0,s=r.length;n!==s;++n){const s=r[n];s.setValue(e,t[s.id],i)}}}const Vn=/(\w+)(\])?(\[|\.)?/g;function addUniform(e,t){e.seq.push(t),e.map[t.id]=t}function parseUniform(e,t,i){const r=e.name,n=r.length;for(Vn.lastIndex=0;;){const s=Vn.exec(r),a=Vn.lastIndex;let o=s[1];const l="]"===s[2],c=s[3];if(l&&(o|=0),void 0===c||"["===c&&a+2===n){addUniform(i,void 0===c?new SingleUniform(o,e,t):new PureArrayUniform(o,e,t));break}{let e=i.map[o];void 0===e&&(e=new StructuredUniform(o),addUniform(i,e)),i=e}}}class WebGLUniforms{constructor(e,t){this.seq=[],this.map={};const i=e.getProgramParameter(t,35718);for(let r=0;r<i;++r){const i=e.getActiveUniform(t,r);parseUniform(i,e.getUniformLocation(t,i.name),this)}}setValue(e,t,i,r){const n=this.map[t];void 0!==n&&n.setValue(e,i,r)}setOptional(e,t,i){const r=t[i];void 0!==r&&this.setValue(e,i,r)}static upload(e,t,i,r){for(let n=0,s=t.length;n!==s;++n){const s=t[n],a=i[s.id];!1!==a.needsUpdate&&s.setValue(e,a.value,r)}}static seqWithValue(e,t){const i=[];for(let r=0,n=e.length;r!==n;++r){const n=e[r];n.id in t&&i.push(n)}return i}}function WebGLShader(e,t,i){const r=e.createShader(t);return e.shaderSource(r,i),e.compileShader(r),r}let Nn=0;function getShaderErrors(e,t,i){const r=e.getShaderParameter(t,35713),n=e.getShaderInfoLog(t).trim();if(r&&""===n)return"";const s=/ERROR: 0:(\d+)/.exec(n);if(s){const r=parseInt(s[1]);return i.toUpperCase()+"\n\n"+n+"\n\n"+function handleSource(e,t){const i=e.split("\n"),r=[],n=Math.max(t-6,0),s=Math.min(t+6,i.length);for(let a=n;a<s;a++){const e=a+1;r.push(`${e===t?">":" "} ${e}: ${i[a]}`)}return r.join("\n")}(e.getShaderSource(t),r)}return n}function getTexelEncodingFunction(e,t){const i=function getEncodingComponents(e){switch(e){case Dt:return["Linear","( value )"];case It:return["sRGB","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",e),["Linear","( value )"]}}(t);return"vec4 "+e+"( vec4 value ) { return LinearTo"+i[0]+i[1]+"; }"}function getToneMappingFunction(e,t){let i;switch(t){case $:i="Linear";break;case ee:i="Reinhard";break;case te:i="OptimizedCineon";break;case ie:i="ACESFilmic";break;case re:i="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t),i="Linear"}return"vec3 "+e+"( vec3 color ) { return "+i+"ToneMapping( color ); }"}function filterEmptyLine(e){return""!==e}function replaceLightNums(e,t){return e.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function replaceClippingPlaneNums(e,t){return e.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}const On=/^[ \t]*#include +<([\w\d./]+)>/gm;function resolveIncludes(e){return e.replace(On,includeReplacer)}function includeReplacer(e,t){const i=mn[t];if(void 0===i)throw new Error("Can not resolve #include <"+t+">");return resolveIncludes(i)}const zn=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,Fn=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function unrollLoops(e){return e.replace(Fn,loopReplacer).replace(zn,deprecatedLoopReplacer)}function deprecatedLoopReplacer(e,t,i,r){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),loopReplacer(e,t,i,r)}function loopReplacer(e,t,i,r){let n="";for(let s=parseInt(t);s<parseInt(i);s++)n+=r.replace(/\[\s*i\s*\]/g,"[ "+s+" ]").replace(/UNROLLED_LOOP_INDEX/g,s);return n}function generatePrecision(e){let t="precision "+e.precision+" float;\nprecision "+e.precision+" int;";return"highp"===e.precision?t+="\n#define HIGH_PRECISION":"mediump"===e.precision?t+="\n#define MEDIUM_PRECISION":"lowp"===e.precision&&(t+="\n#define LOW_PRECISION"),t}function WebGLProgram(e,t,i,r){const n=e.getContext(),s=i.defines;let a=i.vertexShader,o=i.fragmentShader;const l=function generateShadowMapTypeDefine(e){let t="SHADOWMAP_TYPE_BASIC";return e.shadowMapType===h?t="SHADOWMAP_TYPE_PCF":e.shadowMapType===u?t="SHADOWMAP_TYPE_PCF_SOFT":e.shadowMapType===d&&(t="SHADOWMAP_TYPE_VSM"),t}(i),c=function generateEnvMapTypeDefine(e){let t="ENVMAP_TYPE_CUBE";if(e.envMap)switch(e.envMapMode){case se:case ae:t="ENVMAP_TYPE_CUBE";break;case ce:t="ENVMAP_TYPE_CUBE_UV"}return t}(i),p=function generateEnvMapModeDefine(e){let t="ENVMAP_MODE_REFLECTION";e.envMap&&e.envMapMode===ae&&(t="ENVMAP_MODE_REFRACTION");return t}(i),m=function generateEnvMapBlendingDefine(e){let t="ENVMAP_BLENDING_NONE";if(e.envMap)switch(e.combine){case Z:t="ENVMAP_BLENDING_MULTIPLY";break;case J:t="ENVMAP_BLENDING_MIX";break;case K:t="ENVMAP_BLENDING_ADD"}return t}(i),f=function generateCubeUVSize(e){const t=e.envMapCubeUVHeight;if(null===t)return null;const i=Math.log2(t)-2,r=1/t;return{texelWidth:1/(3*Math.max(Math.pow(2,i),112)),texelHeight:r,maxMip:i}}(i),g=i.isWebGL2?"":function generateExtensions(e){return[e.extensionDerivatives||e.envMapCubeUVHeight||e.bumpMap||e.tangentSpaceNormalMap||e.clearcoatNormalMap||e.flatShading||"physical"===e.shaderID?"#extension GL_OES_standard_derivatives : enable":"",(e.extensionFragDepth||e.logarithmicDepthBuffer)&&e.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",e.extensionDrawBuffers&&e.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(e.extensionShaderTextureLOD||e.envMap||e.transmission)&&e.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(filterEmptyLine).join("\n")}(i),x=function generateDefines(e){const t=[];for(const i in e){const r=e[i];!1!==r&&t.push("#define "+i+" "+r)}return t.join("\n")}(s),y=n.createProgram();let _,b,M=i.glslVersion?"#version "+i.glslVersion+"\n":"";i.isRawShaderMaterial?(_=[x].filter(filterEmptyLine).join("\n"),_.length>0&&(_+="\n"),b=[g,x].filter(filterEmptyLine).join("\n"),b.length>0&&(b+="\n")):(_=[generatePrecision(i),"#define SHADER_NAME "+i.shaderName,x,i.instancing?"#define USE_INSTANCING":"",i.instancingColor?"#define USE_INSTANCING_COLOR":"",i.supportsVertexTextures?"#define VERTEX_TEXTURES":"",i.useFog&&i.fog?"#define USE_FOG":"",i.useFog&&i.fogExp2?"#define FOG_EXP2":"",i.map?"#define USE_MAP":"",i.envMap?"#define USE_ENVMAP":"",i.envMap?"#define "+p:"",i.lightMap?"#define USE_LIGHTMAP":"",i.aoMap?"#define USE_AOMAP":"",i.emissiveMap?"#define USE_EMISSIVEMAP":"",i.bumpMap?"#define USE_BUMPMAP":"",i.normalMap?"#define USE_NORMALMAP":"",i.normalMap&&i.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",i.normalMap&&i.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",i.clearcoatMap?"#define USE_CLEARCOATMAP":"",i.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",i.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",i.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",i.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",i.displacementMap&&i.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",i.specularMap?"#define USE_SPECULARMAP":"",i.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",i.specularColorMap?"#define USE_SPECULARCOLORMAP":"",i.roughnessMap?"#define USE_ROUGHNESSMAP":"",i.metalnessMap?"#define USE_METALNESSMAP":"",i.alphaMap?"#define USE_ALPHAMAP":"",i.transmission?"#define USE_TRANSMISSION":"",i.transmissionMap?"#define USE_TRANSMISSIONMAP":"",i.thicknessMap?"#define USE_THICKNESSMAP":"",i.sheenColorMap?"#define USE_SHEENCOLORMAP":"",i.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",i.vertexTangents?"#define USE_TANGENT":"",i.vertexColors?"#define USE_COLOR":"",i.vertexAlphas?"#define USE_COLOR_ALPHA":"",i.vertexUvs?"#define USE_UV":"",i.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",i.flatShading?"#define FLAT_SHADED":"",i.skinning?"#define USE_SKINNING":"",i.morphTargets?"#define USE_MORPHTARGETS":"",i.morphNormals&&!1===i.flatShading?"#define USE_MORPHNORMALS":"",i.morphColors&&i.isWebGL2?"#define USE_MORPHCOLORS":"",i.morphTargetsCount>0&&i.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",i.morphTargetsCount>0&&i.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+i.morphTextureStride:"",i.morphTargetsCount>0&&i.isWebGL2?"#define MORPHTARGETS_COUNT "+i.morphTargetsCount:"",i.doubleSided?"#define DOUBLE_SIDED":"",i.flipSided?"#define FLIP_SIDED":"",i.shadowMapEnabled?"#define USE_SHADOWMAP":"",i.shadowMapEnabled?"#define "+l:"",i.sizeAttenuation?"#define USE_SIZEATTENUATION":"",i.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",i.logarithmicDepthBuffer&&i.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","\tattribute vec4 color;","#elif defined( USE_COLOR )","\tattribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;","\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(filterEmptyLine).join("\n"),b=[g,generatePrecision(i),"#define SHADER_NAME "+i.shaderName,x,i.useFog&&i.fog?"#define USE_FOG":"",i.useFog&&i.fogExp2?"#define FOG_EXP2":"",i.map?"#define USE_MAP":"",i.matcap?"#define USE_MATCAP":"",i.envMap?"#define USE_ENVMAP":"",i.envMap?"#define "+c:"",i.envMap?"#define "+p:"",i.envMap?"#define "+m:"",f?"#define CUBEUV_TEXEL_WIDTH "+f.texelWidth:"",f?"#define CUBEUV_TEXEL_HEIGHT "+f.texelHeight:"",f?"#define CUBEUV_MAX_MIP "+f.maxMip+".0":"",i.lightMap?"#define USE_LIGHTMAP":"",i.aoMap?"#define USE_AOMAP":"",i.emissiveMap?"#define USE_EMISSIVEMAP":"",i.bumpMap?"#define USE_BUMPMAP":"",i.normalMap?"#define USE_NORMALMAP":"",i.normalMap&&i.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",i.normalMap&&i.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",i.clearcoat?"#define USE_CLEARCOAT":"",i.clearcoatMap?"#define USE_CLEARCOATMAP":"",i.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",i.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",i.iridescence?"#define USE_IRIDESCENCE":"",i.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",i.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",i.specularMap?"#define USE_SPECULARMAP":"",i.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",i.specularColorMap?"#define USE_SPECULARCOLORMAP":"",i.roughnessMap?"#define USE_ROUGHNESSMAP":"",i.metalnessMap?"#define USE_METALNESSMAP":"",i.alphaMap?"#define USE_ALPHAMAP":"",i.alphaTest?"#define USE_ALPHATEST":"",i.sheen?"#define USE_SHEEN":"",i.sheenColorMap?"#define USE_SHEENCOLORMAP":"",i.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",i.transmission?"#define USE_TRANSMISSION":"",i.transmissionMap?"#define USE_TRANSMISSIONMAP":"",i.thicknessMap?"#define USE_THICKNESSMAP":"",i.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",i.vertexTangents?"#define USE_TANGENT":"",i.vertexColors||i.instancingColor?"#define USE_COLOR":"",i.vertexAlphas?"#define USE_COLOR_ALPHA":"",i.vertexUvs?"#define USE_UV":"",i.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",i.gradientMap?"#define USE_GRADIENTMAP":"",i.flatShading?"#define FLAT_SHADED":"",i.doubleSided?"#define DOUBLE_SIDED":"",i.flipSided?"#define FLIP_SIDED":"",i.shadowMapEnabled?"#define USE_SHADOWMAP":"",i.shadowMapEnabled?"#define "+l:"",i.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",i.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",i.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",i.logarithmicDepthBuffer&&i.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",i.toneMapping!==Q?"#define TONE_MAPPING":"",i.toneMapping!==Q?mn.tonemapping_pars_fragment:"",i.toneMapping!==Q?getToneMappingFunction("toneMapping",i.toneMapping):"",i.dithering?"#define DITHERING":"",i.opaque?"#define OPAQUE":"",mn.encodings_pars_fragment,getTexelEncodingFunction("linearToOutputTexel",i.outputEncoding),i.useDepthPacking?"#define DEPTH_PACKING "+i.depthPacking:"","\n"].filter(filterEmptyLine).join("\n")),a=resolveIncludes(a),a=replaceLightNums(a,i),a=replaceClippingPlaneNums(a,i),o=resolveIncludes(o),o=replaceLightNums(o,i),o=replaceClippingPlaneNums(o,i),a=unrollLoops(a),o=unrollLoops(o),i.isWebGL2&&!0!==i.isRawShaderMaterial&&(M="#version 300 es\n",_=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+_,b=["#define varying in",i.glslVersion===pi?"":"layout(location = 0) out highp vec4 pc_fragColor;",i.glslVersion===pi?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+b);const S=M+b+o,w=WebGLShader(n,35633,M+_+a),T=WebGLShader(n,35632,S);if(n.attachShader(y,w),n.attachShader(y,T),void 0!==i.index0AttributeName?n.bindAttribLocation(y,0,i.index0AttributeName):!0===i.morphTargets&&n.bindAttribLocation(y,0,"position"),n.linkProgram(y),e.debug.checkShaderErrors){const e=n.getProgramInfoLog(y).trim(),t=n.getShaderInfoLog(w).trim(),i=n.getShaderInfoLog(T).trim();let r=!0,s=!0;if(!1===n.getProgramParameter(y,35714)){r=!1;const t=getShaderErrors(n,w,"vertex"),i=getShaderErrors(n,T,"fragment");console.error("THREE.WebGLProgram: Shader Error "+n.getError()+" - VALIDATE_STATUS "+n.getProgramParameter(y,35715)+"\n\nProgram Info Log: "+e+"\n"+t+"\n"+i)}else""!==e?console.warn("THREE.WebGLProgram: Program Info Log:",e):""!==t&&""!==i||(s=!1);s&&(this.diagnostics={runnable:r,programLog:e,vertexShader:{log:t,prefix:_},fragmentShader:{log:i,prefix:b}})}let A,C;return n.deleteShader(w),n.deleteShader(T),this.getUniforms=function(){return void 0===A&&(A=new WebGLUniforms(n,y)),A},this.getAttributes=function(){return void 0===C&&(C=function fetchAttributeLocations(e,t){const i={},r=e.getProgramParameter(t,35721);for(let n=0;n<r;n++){const r=e.getActiveAttrib(t,n),s=r.name;let a=1;35674===r.type&&(a=2),35675===r.type&&(a=3),35676===r.type&&(a=4),i[s]={type:r.type,location:e.getAttribLocation(t,s),locationSize:a}}return i}(n,y)),C},this.destroy=function(){r.releaseStatesOfProgram(this),n.deleteProgram(y),this.program=void 0},this.name=i.shaderName,this.id=Nn++,this.cacheKey=t,this.usedTimes=1,this.program=y,this.vertexShader=w,this.fragmentShader=T,this}let Gn=0;class WebGLShaderCache{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const t=e.vertexShader,i=e.fragmentShader,r=this._getShaderStage(t),n=this._getShaderStage(i),s=this._getShaderCacheForMaterial(e);return!1===s.has(r)&&(s.add(r),r.usedTimes++),!1===s.has(n)&&(s.add(n),n.usedTimes++),this}remove(e){const t=this.materialCache.get(e);for(const i of t)i.usedTimes--,0===i.usedTimes&&this.shaderCache.delete(i.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const t=this.materialCache;return!1===t.has(e)&&t.set(e,new Set),t.get(e)}_getShaderStage(e){const t=this.shaderCache;if(!1===t.has(e)){const i=new WebGLShaderStage(e);t.set(e,i)}return t.get(e)}}class WebGLShaderStage{constructor(e){this.id=Gn++,this.code=e,this.usedTimes=0}}function WebGLPrograms(e,t,i,r,n,s,a){const o=new Layers,l=new WebGLShaderCache,c=[],h=n.isWebGL2,u=n.logarithmicDepthBuffer,d=n.vertexTextures;let p=n.precision;const g={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};return{getParameters:function getParameters(s,o,c,x,y){const b=x.fog,M=y.geometry,S=s.isMeshStandardMaterial?x.environment:null,w=(s.isMeshStandardMaterial?i:t).get(s.envMap||S),T=w&&w.mapping===ce?w.image.height:null,A=g[s.type];null!==s.precision&&(p=n.getMaxPrecision(s.precision),p!==s.precision&&console.warn("THREE.WebGLProgram.getParameters:",s.precision,"not supported, using",p,"instead."));const C=M.morphAttributes.position||M.morphAttributes.normal||M.morphAttributes.color,E=void 0!==C?C.length:0;let L,P,R,D,I=0;if(void 0!==M.morphAttributes.position&&(I=1),void 0!==M.morphAttributes.normal&&(I=2),void 0!==M.morphAttributes.color&&(I=3),A){const e=gn[A];L=e.vertexShader,P=e.fragmentShader}else L=s.vertexShader,P=s.fragmentShader,l.update(s),R=l.getVertexShaderID(s),D=l.getFragmentShaderID(s);const B=e.getRenderTarget(),V=s.alphaTest>0,N=s.clearcoat>0,O=s.iridescence>0;return{isWebGL2:h,shaderID:A,shaderName:s.type,vertexShader:L,fragmentShader:P,defines:s.defines,customVertexShaderID:R,customFragmentShaderID:D,isRawShaderMaterial:!0===s.isRawShaderMaterial,glslVersion:s.glslVersion,precision:p,instancing:!0===y.isInstancedMesh,instancingColor:!0===y.isInstancedMesh&&null!==y.instanceColor,supportsVertexTextures:d,outputEncoding:null===B?e.outputEncoding:!0===B.isXRRenderTarget?B.texture.encoding:Dt,map:!!s.map,matcap:!!s.matcap,envMap:!!w,envMapMode:w&&w.mapping,envMapCubeUVHeight:T,lightMap:!!s.lightMap,aoMap:!!s.aoMap,emissiveMap:!!s.emissiveMap,bumpMap:!!s.bumpMap,normalMap:!!s.normalMap,objectSpaceNormalMap:s.normalMapType===Ot,tangentSpaceNormalMap:s.normalMapType===Nt,decodeVideoTexture:!!s.map&&!0===s.map.isVideoTexture&&s.map.encoding===It,clearcoat:N,clearcoatMap:N&&!!s.clearcoatMap,clearcoatRoughnessMap:N&&!!s.clearcoatRoughnessMap,clearcoatNormalMap:N&&!!s.clearcoatNormalMap,iridescence:O,iridescenceMap:O&&!!s.iridescenceMap,iridescenceThicknessMap:O&&!!s.iridescenceThicknessMap,displacementMap:!!s.displacementMap,roughnessMap:!!s.roughnessMap,metalnessMap:!!s.metalnessMap,specularMap:!!s.specularMap,specularIntensityMap:!!s.specularIntensityMap,specularColorMap:!!s.specularColorMap,opaque:!1===s.transparent&&s.blending===_,alphaMap:!!s.alphaMap,alphaTest:V,gradientMap:!!s.gradientMap,sheen:s.sheen>0,sheenColorMap:!!s.sheenColorMap,sheenRoughnessMap:!!s.sheenRoughnessMap,transmission:s.transmission>0,transmissionMap:!!s.transmissionMap,thicknessMap:!!s.thicknessMap,combine:s.combine,vertexTangents:!!s.normalMap&&!!M.attributes.tangent,vertexColors:s.vertexColors,vertexAlphas:!0===s.vertexColors&&!!M.attributes.color&&4===M.attributes.color.itemSize,vertexUvs:!!s.map||!!s.bumpMap||!!s.normalMap||!!s.specularMap||!!s.alphaMap||!!s.emissiveMap||!!s.roughnessMap||!!s.metalnessMap||!!s.clearcoatMap||!!s.clearcoatRoughnessMap||!!s.clearcoatNormalMap||!!s.iridescenceMap||!!s.iridescenceThicknessMap||!!s.displacementMap||!!s.transmissionMap||!!s.thicknessMap||!!s.specularIntensityMap||!!s.specularColorMap||!!s.sheenColorMap||!!s.sheenRoughnessMap,uvsVertexOnly:!(s.map||s.bumpMap||s.normalMap||s.specularMap||s.alphaMap||s.emissiveMap||s.roughnessMap||s.metalnessMap||s.clearcoatNormalMap||s.iridescenceMap||s.iridescenceThicknessMap||s.transmission>0||s.transmissionMap||s.thicknessMap||s.specularIntensityMap||s.specularColorMap||s.sheen>0||s.sheenColorMap||s.sheenRoughnessMap)&&!!s.displacementMap,fog:!!b,useFog:!0===s.fog,fogExp2:b&&b.isFogExp2,flatShading:!!s.flatShading,sizeAttenuation:s.sizeAttenuation,logarithmicDepthBuffer:u,skinning:!0===y.isSkinnedMesh,morphTargets:void 0!==M.morphAttributes.position,morphNormals:void 0!==M.morphAttributes.normal,morphColors:void 0!==M.morphAttributes.color,morphTargetsCount:E,morphTextureStride:I,numDirLights:o.directional.length,numPointLights:o.point.length,numSpotLights:o.spot.length,numRectAreaLights:o.rectArea.length,numHemiLights:o.hemi.length,numDirLightShadows:o.directionalShadowMap.length,numPointLightShadows:o.pointShadowMap.length,numSpotLightShadows:o.spotShadowMap.length,numClippingPlanes:a.numPlanes,numClipIntersection:a.numIntersection,dithering:s.dithering,shadowMapEnabled:e.shadowMap.enabled&&c.length>0,shadowMapType:e.shadowMap.type,toneMapping:s.toneMapped?e.toneMapping:Q,physicallyCorrectLights:e.physicallyCorrectLights,premultipliedAlpha:s.premultipliedAlpha,doubleSided:s.side===f,flipSided:s.side===m,useDepthPacking:!!s.depthPacking,depthPacking:s.depthPacking||0,index0AttributeName:s.index0AttributeName,extensionDerivatives:s.extensions&&s.extensions.derivatives,extensionFragDepth:s.extensions&&s.extensions.fragDepth,extensionDrawBuffers:s.extensions&&s.extensions.drawBuffers,extensionShaderTextureLOD:s.extensions&&s.extensions.shaderTextureLOD,rendererExtensionFragDepth:h||r.has("EXT_frag_depth"),rendererExtensionDrawBuffers:h||r.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:h||r.has("EXT_shader_texture_lod"),customProgramCacheKey:s.customProgramCacheKey()}},getProgramCacheKey:function getProgramCacheKey(t){const i=[];if(t.shaderID?i.push(t.shaderID):(i.push(t.customVertexShaderID),i.push(t.customFragmentShaderID)),void 0!==t.defines)for(const e in t.defines)i.push(e),i.push(t.defines[e]);return!1===t.isRawShaderMaterial&&(!function getProgramCacheKeyParameters(e,t){e.push(t.precision),e.push(t.outputEncoding),e.push(t.envMapMode),e.push(t.envMapCubeUVHeight),e.push(t.combine),e.push(t.vertexUvs),e.push(t.fogExp2),e.push(t.sizeAttenuation),e.push(t.morphTargetsCount),e.push(t.morphAttributeCount),e.push(t.numDirLights),e.push(t.numPointLights),e.push(t.numSpotLights),e.push(t.numHemiLights),e.push(t.numRectAreaLights),e.push(t.numDirLightShadows),e.push(t.numPointLightShadows),e.push(t.numSpotLightShadows),e.push(t.shadowMapType),e.push(t.toneMapping),e.push(t.numClippingPlanes),e.push(t.numClipIntersection),e.push(t.depthPacking)}(i,t),function getProgramCacheKeyBooleans(e,t){o.disableAll(),t.isWebGL2&&o.enable(0);t.supportsVertexTextures&&o.enable(1);t.instancing&&o.enable(2);t.instancingColor&&o.enable(3);t.map&&o.enable(4);t.matcap&&o.enable(5);t.envMap&&o.enable(6);t.lightMap&&o.enable(7);t.aoMap&&o.enable(8);t.emissiveMap&&o.enable(9);t.bumpMap&&o.enable(10);t.normalMap&&o.enable(11);t.objectSpaceNormalMap&&o.enable(12);t.tangentSpaceNormalMap&&o.enable(13);t.clearcoat&&o.enable(14);t.clearcoatMap&&o.enable(15);t.clearcoatRoughnessMap&&o.enable(16);t.clearcoatNormalMap&&o.enable(17);t.iridescence&&o.enable(18);t.iridescenceMap&&o.enable(19);t.iridescenceThicknessMap&&o.enable(20);t.displacementMap&&o.enable(21);t.specularMap&&o.enable(22);t.roughnessMap&&o.enable(23);t.metalnessMap&&o.enable(24);t.gradientMap&&o.enable(25);t.alphaMap&&o.enable(26);t.alphaTest&&o.enable(27);t.vertexColors&&o.enable(28);t.vertexAlphas&&o.enable(29);t.vertexUvs&&o.enable(30);t.vertexTangents&&o.enable(31);t.uvsVertexOnly&&o.enable(32);t.fog&&o.enable(33);e.push(o.mask),o.disableAll(),t.useFog&&o.enable(0);t.flatShading&&o.enable(1);t.logarithmicDepthBuffer&&o.enable(2);t.skinning&&o.enable(3);t.morphTargets&&o.enable(4);t.morphNormals&&o.enable(5);t.morphColors&&o.enable(6);t.premultipliedAlpha&&o.enable(7);t.shadowMapEnabled&&o.enable(8);t.physicallyCorrectLights&&o.enable(9);t.doubleSided&&o.enable(10);t.flipSided&&o.enable(11);t.useDepthPacking&&o.enable(12);t.dithering&&o.enable(13);t.specularIntensityMap&&o.enable(14);t.specularColorMap&&o.enable(15);t.transmission&&o.enable(16);t.transmissionMap&&o.enable(17);t.thicknessMap&&o.enable(18);t.sheen&&o.enable(19);t.sheenColorMap&&o.enable(20);t.sheenRoughnessMap&&o.enable(21);t.decodeVideoTexture&&o.enable(22);t.opaque&&o.enable(23);e.push(o.mask)}(i,t),i.push(e.outputEncoding)),i.push(t.customProgramCacheKey),i.join()},getUniforms:function getUniforms(e){const t=g[e.type];let i;if(t){const e=gn[t];i=on.clone(e.uniforms)}else i=e.uniforms;return i},acquireProgram:function acquireProgram(t,i){let r;for(let e=0,n=c.length;e<n;e++){const t=c[e];if(t.cacheKey===i){r=t,++r.usedTimes;break}}return void 0===r&&(r=new WebGLProgram(e,i,t,s),c.push(r)),r},releaseProgram:function releaseProgram(e){if(0===--e.usedTimes){const t=c.indexOf(e);c[t]=c[c.length-1],c.pop(),e.destroy()}},releaseShaderCache:function releaseShaderCache(e){l.remove(e)},programs:c,dispose:function dispose(){l.dispose()}}}function WebGLProperties(){let e=new WeakMap;return{get:function get(t){let i=e.get(t);return void 0===i&&(i={},e.set(t,i)),i},remove:function remove(t){e.delete(t)},update:function update(t,i,r){e.get(t)[i]=r},dispose:function dispose(){e=new WeakMap}}}function painterSortStable(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.material.id!==t.material.id?e.material.id-t.material.id:e.z!==t.z?e.z-t.z:e.id-t.id}function reversePainterSortStable(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.z!==t.z?t.z-e.z:e.id-t.id}function WebGLRenderList(){const e=[];let t=0;const i=[],r=[],n=[];function getNextRenderItem(i,r,n,s,a,o){let l=e[t];return void 0===l?(l={id:i.id,object:i,geometry:r,material:n,groupOrder:s,renderOrder:i.renderOrder,z:a,group:o},e[t]=l):(l.id=i.id,l.object=i,l.geometry=r,l.material=n,l.groupOrder=s,l.renderOrder=i.renderOrder,l.z=a,l.group=o),t++,l}return{opaque:i,transmissive:r,transparent:n,init:function init(){t=0,i.length=0,r.length=0,n.length=0},push:function push(e,t,s,a,o,l){const c=getNextRenderItem(e,t,s,a,o,l);s.transmission>0?r.push(c):!0===s.transparent?n.push(c):i.push(c)},unshift:function unshift(e,t,s,a,o,l){const c=getNextRenderItem(e,t,s,a,o,l);s.transmission>0?r.unshift(c):!0===s.transparent?n.unshift(c):i.unshift(c)},finish:function finish(){for(let i=t,r=e.length;i<r;i++){const t=e[i];if(null===t.id)break;t.id=null,t.object=null,t.geometry=null,t.material=null,t.group=null}},sort:function sort(e,t){i.length>1&&i.sort(e||painterSortStable),r.length>1&&r.sort(t||reversePainterSortStable),n.length>1&&n.sort(t||reversePainterSortStable)}}}function WebGLRenderLists(){let e=new WeakMap;return{get:function get(t,i){let r;return!1===e.has(t)?(r=new WebGLRenderList,e.set(t,[r])):i>=e.get(t).length?(r=new WebGLRenderList,e.get(t).push(r)):r=e.get(t)[i],r},dispose:function dispose(){e=new WeakMap}}}function UniformsCache(){const e={};return{get:function(t){if(void 0!==e[t.id])return e[t.id];let i;switch(t.type){case"DirectionalLight":i={direction:new Vector3,color:new Color};break;case"SpotLight":i={position:new Vector3,direction:new Vector3,color:new Color,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":i={position:new Vector3,color:new Color,distance:0,decay:0};break;case"HemisphereLight":i={direction:new Vector3,skyColor:new Color,groundColor:new Color};break;case"RectAreaLight":i={color:new Color,position:new Vector3,halfWidth:new Vector3,halfHeight:new Vector3}}return e[t.id]=i,i}}}let Un=0;function shadowCastingLightsFirst(e,t){return(t.castShadow?1:0)-(e.castShadow?1:0)}function WebGLLights(e,t){const i=new UniformsCache,r=function ShadowUniformsCache(){const e={};return{get:function(t){if(void 0!==e[t.id])return e[t.id];let i;switch(t.type){case"DirectionalLight":case"SpotLight":i={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2};break;case"PointLight":i={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2,shadowCameraNear:1,shadowCameraFar:1e3}}return e[t.id]=i,i}}}(),n={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let l=0;l<9;l++)n.probe.push(new Vector3);const s=new Vector3,a=new Matrix4,o=new Matrix4;return{setup:function setup(s,a){let o=0,l=0,c=0;for(let e=0;e<9;e++)n.probe[e].set(0,0,0);let h=0,u=0,d=0,p=0,m=0,f=0,g=0,x=0;s.sort(shadowCastingLightsFirst);const y=!0!==a?Math.PI:1;for(let e=0,t=s.length;e<t;e++){const t=s[e],a=t.color,_=t.intensity,b=t.distance,M=t.shadow&&t.shadow.map?t.shadow.map.texture:null;if(t.isAmbientLight)o+=a.r*_*y,l+=a.g*_*y,c+=a.b*_*y;else if(t.isLightProbe)for(let e=0;e<9;e++)n.probe[e].addScaledVector(t.sh.coefficients[e],_);else if(t.isDirectionalLight){const e=i.get(t);if(e.color.copy(t.color).multiplyScalar(t.intensity*y),t.castShadow){const e=t.shadow,i=r.get(t);i.shadowBias=e.bias,i.shadowNormalBias=e.normalBias,i.shadowRadius=e.radius,i.shadowMapSize=e.mapSize,n.directionalShadow[h]=i,n.directionalShadowMap[h]=M,n.directionalShadowMatrix[h]=t.shadow.matrix,f++}n.directional[h]=e,h++}else if(t.isSpotLight){const e=i.get(t);if(e.position.setFromMatrixPosition(t.matrixWorld),e.color.copy(a).multiplyScalar(_*y),e.distance=b,e.coneCos=Math.cos(t.angle),e.penumbraCos=Math.cos(t.angle*(1-t.penumbra)),e.decay=t.decay,t.castShadow){const e=t.shadow,i=r.get(t);i.shadowBias=e.bias,i.shadowNormalBias=e.normalBias,i.shadowRadius=e.radius,i.shadowMapSize=e.mapSize,n.spotShadow[d]=i,n.spotShadowMap[d]=M,n.spotShadowMatrix[d]=t.shadow.matrix,x++}n.spot[d]=e,d++}else if(t.isRectAreaLight){const e=i.get(t);e.color.copy(a).multiplyScalar(_),e.halfWidth.set(.5*t.width,0,0),e.halfHeight.set(0,.5*t.height,0),n.rectArea[p]=e,p++}else if(t.isPointLight){const e=i.get(t);if(e.color.copy(t.color).multiplyScalar(t.intensity*y),e.distance=t.distance,e.decay=t.decay,t.castShadow){const e=t.shadow,i=r.get(t);i.shadowBias=e.bias,i.shadowNormalBias=e.normalBias,i.shadowRadius=e.radius,i.shadowMapSize=e.mapSize,i.shadowCameraNear=e.camera.near,i.shadowCameraFar=e.camera.far,n.pointShadow[u]=i,n.pointShadowMap[u]=M,n.pointShadowMatrix[u]=t.shadow.matrix,g++}n.point[u]=e,u++}else if(t.isHemisphereLight){const e=i.get(t);e.skyColor.copy(t.color).multiplyScalar(_*y),e.groundColor.copy(t.groundColor).multiplyScalar(_*y),n.hemi[m]=e,m++}}p>0&&(t.isWebGL2||!0===e.has("OES_texture_float_linear")?(n.rectAreaLTC1=fn.LTC_FLOAT_1,n.rectAreaLTC2=fn.LTC_FLOAT_2):!0===e.has("OES_texture_half_float_linear")?(n.rectAreaLTC1=fn.LTC_HALF_1,n.rectAreaLTC2=fn.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),n.ambient[0]=o,n.ambient[1]=l,n.ambient[2]=c;const _=n.hash;_.directionalLength===h&&_.pointLength===u&&_.spotLength===d&&_.rectAreaLength===p&&_.hemiLength===m&&_.numDirectionalShadows===f&&_.numPointShadows===g&&_.numSpotShadows===x||(n.directional.length=h,n.spot.length=d,n.rectArea.length=p,n.point.length=u,n.hemi.length=m,n.directionalShadow.length=f,n.directionalShadowMap.length=f,n.pointShadow.length=g,n.pointShadowMap.length=g,n.spotShadow.length=x,n.spotShadowMap.length=x,n.directionalShadowMatrix.length=f,n.pointShadowMatrix.length=g,n.spotShadowMatrix.length=x,_.directionalLength=h,_.pointLength=u,_.spotLength=d,_.rectAreaLength=p,_.hemiLength=m,_.numDirectionalShadows=f,_.numPointShadows=g,_.numSpotShadows=x,n.version=Un++)},setupView:function setupView(e,t){let i=0,r=0,l=0,c=0,h=0;const u=t.matrixWorldInverse;for(let d=0,p=e.length;d<p;d++){const t=e[d];if(t.isDirectionalLight){const e=n.directional[i];e.direction.setFromMatrixPosition(t.matrixWorld),s.setFromMatrixPosition(t.target.matrixWorld),e.direction.sub(s),e.direction.transformDirection(u),i++}else if(t.isSpotLight){const e=n.spot[l];e.position.setFromMatrixPosition(t.matrixWorld),e.position.applyMatrix4(u),e.direction.setFromMatrixPosition(t.matrixWorld),s.setFromMatrixPosition(t.target.matrixWorld),e.direction.sub(s),e.direction.transformDirection(u),l++}else if(t.isRectAreaLight){const e=n.rectArea[c];e.position.setFromMatrixPosition(t.matrixWorld),e.position.applyMatrix4(u),o.identity(),a.copy(t.matrixWorld),a.premultiply(u),o.extractRotation(a),e.halfWidth.set(.5*t.width,0,0),e.halfHeight.set(0,.5*t.height,0),e.halfWidth.applyMatrix4(o),e.halfHeight.applyMatrix4(o),c++}else if(t.isPointLight){const e=n.point[r];e.position.setFromMatrixPosition(t.matrixWorld),e.position.applyMatrix4(u),r++}else if(t.isHemisphereLight){const e=n.hemi[h];e.direction.setFromMatrixPosition(t.matrixWorld),e.direction.transformDirection(u),h++}}},state:n}}function WebGLRenderState(e,t){const i=new WebGLLights(e,t),r=[],n=[];return{init:function init(){r.length=0,n.length=0},state:{lightsArray:r,shadowsArray:n,lights:i},setupLights:function setupLights(e){i.setup(r,e)},setupLightsView:function setupLightsView(e){i.setupView(r,e)},pushLight:function pushLight(e){r.push(e)},pushShadow:function pushShadow(e){n.push(e)}}}function WebGLRenderStates(e,t){let i=new WeakMap;return{get:function get(r,n=0){let s;return!1===i.has(r)?(s=new WebGLRenderState(e,t),i.set(r,[s])):n>=i.get(r).length?(s=new WebGLRenderState(e,t),i.get(r).push(s)):s=i.get(r)[n],s},dispose:function dispose(){i=new WeakMap}}}class MeshDepthMaterial extends Material{constructor(e){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=Bt,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}class MeshDistanceMaterial extends Material{constructor(e){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.referencePosition=new Vector3,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.referencePosition.copy(e.referencePosition),this.nearDistance=e.nearDistance,this.farDistance=e.farDistance,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}const kn="void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",Wn="uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";function WebGLShadowMap(e,t,i){let r=new Frustum;const n=new Vector2,s=new Vector2,a=new Vector4,o=new MeshDepthMaterial({depthPacking:Vt}),l=new MeshDistanceMaterial,c={},u=i.maxTextureSize,g={0:m,1:p,2:f},x=new ShaderMaterial({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Vector2},radius:{value:4}},vertexShader:kn,fragmentShader:Wn}),_=x.clone();_.defines.HORIZONTAL_PASS=1;const b=new BufferGeometry;b.setAttribute("position",new BufferAttribute(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const M=new Mesh(b,x),S=this;function VSMPass(i,r){const s=t.update(M);x.defines.VSM_SAMPLES!==i.blurSamples&&(x.defines.VSM_SAMPLES=i.blurSamples,_.defines.VSM_SAMPLES=i.blurSamples,x.needsUpdate=!0,_.needsUpdate=!0),null===i.mapPass&&(i.mapPass=new WebGLRenderTarget(n.x,n.y)),x.uniforms.shadow_pass.value=i.map.texture,x.uniforms.resolution.value=i.mapSize,x.uniforms.radius.value=i.radius,e.setRenderTarget(i.mapPass),e.clear(),e.renderBufferDirect(r,null,s,x,M,null),_.uniforms.shadow_pass.value=i.mapPass.texture,_.uniforms.resolution.value=i.mapSize,_.uniforms.radius.value=i.radius,e.setRenderTarget(i.map),e.clear(),e.renderBufferDirect(r,null,s,_,M,null)}function getDepthMaterial(t,i,r,n,s,a){let h=null;const u=!0===r.isPointLight?t.customDistanceMaterial:t.customDepthMaterial;if(h=void 0!==u?u:!0===r.isPointLight?l:o,e.localClippingEnabled&&!0===i.clipShadows&&Array.isArray(i.clippingPlanes)&&0!==i.clippingPlanes.length||i.displacementMap&&0!==i.displacementScale||i.alphaMap&&i.alphaTest>0){const e=h.uuid,t=i.uuid;let r=c[e];void 0===r&&(r={},c[e]=r);let n=r[t];void 0===n&&(n=h.clone(),r[t]=n),h=n}return h.visible=i.visible,h.wireframe=i.wireframe,h.side=a===d?null!==i.shadowSide?i.shadowSide:i.side:null!==i.shadowSide?i.shadowSide:g[i.side],h.alphaMap=i.alphaMap,h.alphaTest=i.alphaTest,h.clipShadows=i.clipShadows,h.clippingPlanes=i.clippingPlanes,h.clipIntersection=i.clipIntersection,h.displacementMap=i.displacementMap,h.displacementScale=i.displacementScale,h.displacementBias=i.displacementBias,h.wireframeLinewidth=i.wireframeLinewidth,h.linewidth=i.linewidth,!0===r.isPointLight&&!0===h.isMeshDistanceMaterial&&(h.referencePosition.setFromMatrixPosition(r.matrixWorld),h.nearDistance=n,h.farDistance=s),h}function renderObject(i,n,s,a,o){if(!1===i.visible)return;if(i.layers.test(n.layers)&&(i.isMesh||i.isLine||i.isPoints)&&(i.castShadow||i.receiveShadow&&o===d)&&(!i.frustumCulled||r.intersectsObject(i))){i.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse,i.matrixWorld);const r=t.update(i),n=i.material;if(Array.isArray(n)){const t=r.groups;for(let l=0,c=t.length;l<c;l++){const c=t[l],h=n[c.materialIndex];if(h&&h.visible){const t=getDepthMaterial(i,h,a,s.near,s.far,o);e.renderBufferDirect(s,null,r,t,i,c)}}}else if(n.visible){const t=getDepthMaterial(i,n,a,s.near,s.far,o);e.renderBufferDirect(s,null,r,t,i,null)}}const l=i.children;for(let e=0,t=l.length;e<t;e++)renderObject(l[e],n,s,a,o)}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=h,this.render=function(t,i,o){if(!1===S.enabled)return;if(!1===S.autoUpdate&&!1===S.needsUpdate)return;if(0===t.length)return;const l=e.getRenderTarget(),c=e.getActiveCubeFace(),h=e.getActiveMipmapLevel(),p=e.state;p.setBlending(y),p.buffers.color.setClear(1,1,1,1),p.buffers.depth.setTest(!0),p.setScissorTest(!1);for(let m=0,f=t.length;m<f;m++){const l=t[m],c=l.shadow;if(void 0===c){console.warn("THREE.WebGLShadowMap:",l,"has no shadow.");continue}if(!1===c.autoUpdate&&!1===c.needsUpdate)continue;n.copy(c.mapSize);const h=c.getFrameExtents();if(n.multiply(h),s.copy(c.mapSize),(n.x>u||n.y>u)&&(n.x>u&&(s.x=Math.floor(u/h.x),n.x=s.x*h.x,c.mapSize.x=s.x),n.y>u&&(s.y=Math.floor(u/h.y),n.y=s.y*h.y,c.mapSize.y=s.y)),null===c.map){const e=this.type!==d?{minFilter:pe,magFilter:pe}:{};c.map=new WebGLRenderTarget(n.x,n.y,e),c.map.texture.name=l.name+".shadowMap",c.camera.updateProjectionMatrix()}e.setRenderTarget(c.map),e.clear();const f=c.getViewportCount();for(let e=0;e<f;e++){const t=c.getViewport(e);a.set(s.x*t.x,s.y*t.y,s.x*t.z,s.y*t.w),p.viewport(a),c.updateMatrices(l,e),r=c.getFrustum(),renderObject(i,o,c.camera,l,this.type)}!0!==c.isPointLightShadow&&this.type===d&&VSMPass(c,o),c.needsUpdate=!1}S.needsUpdate=!1,e.setRenderTarget(l,c,h)}}function WebGLState(e,t,i){const r=i.isWebGL2;const n=new function ColorBuffer(){let t=!1;const i=new Vector4;let r=null;const n=new Vector4(0,0,0,0);return{setMask:function(i){r===i||t||(e.colorMask(i,i,i,i),r=i)},setLocked:function(e){t=e},setClear:function(t,r,s,a,o){!0===o&&(t*=a,r*=a,s*=a),i.set(t,r,s,a),!1===n.equals(i)&&(e.clearColor(t,r,s,a),n.copy(i))},reset:function(){t=!1,r=null,n.set(-1,0,0,0)}}},l=new function DepthBuffer(){let t=!1,i=null,r=null,n=null;return{setTest:function(e){e?enable(2929):disable(2929)},setMask:function(r){i===r||t||(e.depthMask(r),i=r)},setFunc:function(t){if(r!==t){if(t)switch(t){case U:e.depthFunc(512);break;case k:e.depthFunc(519);break;case W:e.depthFunc(513);break;case H:e.depthFunc(515);break;case j:e.depthFunc(514);break;case q:e.depthFunc(518);break;case X:e.depthFunc(516);break;case Y:e.depthFunc(517);break;default:e.depthFunc(515)}else e.depthFunc(515);r=t}},setLocked:function(e){t=e},setClear:function(t){n!==t&&(e.clearDepth(t),n=t)},reset:function(){t=!1,i=null,r=null,n=null}}},c=new function StencilBuffer(){let t=!1,i=null,r=null,n=null,s=null,a=null,o=null,l=null,c=null;return{setTest:function(e){t||(e?enable(2960):disable(2960))},setMask:function(r){i===r||t||(e.stencilMask(r),i=r)},setFunc:function(t,i,a){r===t&&n===i&&s===a||(e.stencilFunc(t,i,a),r=t,n=i,s=a)},setOp:function(t,i,r){a===t&&o===i&&l===r||(e.stencilOp(t,i,r),a=t,o=i,l=r)},setLocked:function(e){t=e},setClear:function(t){c!==t&&(e.clearStencil(t),c=t)},reset:function(){t=!1,i=null,r=null,n=null,s=null,a=null,o=null,l=null,c=null}}},h=new WeakMap,u=new WeakMap;let d={},p={},g=new WeakMap,x=[],Z=null,J=!1,K=null,Q=null,$=null,ee=null,te=null,ie=null,re=null,ne=!1,se=null,ae=null,oe=null,le=null,ce=null;const he=e.getParameter(35661);let ue=!1,de=0;const pe=e.getParameter(7938);-1!==pe.indexOf("WebGL")?(de=parseFloat(/^WebGL (\d)/.exec(pe)[1]),ue=de>=1):-1!==pe.indexOf("OpenGL ES")&&(de=parseFloat(/^OpenGL ES (\d)/.exec(pe)[1]),ue=de>=2);let me=null,fe={};const ge=e.getParameter(3088),ve=e.getParameter(2978),xe=(new Vector4).fromArray(ge),ye=(new Vector4).fromArray(ve);function createTexture(t,i,r){const n=new Uint8Array(4),s=e.createTexture();e.bindTexture(t,s),e.texParameteri(t,10241,9728),e.texParameteri(t,10240,9728);for(let a=0;a<r;a++)e.texImage2D(i+a,0,6408,1,1,0,6408,5121,n);return s}const _e={};function enable(t){!0!==d[t]&&(e.enable(t),d[t]=!0)}function disable(t){!1!==d[t]&&(e.disable(t),d[t]=!1)}_e[3553]=createTexture(3553,3553,1),_e[34067]=createTexture(34067,34069,6),n.setClear(0,0,0,1),l.setClear(1),c.setClear(0),enable(2929),l.setFunc(H),setFlipSided(!1),setCullFace(a),enable(2884),setBlending(y);const be={[T]:32774,[A]:32778,[C]:32779};if(r)be[E]=32775,be[L]=32776;else{const e=t.get("EXT_blend_minmax");null!==e&&(be[E]=e.MIN_EXT,be[L]=e.MAX_EXT)}const Me={[P]:0,[R]:1,[D]:768,[B]:770,[G]:776,[z]:774,[N]:772,[I]:769,[V]:771,[F]:775,[O]:773};function setBlending(t,i,r,n,s,a,o,l){if(t!==y){if(!1===J&&(enable(3042),J=!0),t===w)s=s||i,a=a||r,o=o||n,i===Q&&s===te||(e.blendEquationSeparate(be[i],be[s]),Q=i,te=s),r===$&&n===ee&&a===ie&&o===re||(e.blendFuncSeparate(Me[r],Me[n],Me[a],Me[o]),$=r,ee=n,ie=a,re=o),K=t,ne=null;else if(t!==K||l!==ne){if(Q===T&&te===T||(e.blendEquation(32774),Q=T,te=T),l)switch(t){case _:e.blendFuncSeparate(1,771,1,771);break;case b:e.blendFunc(1,1);break;case M:e.blendFuncSeparate(0,769,0,1);break;case S:e.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",t)}else switch(t){case _:e.blendFuncSeparate(770,771,1,771);break;case b:e.blendFunc(770,1);break;case M:e.blendFuncSeparate(0,769,0,1);break;case S:e.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",t)}$=null,ee=null,ie=null,re=null,K=t,ne=l}}else!0===J&&(disable(3042),J=!1)}function setFlipSided(t){se!==t&&(t?e.frontFace(2304):e.frontFace(2305),se=t)}function setCullFace(t){t!==s?(enable(2884),t!==ae&&(t===a?e.cullFace(1029):t===o?e.cullFace(1028):e.cullFace(1032))):disable(2884),ae=t}function setPolygonOffset(t,i,r){t?(enable(32823),le===i&&ce===r||(e.polygonOffset(i,r),le=i,ce=r)):disable(32823)}function activeTexture(t){void 0===t&&(t=33984+he-1),me!==t&&(e.activeTexture(t),me=t)}return{buffers:{color:n,depth:l,stencil:c},enable:enable,disable:disable,bindFramebuffer:function bindFramebuffer(t,i){return p[t]!==i&&(e.bindFramebuffer(t,i),p[t]=i,r&&(36009===t&&(p[36160]=i),36160===t&&(p[36009]=i)),!0)},drawBuffers:function drawBuffers(r,n){let s=x,a=!1;if(r)if(s=g.get(n),void 0===s&&(s=[],g.set(n,s)),r.isWebGLMultipleRenderTargets){const e=r.texture;if(s.length!==e.length||36064!==s[0]){for(let t=0,i=e.length;t<i;t++)s[t]=36064+t;s.length=e.length,a=!0}}else 36064!==s[0]&&(s[0]=36064,a=!0);else 1029!==s[0]&&(s[0]=1029,a=!0);a&&(i.isWebGL2?e.drawBuffers(s):t.get("WEBGL_draw_buffers").drawBuffersWEBGL(s))},useProgram:function useProgram(t){return Z!==t&&(e.useProgram(t),Z=t,!0)},setBlending:setBlending,setMaterial:function setMaterial(e,t){e.side===f?disable(2884):enable(2884);let i=e.side===m;t&&(i=!i),setFlipSided(i),e.blending===_&&!1===e.transparent?setBlending(y):setBlending(e.blending,e.blendEquation,e.blendSrc,e.blendDst,e.blendEquationAlpha,e.blendSrcAlpha,e.blendDstAlpha,e.premultipliedAlpha),l.setFunc(e.depthFunc),l.setTest(e.depthTest),l.setMask(e.depthWrite),n.setMask(e.colorWrite);const r=e.stencilWrite;c.setTest(r),r&&(c.setMask(e.stencilWriteMask),c.setFunc(e.stencilFunc,e.stencilRef,e.stencilFuncMask),c.setOp(e.stencilFail,e.stencilZFail,e.stencilZPass)),setPolygonOffset(e.polygonOffset,e.polygonOffsetFactor,e.polygonOffsetUnits),!0===e.alphaToCoverage?enable(32926):disable(32926)},setFlipSided:setFlipSided,setCullFace:setCullFace,setLineWidth:function setLineWidth(t){t!==oe&&(ue&&e.lineWidth(t),oe=t)},setPolygonOffset:setPolygonOffset,setScissorTest:function setScissorTest(e){e?enable(3089):disable(3089)},activeTexture:activeTexture,bindTexture:function bindTexture(t,i){null===me&&activeTexture();let r=fe[me];void 0===r&&(r={type:void 0,texture:void 0},fe[me]=r),r.type===t&&r.texture===i||(e.bindTexture(t,i||_e[t]),r.type=t,r.texture=i)},unbindTexture:function unbindTexture(){const t=fe[me];void 0!==t&&void 0!==t.type&&(e.bindTexture(t.type,null),t.type=void 0,t.texture=void 0)},compressedTexImage2D:function compressedTexImage2D(){try{e.compressedTexImage2D.apply(e,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texImage2D:function texImage2D(){try{e.texImage2D.apply(e,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texImage3D:function texImage3D(){try{e.texImage3D.apply(e,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},updateUBOMapping:function updateUBOMapping(t,i){let r=u.get(i);void 0===r&&(r=new WeakMap,u.set(i,r));let n=r.get(t);void 0===n&&(n=e.getUniformBlockIndex(i,t.name),r.set(t,n))},uniformBlockBinding:function uniformBlockBinding(t,i){const r=u.get(i).get(t);h.get(t)!==r&&(e.uniformBlockBinding(i,r,t.__bindingPointIndex),h.set(t,r))},texStorage2D:function texStorage2D(){try{e.texStorage2D.apply(e,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texStorage3D:function texStorage3D(){try{e.texStorage3D.apply(e,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texSubImage2D:function texSubImage2D(){try{e.texSubImage2D.apply(e,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texSubImage3D:function texSubImage3D(){try{e.texSubImage3D.apply(e,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},compressedTexSubImage2D:function compressedTexSubImage2D(){try{e.compressedTexSubImage2D.apply(e,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},scissor:function scissor(t){!1===xe.equals(t)&&(e.scissor(t.x,t.y,t.z,t.w),xe.copy(t))},viewport:function viewport(t){!1===ye.equals(t)&&(e.viewport(t.x,t.y,t.z,t.w),ye.copy(t))},reset:function reset(){e.disable(3042),e.disable(2884),e.disable(2929),e.disable(32823),e.disable(3089),e.disable(2960),e.disable(32926),e.blendEquation(32774),e.blendFunc(1,0),e.blendFuncSeparate(1,0,1,0),e.colorMask(!0,!0,!0,!0),e.clearColor(0,0,0,0),e.depthMask(!0),e.depthFunc(513),e.clearDepth(1),e.stencilMask(4294967295),e.stencilFunc(519,0,4294967295),e.stencilOp(7680,7680,7680),e.clearStencil(0),e.cullFace(1029),e.frontFace(2305),e.polygonOffset(0,0),e.activeTexture(33984),e.bindFramebuffer(36160,null),!0===r&&(e.bindFramebuffer(36009,null),e.bindFramebuffer(36008,null)),e.useProgram(null),e.lineWidth(1),e.scissor(0,0,e.canvas.width,e.canvas.height),e.viewport(0,0,e.canvas.width,e.canvas.height),d={},me=null,fe={},p={},g=new WeakMap,x=[],Z=null,J=!1,K=null,Q=null,$=null,ee=null,te=null,ie=null,re=null,ne=!1,se=null,ae=null,oe=null,le=null,ce=null,xe.set(0,0,e.canvas.width,e.canvas.height),ye.set(0,0,e.canvas.width,e.canvas.height),n.reset(),l.reset(),c.reset()}}}function WebGLTextures(e,t,i,r,n,s,a){const o=n.isWebGL2,l=n.maxTextures,c=n.maxCubemapSize,h=n.maxTextureSize,u=n.maxSamples,d=t.has("WEBGL_multisampled_render_to_texture")?t.get("WEBGL_multisampled_render_to_texture"):null,p=/OculusBrowser/g.test(navigator.userAgent),m=new WeakMap;let f;const g=new WeakMap;let x=!1;try{x="undefined"!==typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(M){}function createCanvas(e,t){return x?new OffscreenCanvas(e,t):createElementNS("canvas")}function resizeImage(e,t,i,r){let n=1;if((e.width>r||e.height>r)&&(n=r/Math.max(e.width,e.height)),n<1||!0===t){if("undefined"!==typeof HTMLImageElement&&e instanceof HTMLImageElement||"undefined"!==typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!==typeof ImageBitmap&&e instanceof ImageBitmap){const r=t?floorPowerOfTwo:Math.floor,s=r(n*e.width),a=r(n*e.height);void 0===f&&(f=createCanvas(s,a));const o=i?createCanvas(s,a):f;o.width=s,o.height=a;return o.getContext("2d").drawImage(e,0,0,s,a),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+e.width+"x"+e.height+") to ("+s+"x"+a+")."),o}return"data"in e&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+e.width+"x"+e.height+")."),e}return e}function isPowerOfTwo$1(e){return isPowerOfTwo(e.width)&&isPowerOfTwo(e.height)}function textureNeedsGenerateMipmaps(e,t){return e.generateMipmaps&&t&&e.minFilter!==pe&&e.minFilter!==xe}function generateMipmap(t){e.generateMipmap(t)}function getInternalFormat(i,r,n,s,a=!1){if(!1===o)return r;if(null!==i){if(void 0!==e[i])return e[i];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+i+"'")}let l=r;return 6403===r&&(5126===n&&(l=33326),5131===n&&(l=33325),5121===n&&(l=33321)),33319===r&&(5126===n&&(l=33328),5131===n&&(l=33327),5121===n&&(l=33323)),6408===r&&(5126===n&&(l=34836),5131===n&&(l=34842),5121===n&&(l=s===It&&!1===a?35907:32856),32819===n&&(l=32854),32820===n&&(l=32855)),33325!==l&&33326!==l&&33327!==l&&33328!==l&&34842!==l&&34836!==l||t.get("EXT_color_buffer_float"),l}function getMipLevels(e,t,i){return!0===textureNeedsGenerateMipmaps(e,i)||e.isFramebufferTexture&&e.minFilter!==pe&&e.minFilter!==xe?Math.log2(Math.max(t.width,t.height))+1:void 0!==e.mipmaps&&e.mipmaps.length>0?e.mipmaps.length:e.isCompressedTexture&&Array.isArray(e.image)?t.mipmaps.length:1}function filterFallback(e){return e===pe||e===me||e===ge?9728:9729}function onTextureDispose(e){const t=e.target;t.removeEventListener("dispose",onTextureDispose),function deallocateTexture(e){const t=r.get(e);if(void 0===t.__webglInit)return;const i=e.source,n=g.get(i);if(n){const r=n[t.__cacheKey];r.usedTimes--,0===r.usedTimes&&deleteTexture(e),0===Object.keys(n).length&&g.delete(i)}r.remove(e)}(t),t.isVideoTexture&&m.delete(t)}function onRenderTargetDispose(t){const i=t.target;i.removeEventListener("dispose",onRenderTargetDispose),function deallocateRenderTarget(t){const i=t.texture,n=r.get(t),s=r.get(i);void 0!==s.__webglTexture&&(e.deleteTexture(s.__webglTexture),a.memory.textures--);t.depthTexture&&t.depthTexture.dispose();if(t.isWebGLCubeRenderTarget)for(let r=0;r<6;r++)e.deleteFramebuffer(n.__webglFramebuffer[r]),n.__webglDepthbuffer&&e.deleteRenderbuffer(n.__webglDepthbuffer[r]);else{if(e.deleteFramebuffer(n.__webglFramebuffer),n.__webglDepthbuffer&&e.deleteRenderbuffer(n.__webglDepthbuffer),n.__webglMultisampledFramebuffer&&e.deleteFramebuffer(n.__webglMultisampledFramebuffer),n.__webglColorRenderbuffer)for(let t=0;t<n.__webglColorRenderbuffer.length;t++)n.__webglColorRenderbuffer[t]&&e.deleteRenderbuffer(n.__webglColorRenderbuffer[t]);n.__webglDepthRenderbuffer&&e.deleteRenderbuffer(n.__webglDepthRenderbuffer)}if(t.isWebGLMultipleRenderTargets)for(let o=0,l=i.length;o<l;o++){const t=r.get(i[o]);t.__webglTexture&&(e.deleteTexture(t.__webglTexture),a.memory.textures--),r.remove(i[o])}r.remove(i),r.remove(t)}(i)}function deleteTexture(t){const i=r.get(t);e.deleteTexture(i.__webglTexture);const n=t.source;delete g.get(n)[i.__cacheKey],a.memory.textures--}let y=0;function setTexture2D(e,t){const n=r.get(e);if(e.isVideoTexture&&function updateVideoTexture(e){const t=a.render.frame;m.get(e)!==t&&(m.set(e,t),e.update())}(e),!1===e.isRenderTargetTexture&&e.version>0&&n.__version!==e.version){const i=e.image;if(null===i)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else{if(!1!==i.complete)return void uploadTexture(n,e,t);console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")}}i.activeTexture(33984+t),i.bindTexture(3553,n.__webglTexture)}const _={[he]:10497,[ue]:33071,[de]:33648},b={[pe]:9728,[me]:9984,[ge]:9986,[xe]:9729,[ye]:9985,[be]:9987};function setTextureParameters(i,s,a){if(a?(e.texParameteri(i,10242,_[s.wrapS]),e.texParameteri(i,10243,_[s.wrapT]),32879!==i&&35866!==i||e.texParameteri(i,32882,_[s.wrapR]),e.texParameteri(i,10240,b[s.magFilter]),e.texParameteri(i,10241,b[s.minFilter])):(e.texParameteri(i,10242,33071),e.texParameteri(i,10243,33071),32879!==i&&35866!==i||e.texParameteri(i,32882,33071),s.wrapS===ue&&s.wrapT===ue||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),e.texParameteri(i,10240,filterFallback(s.magFilter)),e.texParameteri(i,10241,filterFallback(s.minFilter)),s.minFilter!==pe&&s.minFilter!==xe&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),!0===t.has("EXT_texture_filter_anisotropic")){const a=t.get("EXT_texture_filter_anisotropic");if(s.type===Le&&!1===t.has("OES_texture_float_linear"))return;if(!1===o&&s.type===Pe&&!1===t.has("OES_texture_half_float_linear"))return;(s.anisotropy>1||r.get(s).__currentAnisotropy)&&(e.texParameterf(i,a.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(s.anisotropy,n.getMaxAnisotropy())),r.get(s).__currentAnisotropy=s.anisotropy)}}function initTexture(t,i){let r=!1;void 0===t.__webglInit&&(t.__webglInit=!0,i.addEventListener("dispose",onTextureDispose));const n=i.source;let s=g.get(n);void 0===s&&(s={},g.set(n,s));const o=function getTextureCacheKey(e){const t=[];return t.push(e.wrapS),t.push(e.wrapT),t.push(e.magFilter),t.push(e.minFilter),t.push(e.anisotropy),t.push(e.internalFormat),t.push(e.format),t.push(e.type),t.push(e.generateMipmaps),t.push(e.premultiplyAlpha),t.push(e.flipY),t.push(e.unpackAlignment),t.push(e.encoding),t.join()}(i);if(o!==t.__cacheKey){void 0===s[o]&&(s[o]={texture:e.createTexture(),usedTimes:0},a.memory.textures++,r=!0),s[o].usedTimes++;const n=s[t.__cacheKey];void 0!==n&&(s[t.__cacheKey].usedTimes--,0===n.usedTimes&&deleteTexture(i)),t.__cacheKey=o,t.__webglTexture=s[o].texture}return r}function uploadTexture(t,r,n){let a=3553;r.isDataArrayTexture&&(a=35866),r.isData3DTexture&&(a=32879);const l=initTexture(t,r),c=r.source;if(i.activeTexture(33984+n),i.bindTexture(a,t.__webglTexture),c.version!==c.__currentVersion||!0===l){e.pixelStorei(37440,r.flipY),e.pixelStorei(37441,r.premultiplyAlpha),e.pixelStorei(3317,r.unpackAlignment),e.pixelStorei(37443,0);const t=function textureNeedsPowerOfTwo(e){return!o&&(e.wrapS!==ue||e.wrapT!==ue||e.minFilter!==pe&&e.minFilter!==xe)}(r)&&!1===isPowerOfTwo$1(r.image);let n=resizeImage(r.image,t,!1,h);n=verifyColorSpace(r,n);const u=isPowerOfTwo$1(n)||o,d=s.convert(r.format,r.encoding);let p,m=s.convert(r.type),f=getInternalFormat(r.internalFormat,d,m,r.encoding,r.isVideoTexture);setTextureParameters(a,r,u);const g=r.mipmaps,x=o&&!0!==r.isVideoTexture,y=void 0===c.__currentVersion||!0===l,_=getMipLevels(r,n,u);if(r.isDepthTexture)f=6402,o?f=r.type===Le?36012:r.type===Ee?33190:r.type===Ie?35056:33189:r.type===Le&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),r.format===Fe&&6402===f&&r.type!==Ae&&r.type!==Ee&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),r.type=Ee,m=s.convert(r.type)),r.format===Ge&&6402===f&&(f=34041,r.type!==Ie&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),r.type=Ie,m=s.convert(r.type))),y&&(x?i.texStorage2D(3553,1,f,n.width,n.height):i.texImage2D(3553,0,f,n.width,n.height,0,d,m,null));else if(r.isDataTexture)if(g.length>0&&u){x&&y&&i.texStorage2D(3553,_,f,g[0].width,g[0].height);for(let e=0,t=g.length;e<t;e++)p=g[e],x?i.texSubImage2D(3553,e,0,0,p.width,p.height,d,m,p.data):i.texImage2D(3553,e,f,p.width,p.height,0,d,m,p.data);r.generateMipmaps=!1}else x?(y&&i.texStorage2D(3553,_,f,n.width,n.height),i.texSubImage2D(3553,0,0,0,n.width,n.height,d,m,n.data)):i.texImage2D(3553,0,f,n.width,n.height,0,d,m,n.data);else if(r.isCompressedTexture){x&&y&&i.texStorage2D(3553,_,f,g[0].width,g[0].height);for(let e=0,t=g.length;e<t;e++)p=g[e],r.format!==Ne?null!==d?x?i.compressedTexSubImage2D(3553,e,0,0,p.width,p.height,d,p.data):i.compressedTexImage2D(3553,e,f,p.width,p.height,0,p.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):x?i.texSubImage2D(3553,e,0,0,p.width,p.height,d,m,p.data):i.texImage2D(3553,e,f,p.width,p.height,0,d,m,p.data)}else if(r.isDataArrayTexture)x?(y&&i.texStorage3D(35866,_,f,n.width,n.height,n.depth),i.texSubImage3D(35866,0,0,0,0,n.width,n.height,n.depth,d,m,n.data)):i.texImage3D(35866,0,f,n.width,n.height,n.depth,0,d,m,n.data);else if(r.isData3DTexture)x?(y&&i.texStorage3D(32879,_,f,n.width,n.height,n.depth),i.texSubImage3D(32879,0,0,0,0,n.width,n.height,n.depth,d,m,n.data)):i.texImage3D(32879,0,f,n.width,n.height,n.depth,0,d,m,n.data);else if(r.isFramebufferTexture){if(y)if(x)i.texStorage2D(3553,_,f,n.width,n.height);else{let e=n.width,t=n.height;for(let r=0;r<_;r++)i.texImage2D(3553,r,f,e,t,0,d,m,null),e>>=1,t>>=1}}else if(g.length>0&&u){x&&y&&i.texStorage2D(3553,_,f,g[0].width,g[0].height);for(let e=0,t=g.length;e<t;e++)p=g[e],x?i.texSubImage2D(3553,e,0,0,d,m,p):i.texImage2D(3553,e,f,d,m,p);r.generateMipmaps=!1}else x?(y&&i.texStorage2D(3553,_,f,n.width,n.height),i.texSubImage2D(3553,0,0,0,d,m,n)):i.texImage2D(3553,0,f,d,m,n);textureNeedsGenerateMipmaps(r,u)&&generateMipmap(a),c.__currentVersion=c.version,r.onUpdate&&r.onUpdate(r)}t.__version=r.version}function setupFrameBufferTexture(t,n,a,o,l){const c=s.convert(a.format,a.encoding),h=s.convert(a.type),u=getInternalFormat(a.internalFormat,c,h,a.encoding);r.get(n).__hasExternalTextures||(32879===l||35866===l?i.texImage3D(l,0,u,n.width,n.height,n.depth,0,c,h,null):i.texImage2D(l,0,u,n.width,n.height,0,c,h,null)),i.bindFramebuffer(36160,t),useMultisampledRTT(n)?d.framebufferTexture2DMultisampleEXT(36160,o,l,r.get(a).__webglTexture,0,getRenderTargetSamples(n)):e.framebufferTexture2D(36160,o,l,r.get(a).__webglTexture,0),i.bindFramebuffer(36160,null)}function setupRenderBufferStorage(t,i,r){if(e.bindRenderbuffer(36161,t),i.depthBuffer&&!i.stencilBuffer){let n=33189;if(r||useMultisampledRTT(i)){const t=i.depthTexture;t&&t.isDepthTexture&&(t.type===Le?n=36012:t.type===Ee&&(n=33190));const r=getRenderTargetSamples(i);useMultisampledRTT(i)?d.renderbufferStorageMultisampleEXT(36161,r,n,i.width,i.height):e.renderbufferStorageMultisample(36161,r,n,i.width,i.height)}else e.renderbufferStorage(36161,n,i.width,i.height);e.framebufferRenderbuffer(36160,36096,36161,t)}else if(i.depthBuffer&&i.stencilBuffer){const n=getRenderTargetSamples(i);r&&!1===useMultisampledRTT(i)?e.renderbufferStorageMultisample(36161,n,35056,i.width,i.height):useMultisampledRTT(i)?d.renderbufferStorageMultisampleEXT(36161,n,35056,i.width,i.height):e.renderbufferStorage(36161,34041,i.width,i.height),e.framebufferRenderbuffer(36160,33306,36161,t)}else{const t=!0===i.isWebGLMultipleRenderTargets?i.texture:[i.texture];for(let n=0;n<t.length;n++){const a=t[n],o=s.convert(a.format,a.encoding),l=s.convert(a.type),c=getInternalFormat(a.internalFormat,o,l,a.encoding),h=getRenderTargetSamples(i);r&&!1===useMultisampledRTT(i)?e.renderbufferStorageMultisample(36161,h,c,i.width,i.height):useMultisampledRTT(i)?d.renderbufferStorageMultisampleEXT(36161,h,c,i.width,i.height):e.renderbufferStorage(36161,c,i.width,i.height)}}e.bindRenderbuffer(36161,null)}function setupDepthRenderbuffer(t){const n=r.get(t),s=!0===t.isWebGLCubeRenderTarget;if(t.depthTexture&&!n.__autoAllocateDepthBuffer){if(s)throw new Error("target.depthTexture not supported in Cube render targets");!function setupDepthTexture(t,n){if(n&&n.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(i.bindFramebuffer(36160,t),!n.depthTexture||!n.depthTexture.isDepthTexture)throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");r.get(n.depthTexture).__webglTexture&&n.depthTexture.image.width===n.width&&n.depthTexture.image.height===n.height||(n.depthTexture.image.width=n.width,n.depthTexture.image.height=n.height,n.depthTexture.needsUpdate=!0),setTexture2D(n.depthTexture,0);const s=r.get(n.depthTexture).__webglTexture,a=getRenderTargetSamples(n);if(n.depthTexture.format===Fe)useMultisampledRTT(n)?d.framebufferTexture2DMultisampleEXT(36160,36096,3553,s,0,a):e.framebufferTexture2D(36160,36096,3553,s,0);else{if(n.depthTexture.format!==Ge)throw new Error("Unknown depthTexture format");useMultisampledRTT(n)?d.framebufferTexture2DMultisampleEXT(36160,33306,3553,s,0,a):e.framebufferTexture2D(36160,33306,3553,s,0)}}(n.__webglFramebuffer,t)}else if(s){n.__webglDepthbuffer=[];for(let r=0;r<6;r++)i.bindFramebuffer(36160,n.__webglFramebuffer[r]),n.__webglDepthbuffer[r]=e.createRenderbuffer(),setupRenderBufferStorage(n.__webglDepthbuffer[r],t,!1)}else i.bindFramebuffer(36160,n.__webglFramebuffer),n.__webglDepthbuffer=e.createRenderbuffer(),setupRenderBufferStorage(n.__webglDepthbuffer,t,!1);i.bindFramebuffer(36160,null)}function getRenderTargetSamples(e){return Math.min(u,e.samples)}function useMultisampledRTT(e){const i=r.get(e);return o&&e.samples>0&&!0===t.has("WEBGL_multisampled_render_to_texture")&&!1!==i.__useRenderToTexture}function verifyColorSpace(e,i){const r=e.encoding,n=e.format,s=e.type;return!0===e.isCompressedTexture||!0===e.isVideoTexture||e.format===mi||r!==Dt&&(r===It?!1===o?!0===t.has("EXT_sRGB")&&n===Ne?(e.format=mi,e.minFilter=xe,e.generateMipmaps=!1):i=ImageUtils.sRGBToLinear(i):n===Ne&&s===Se||console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture encoding:",r)),i}this.allocateTextureUnit=function allocateTextureUnit(){const e=y;return e>=l&&console.warn("THREE.WebGLTextures: Trying to use "+e+" texture units while this GPU supports only "+l),y+=1,e},this.resetTextureUnits=function resetTextureUnits(){y=0},this.setTexture2D=setTexture2D,this.setTexture2DArray=function setTexture2DArray(e,t){const n=r.get(e);e.version>0&&n.__version!==e.version?uploadTexture(n,e,t):(i.activeTexture(33984+t),i.bindTexture(35866,n.__webglTexture))},this.setTexture3D=function setTexture3D(e,t){const n=r.get(e);e.version>0&&n.__version!==e.version?uploadTexture(n,e,t):(i.activeTexture(33984+t),i.bindTexture(32879,n.__webglTexture))},this.setTextureCube=function setTextureCube(t,n){const a=r.get(t);t.version>0&&a.__version!==t.version?function uploadCubeTexture(t,r,n){if(6!==r.image.length)return;const a=initTexture(t,r),l=r.source;if(i.activeTexture(33984+n),i.bindTexture(34067,t.__webglTexture),l.version!==l.__currentVersion||!0===a){e.pixelStorei(37440,r.flipY),e.pixelStorei(37441,r.premultiplyAlpha),e.pixelStorei(3317,r.unpackAlignment),e.pixelStorei(37443,0);const t=r.isCompressedTexture||r.image[0].isCompressedTexture,n=r.image[0]&&r.image[0].isDataTexture,h=[];for(let e=0;e<6;e++)h[e]=t||n?n?r.image[e].image:r.image[e]:resizeImage(r.image[e],!1,!0,c),h[e]=verifyColorSpace(r,h[e]);const u=h[0],d=isPowerOfTwo$1(u)||o,p=s.convert(r.format,r.encoding),m=s.convert(r.type),f=getInternalFormat(r.internalFormat,p,m,r.encoding),g=o&&!0!==r.isVideoTexture,x=void 0===l.__currentVersion||!0===a;let y,_=getMipLevels(r,u,d);if(setTextureParameters(34067,r,d),t){g&&x&&i.texStorage2D(34067,_,f,u.width,u.height);for(let e=0;e<6;e++){y=h[e].mipmaps;for(let t=0;t<y.length;t++){const n=y[t];r.format!==Ne?null!==p?g?i.compressedTexSubImage2D(34069+e,t,0,0,n.width,n.height,p,n.data):i.compressedTexImage2D(34069+e,t,f,n.width,n.height,0,n.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):g?i.texSubImage2D(34069+e,t,0,0,n.width,n.height,p,m,n.data):i.texImage2D(34069+e,t,f,n.width,n.height,0,p,m,n.data)}}}else{y=r.mipmaps,g&&x&&(y.length>0&&_++,i.texStorage2D(34067,_,f,h[0].width,h[0].height));for(let e=0;e<6;e++)if(n){g?i.texSubImage2D(34069+e,0,0,0,h[e].width,h[e].height,p,m,h[e].data):i.texImage2D(34069+e,0,f,h[e].width,h[e].height,0,p,m,h[e].data);for(let t=0;t<y.length;t++){const r=y[t].image[e].image;g?i.texSubImage2D(34069+e,t+1,0,0,r.width,r.height,p,m,r.data):i.texImage2D(34069+e,t+1,f,r.width,r.height,0,p,m,r.data)}}else{g?i.texSubImage2D(34069+e,0,0,0,p,m,h[e]):i.texImage2D(34069+e,0,f,p,m,h[e]);for(let t=0;t<y.length;t++){const r=y[t];g?i.texSubImage2D(34069+e,t+1,0,0,p,m,r.image[e]):i.texImage2D(34069+e,t+1,f,p,m,r.image[e])}}}textureNeedsGenerateMipmaps(r,d)&&generateMipmap(34067),l.__currentVersion=l.version,r.onUpdate&&r.onUpdate(r)}t.__version=r.version}(a,t,n):(i.activeTexture(33984+n),i.bindTexture(34067,a.__webglTexture))},this.rebindTextures=function rebindTextures(e,t,i){const n=r.get(e);void 0!==t&&setupFrameBufferTexture(n.__webglFramebuffer,e,e.texture,36064,3553),void 0!==i&&setupDepthRenderbuffer(e)},this.setupRenderTarget=function setupRenderTarget(t){const l=t.texture,c=r.get(t),h=r.get(l);t.addEventListener("dispose",onRenderTargetDispose),!0!==t.isWebGLMultipleRenderTargets&&(void 0===h.__webglTexture&&(h.__webglTexture=e.createTexture()),h.__version=l.version,a.memory.textures++);const u=!0===t.isWebGLCubeRenderTarget,d=!0===t.isWebGLMultipleRenderTargets,p=isPowerOfTwo$1(t)||o;if(u){c.__webglFramebuffer=[];for(let t=0;t<6;t++)c.__webglFramebuffer[t]=e.createFramebuffer()}else{if(c.__webglFramebuffer=e.createFramebuffer(),d)if(n.drawBuffers){const i=t.texture;for(let t=0,n=i.length;t<n;t++){const n=r.get(i[t]);void 0===n.__webglTexture&&(n.__webglTexture=e.createTexture(),a.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(o&&t.samples>0&&!1===useMultisampledRTT(t)){const r=d?l:[l];c.__webglMultisampledFramebuffer=e.createFramebuffer(),c.__webglColorRenderbuffer=[],i.bindFramebuffer(36160,c.__webglMultisampledFramebuffer);for(let i=0;i<r.length;i++){const n=r[i];c.__webglColorRenderbuffer[i]=e.createRenderbuffer(),e.bindRenderbuffer(36161,c.__webglColorRenderbuffer[i]);const a=s.convert(n.format,n.encoding),o=s.convert(n.type),l=getInternalFormat(n.internalFormat,a,o,n.encoding),h=getRenderTargetSamples(t);e.renderbufferStorageMultisample(36161,h,l,t.width,t.height),e.framebufferRenderbuffer(36160,36064+i,36161,c.__webglColorRenderbuffer[i])}e.bindRenderbuffer(36161,null),t.depthBuffer&&(c.__webglDepthRenderbuffer=e.createRenderbuffer(),setupRenderBufferStorage(c.__webglDepthRenderbuffer,t,!0)),i.bindFramebuffer(36160,null)}}if(u){i.bindTexture(34067,h.__webglTexture),setTextureParameters(34067,l,p);for(let e=0;e<6;e++)setupFrameBufferTexture(c.__webglFramebuffer[e],t,l,36064,34069+e);textureNeedsGenerateMipmaps(l,p)&&generateMipmap(34067),i.unbindTexture()}else if(d){const e=t.texture;for(let n=0,s=e.length;n<s;n++){const s=e[n],a=r.get(s);i.bindTexture(3553,a.__webglTexture),setTextureParameters(3553,s,p),setupFrameBufferTexture(c.__webglFramebuffer,t,s,36064+n,3553),textureNeedsGenerateMipmaps(s,p)&&generateMipmap(3553)}i.unbindTexture()}else{let e=3553;(t.isWebGL3DRenderTarget||t.isWebGLArrayRenderTarget)&&(o?e=t.isWebGL3DRenderTarget?32879:35866:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),i.bindTexture(e,h.__webglTexture),setTextureParameters(e,l,p),setupFrameBufferTexture(c.__webglFramebuffer,t,l,36064,e),textureNeedsGenerateMipmaps(l,p)&&generateMipmap(e),i.unbindTexture()}t.depthBuffer&&setupDepthRenderbuffer(t)},this.updateRenderTargetMipmap=function updateRenderTargetMipmap(e){const t=isPowerOfTwo$1(e)||o,n=!0===e.isWebGLMultipleRenderTargets?e.texture:[e.texture];for(let s=0,a=n.length;s<a;s++){const a=n[s];if(textureNeedsGenerateMipmaps(a,t)){const t=e.isWebGLCubeRenderTarget?34067:3553,n=r.get(a).__webglTexture;i.bindTexture(t,n),generateMipmap(t),i.unbindTexture()}}},this.updateMultisampleRenderTarget=function updateMultisampleRenderTarget(t){if(o&&t.samples>0&&!1===useMultisampledRTT(t)){const n=t.isWebGLMultipleRenderTargets?t.texture:[t.texture],s=t.width,a=t.height;let o=16384;const l=[],c=t.stencilBuffer?33306:36096,h=r.get(t),u=!0===t.isWebGLMultipleRenderTargets;if(u)for(let t=0;t<n.length;t++)i.bindFramebuffer(36160,h.__webglMultisampledFramebuffer),e.framebufferRenderbuffer(36160,36064+t,36161,null),i.bindFramebuffer(36160,h.__webglFramebuffer),e.framebufferTexture2D(36009,36064+t,3553,null,0);i.bindFramebuffer(36008,h.__webglMultisampledFramebuffer),i.bindFramebuffer(36009,h.__webglFramebuffer);for(let i=0;i<n.length;i++){l.push(36064+i),t.depthBuffer&&l.push(c);const d=void 0!==h.__ignoreDepthValues&&h.__ignoreDepthValues;if(!1===d&&(t.depthBuffer&&(o|=256),t.stencilBuffer&&(o|=1024)),u&&e.framebufferRenderbuffer(36008,36064,36161,h.__webglColorRenderbuffer[i]),!0===d&&(e.invalidateFramebuffer(36008,[c]),e.invalidateFramebuffer(36009,[c])),u){const t=r.get(n[i]).__webglTexture;e.framebufferTexture2D(36009,36064,3553,t,0)}e.blitFramebuffer(0,0,s,a,0,0,s,a,o,9728),p&&e.invalidateFramebuffer(36008,l)}if(i.bindFramebuffer(36008,null),i.bindFramebuffer(36009,null),u)for(let t=0;t<n.length;t++){i.bindFramebuffer(36160,h.__webglMultisampledFramebuffer),e.framebufferRenderbuffer(36160,36064+t,36161,h.__webglColorRenderbuffer[t]);const s=r.get(n[t]).__webglTexture;i.bindFramebuffer(36160,h.__webglFramebuffer),e.framebufferTexture2D(36009,36064+t,3553,s,0)}i.bindFramebuffer(36009,h.__webglMultisampledFramebuffer)}},this.setupDepthRenderbuffer=setupDepthRenderbuffer,this.setupFrameBufferTexture=setupFrameBufferTexture,this.useMultisampledRTT=useMultisampledRTT}function WebGLUtils(e,t,i){const r=i.isWebGL2;return{convert:function convert(i,n=null){let s;if(i===Se)return 5121;if(i===Re)return 32819;if(i===De)return 32820;if(i===we)return 5120;if(i===Te)return 5122;if(i===Ae)return 5123;if(i===Ce)return 5124;if(i===Ee)return 5125;if(i===Le)return 5126;if(i===Pe)return r?5131:(s=t.get("OES_texture_half_float"),null!==s?s.HALF_FLOAT_OES:null);if(i===Be)return 6406;if(i===Ne)return 6408;if(i===Oe)return 6409;if(i===ze)return 6410;if(i===Fe)return 6402;if(i===Ge)return 34041;if(i===Ue)return 6403;if(i===Ve)return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),6408;if(i===mi)return s=t.get("EXT_sRGB"),null!==s?s.SRGB_ALPHA_EXT:null;if(i===ke)return 36244;if(i===We)return 33319;if(i===He)return 33320;if(i===je)return 36249;if(i===qe||i===Xe||i===Ye||i===Ze)if(n===It){if(s=t.get("WEBGL_compressed_texture_s3tc_srgb"),null===s)return null;if(i===qe)return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(i===Xe)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(i===Ye)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(i===Ze)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else{if(s=t.get("WEBGL_compressed_texture_s3tc"),null===s)return null;if(i===qe)return s.COMPRESSED_RGB_S3TC_DXT1_EXT;if(i===Xe)return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(i===Ye)return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(i===Ze)return s.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(i===Je||i===Ke||i===Qe||i===$e){if(s=t.get("WEBGL_compressed_texture_pvrtc"),null===s)return null;if(i===Je)return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(i===Ke)return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(i===Qe)return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(i===$e)return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(i===et)return s=t.get("WEBGL_compressed_texture_etc1"),null!==s?s.COMPRESSED_RGB_ETC1_WEBGL:null;if(i===tt||i===it){if(s=t.get("WEBGL_compressed_texture_etc"),null===s)return null;if(i===tt)return n===It?s.COMPRESSED_SRGB8_ETC2:s.COMPRESSED_RGB8_ETC2;if(i===it)return n===It?s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:s.COMPRESSED_RGBA8_ETC2_EAC}if(i===rt||i===nt||i===st||i===at||i===ot||i===lt||i===ct||i===ht||i===ut||i===dt||i===pt||i===mt||i===ft||i===gt){if(s=t.get("WEBGL_compressed_texture_astc"),null===s)return null;if(i===rt)return n===It?s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:s.COMPRESSED_RGBA_ASTC_4x4_KHR;if(i===nt)return n===It?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:s.COMPRESSED_RGBA_ASTC_5x4_KHR;if(i===st)return n===It?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:s.COMPRESSED_RGBA_ASTC_5x5_KHR;if(i===at)return n===It?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:s.COMPRESSED_RGBA_ASTC_6x5_KHR;if(i===ot)return n===It?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:s.COMPRESSED_RGBA_ASTC_6x6_KHR;if(i===lt)return n===It?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:s.COMPRESSED_RGBA_ASTC_8x5_KHR;if(i===ct)return n===It?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:s.COMPRESSED_RGBA_ASTC_8x6_KHR;if(i===ht)return n===It?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:s.COMPRESSED_RGBA_ASTC_8x8_KHR;if(i===ut)return n===It?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:s.COMPRESSED_RGBA_ASTC_10x5_KHR;if(i===dt)return n===It?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:s.COMPRESSED_RGBA_ASTC_10x6_KHR;if(i===pt)return n===It?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:s.COMPRESSED_RGBA_ASTC_10x8_KHR;if(i===mt)return n===It?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:s.COMPRESSED_RGBA_ASTC_10x10_KHR;if(i===ft)return n===It?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:s.COMPRESSED_RGBA_ASTC_12x10_KHR;if(i===gt)return n===It?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:s.COMPRESSED_RGBA_ASTC_12x12_KHR}if(i===vt){if(s=t.get("EXT_texture_compression_bptc"),null===s)return null;if(i===vt)return n===It?s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:s.COMPRESSED_RGBA_BPTC_UNORM_EXT}return i===Ie?r?34042:(s=t.get("WEBGL_depth_texture"),null!==s?s.UNSIGNED_INT_24_8_WEBGL:null):void 0!==e[i]?e[i]:null}}}class ArrayCamera extends PerspectiveCamera{constructor(e=[]){super(),this.isArrayCamera=!0,this.cameras=e}}class Group extends Object3D{constructor(){super(),this.isGroup=!0,this.type="Group"}}const Hn={type:"move"};class WebXRController{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return null===this._hand&&(this._hand=new Group,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return null===this._targetRay&&(this._targetRay=new Group,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new Vector3,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new Vector3),this._targetRay}getGripSpace(){return null===this._grip&&(this._grip=new Group,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new Vector3,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new Vector3),this._grip}dispatchEvent(e){return null!==this._targetRay&&this._targetRay.dispatchEvent(e),null!==this._grip&&this._grip.dispatchEvent(e),null!==this._hand&&this._hand.dispatchEvent(e),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this}update(e,t,i){let r=null,n=null,s=null;const a=this._targetRay,o=this._grip,l=this._hand;if(e&&"visible-blurred"!==t.session.visibilityState){if(l&&e.hand){s=!0;for(const s of e.hand.values()){const e=t.getJointPose(s,i);if(void 0===l.joints[s.jointName]){const e=new Group;e.matrixAutoUpdate=!1,e.visible=!1,l.joints[s.jointName]=e,l.add(e)}const r=l.joints[s.jointName];null!==e&&(r.matrix.fromArray(e.transform.matrix),r.matrix.decompose(r.position,r.rotation,r.scale),r.jointRadius=e.radius),r.visible=null!==e}const r=l.joints["index-finger-tip"],n=l.joints["thumb-tip"],a=r.position.distanceTo(n.position),o=.02,c=.005;l.inputState.pinching&&a>o+c?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!l.inputState.pinching&&a<=o-c&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else null!==o&&e.gripSpace&&(n=t.getPose(e.gripSpace,i),null!==n&&(o.matrix.fromArray(n.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),n.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(n.linearVelocity)):o.hasLinearVelocity=!1,n.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(n.angularVelocity)):o.hasAngularVelocity=!1));null!==a&&(r=t.getPose(e.targetRaySpace,i),null===r&&null!==n&&(r=n),null!==r&&(a.matrix.fromArray(r.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),r.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(r.linearVelocity)):a.hasLinearVelocity=!1,r.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(r.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(Hn)))}return null!==a&&(a.visible=null!==r),null!==o&&(o.visible=null!==n),null!==l&&(l.visible=null!==s),this}}class DepthTexture extends Texture{constructor(e,t,i,r,n,s,a,o,l,c){if((c=void 0!==c?c:Fe)!==Fe&&c!==Ge)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===i&&c===Fe&&(i=Ee),void 0===i&&c===Ge&&(i=Ie),super(null,r,n,s,a,o,c,i,l),this.isDepthTexture=!0,this.image={width:e,height:t},this.magFilter=void 0!==a?a:pe,this.minFilter=void 0!==o?o:pe,this.flipY=!1,this.generateMipmaps=!1}}class WebXRManager extends EventDispatcher{constructor(e,t){super();const i=this;let r=null,n=1,s=null,a="local-floor",o=null,l=null,c=null,h=null,u=null,d=null;const p=t.getContextAttributes();let m=null,f=null;const g=[],x=[],y=new PerspectiveCamera;y.layers.enable(1),y.viewport=new Vector4;const _=new PerspectiveCamera;_.layers.enable(2),_.viewport=new Vector4;const b=[y,_],M=new ArrayCamera;M.layers.enable(1),M.layers.enable(2);let S=null,w=null;function onSessionEvent(e){const t=x.indexOf(e.inputSource);if(-1===t)return;const i=g[t];void 0!==i&&i.dispatchEvent({type:e.type,data:e.inputSource})}function onSessionEnd(){r.removeEventListener("select",onSessionEvent),r.removeEventListener("selectstart",onSessionEvent),r.removeEventListener("selectend",onSessionEvent),r.removeEventListener("squeeze",onSessionEvent),r.removeEventListener("squeezestart",onSessionEvent),r.removeEventListener("squeezeend",onSessionEvent),r.removeEventListener("end",onSessionEnd),r.removeEventListener("inputsourceschange",onInputSourcesChange);for(let e=0;e<g.length;e++){const t=x[e];null!==t&&(x[e]=null,g[e].disconnect(t))}S=null,w=null,e.setRenderTarget(m),u=null,h=null,c=null,r=null,f=null,E.stop(),i.isPresenting=!1,i.dispatchEvent({type:"sessionend"})}function onInputSourcesChange(e){for(let t=0;t<e.removed.length;t++){const i=e.removed[t],r=x.indexOf(i);r>=0&&(x[r]=null,g[r].dispatchEvent({type:"disconnected",data:i}))}for(let t=0;t<e.added.length;t++){const i=e.added[t];let r=x.indexOf(i);if(-1===r){for(let e=0;e<g.length;e++){if(e>=x.length){x.push(i),r=e;break}if(null===x[e]){x[e]=i,r=e;break}}if(-1===r)break}const n=g[r];n&&n.dispatchEvent({type:"connected",data:i})}}this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(e){let t=g[e];return void 0===t&&(t=new WebXRController,g[e]=t),t.getTargetRaySpace()},this.getControllerGrip=function(e){let t=g[e];return void 0===t&&(t=new WebXRController,g[e]=t),t.getGripSpace()},this.getHand=function(e){let t=g[e];return void 0===t&&(t=new WebXRController,g[e]=t),t.getHandSpace()},this.setFramebufferScaleFactor=function(e){n=e,!0===i.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(e){a=e,!0===i.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return o||s},this.setReferenceSpace=function(e){o=e},this.getBaseLayer=function(){return null!==h?h:u},this.getBinding=function(){return c},this.getFrame=function(){return d},this.getSession=function(){return r},this.setSession=async function(l){if(r=l,null!==r){if(m=e.getRenderTarget(),r.addEventListener("select",onSessionEvent),r.addEventListener("selectstart",onSessionEvent),r.addEventListener("selectend",onSessionEvent),r.addEventListener("squeeze",onSessionEvent),r.addEventListener("squeezestart",onSessionEvent),r.addEventListener("squeezeend",onSessionEvent),r.addEventListener("end",onSessionEnd),r.addEventListener("inputsourceschange",onInputSourcesChange),!0!==p.xrCompatible&&await t.makeXRCompatible(),void 0===r.renderState.layers||!1===e.capabilities.isWebGL2){const i={antialias:void 0!==r.renderState.layers||p.antialias,alpha:p.alpha,depth:p.depth,stencil:p.stencil,framebufferScaleFactor:n};u=new XRWebGLLayer(r,t,i),r.updateRenderState({baseLayer:u}),f=new WebGLRenderTarget(u.framebufferWidth,u.framebufferHeight,{format:Ne,type:Se,encoding:e.outputEncoding})}else{let i=null,s=null,a=null;p.depth&&(a=p.stencil?35056:33190,i=p.stencil?Ge:Fe,s=p.stencil?Ie:Ee);const o={colorFormat:32856,depthFormat:a,scaleFactor:n};c=new XRWebGLBinding(r,t),h=c.createProjectionLayer(o),r.updateRenderState({layers:[h]}),f=new WebGLRenderTarget(h.textureWidth,h.textureHeight,{format:Ne,type:Se,depthTexture:new DepthTexture(h.textureWidth,h.textureHeight,s,void 0,void 0,void 0,void 0,void 0,void 0,i),stencilBuffer:p.stencil,encoding:e.outputEncoding,samples:p.antialias?4:0});e.properties.get(f).__ignoreDepthValues=h.ignoreDepthValues}f.isXRRenderTarget=!0,this.setFoveation(1),o=null,s=await r.requestReferenceSpace(a),E.setContext(r),E.start(),i.isPresenting=!0,i.dispatchEvent({type:"sessionstart"})}};const T=new Vector3,A=new Vector3;function updateCamera(e,t){null===t?e.matrixWorld.copy(e.matrix):e.matrixWorld.multiplyMatrices(t.matrixWorld,e.matrix),e.matrixWorldInverse.copy(e.matrixWorld).invert()}this.updateCamera=function(e){if(null===r)return;M.near=_.near=y.near=e.near,M.far=_.far=y.far=e.far,S===M.near&&w===M.far||(r.updateRenderState({depthNear:M.near,depthFar:M.far}),S=M.near,w=M.far);const t=e.parent,i=M.cameras;updateCamera(M,t);for(let r=0;r<i.length;r++)updateCamera(i[r],t);M.matrixWorld.decompose(M.position,M.quaternion,M.scale),e.position.copy(M.position),e.quaternion.copy(M.quaternion),e.scale.copy(M.scale),e.matrix.copy(M.matrix),e.matrixWorld.copy(M.matrixWorld);const n=e.children;for(let r=0,s=n.length;r<s;r++)n[r].updateMatrixWorld(!0);2===i.length?function setProjectionFromUnion(e,t,i){T.setFromMatrixPosition(t.matrixWorld),A.setFromMatrixPosition(i.matrixWorld);const r=T.distanceTo(A),n=t.projectionMatrix.elements,s=i.projectionMatrix.elements,a=n[14]/(n[10]-1),o=n[14]/(n[10]+1),l=(n[9]+1)/n[5],c=(n[9]-1)/n[5],h=(n[8]-1)/n[0],u=(s[8]+1)/s[0],d=a*h,p=a*u,m=r/(-h+u),f=m*-h;t.matrixWorld.decompose(e.position,e.quaternion,e.scale),e.translateX(f),e.translateZ(m),e.matrixWorld.compose(e.position,e.quaternion,e.scale),e.matrixWorldInverse.copy(e.matrixWorld).invert();const g=a+m,x=o+m,y=d-f,_=p+(r-f),b=l*o/x*g,M=c*o/x*g;e.projectionMatrix.makePerspective(y,_,b,M,g,x)}(M,y,_):M.projectionMatrix.copy(y.projectionMatrix)},this.getCamera=function(){return M},this.getFoveation=function(){return null!==h?h.fixedFoveation:null!==u?u.fixedFoveation:void 0},this.setFoveation=function(e){null!==h&&(h.fixedFoveation=e),null!==u&&void 0!==u.fixedFoveation&&(u.fixedFoveation=e)};let C=null;const E=new WebGLAnimation;E.setAnimationLoop((function onAnimationFrame(t,i){if(l=i.getViewerPose(o||s),d=i,null!==l){const t=l.views;null!==u&&(e.setRenderTargetFramebuffer(f,u.framebuffer),e.setRenderTarget(f));let i=!1;t.length!==M.cameras.length&&(M.cameras.length=0,i=!0);for(let r=0;r<t.length;r++){const n=t[r];let s=null;if(null!==u)s=u.getViewport(n);else{const t=c.getViewSubImage(h,n);s=t.viewport,0===r&&(e.setRenderTargetTextures(f,t.colorTexture,h.ignoreDepthValues?void 0:t.depthStencilTexture),e.setRenderTarget(f))}let a=b[r];void 0===a&&(a=new PerspectiveCamera,a.layers.enable(r),a.viewport=new Vector4,b[r]=a),a.matrix.fromArray(n.transform.matrix),a.projectionMatrix.fromArray(n.projectionMatrix),a.viewport.set(s.x,s.y,s.width,s.height),0===r&&M.matrix.copy(a.matrix),!0===i&&M.cameras.push(a)}}for(let e=0;e<g.length;e++){const t=x[e],r=g[e];null!==t&&void 0!==r&&r.update(t,i,o||s)}C&&C(t,i),d=null})),this.setAnimationLoop=function(e){C=e},this.dispose=function(){}}}function WebGLMaterials(e,t){function refreshUniformsCommon(i,r){i.opacity.value=r.opacity,r.color&&i.diffuse.value.copy(r.color),r.emissive&&i.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity),r.map&&(i.map.value=r.map),r.alphaMap&&(i.alphaMap.value=r.alphaMap),r.bumpMap&&(i.bumpMap.value=r.bumpMap,i.bumpScale.value=r.bumpScale,r.side===m&&(i.bumpScale.value*=-1)),r.displacementMap&&(i.displacementMap.value=r.displacementMap,i.displacementScale.value=r.displacementScale,i.displacementBias.value=r.displacementBias),r.emissiveMap&&(i.emissiveMap.value=r.emissiveMap),r.normalMap&&(i.normalMap.value=r.normalMap,i.normalScale.value.copy(r.normalScale),r.side===m&&i.normalScale.value.negate()),r.specularMap&&(i.specularMap.value=r.specularMap),r.alphaTest>0&&(i.alphaTest.value=r.alphaTest);const n=t.get(r).envMap;if(n&&(i.envMap.value=n,i.flipEnvMap.value=n.isCubeTexture&&!1===n.isRenderTargetTexture?-1:1,i.reflectivity.value=r.reflectivity,i.ior.value=r.ior,i.refractionRatio.value=r.refractionRatio),r.lightMap){i.lightMap.value=r.lightMap;const t=!0!==e.physicallyCorrectLights?Math.PI:1;i.lightMapIntensity.value=r.lightMapIntensity*t}let s,a;r.aoMap&&(i.aoMap.value=r.aoMap,i.aoMapIntensity.value=r.aoMapIntensity),r.map?s=r.map:r.specularMap?s=r.specularMap:r.displacementMap?s=r.displacementMap:r.normalMap?s=r.normalMap:r.bumpMap?s=r.bumpMap:r.roughnessMap?s=r.roughnessMap:r.metalnessMap?s=r.metalnessMap:r.alphaMap?s=r.alphaMap:r.emissiveMap?s=r.emissiveMap:r.clearcoatMap?s=r.clearcoatMap:r.clearcoatNormalMap?s=r.clearcoatNormalMap:r.clearcoatRoughnessMap?s=r.clearcoatRoughnessMap:r.iridescenceMap?s=r.iridescenceMap:r.iridescenceThicknessMap?s=r.iridescenceThicknessMap:r.specularIntensityMap?s=r.specularIntensityMap:r.specularColorMap?s=r.specularColorMap:r.transmissionMap?s=r.transmissionMap:r.thicknessMap?s=r.thicknessMap:r.sheenColorMap?s=r.sheenColorMap:r.sheenRoughnessMap&&(s=r.sheenRoughnessMap),void 0!==s&&(s.isWebGLRenderTarget&&(s=s.texture),!0===s.matrixAutoUpdate&&s.updateMatrix(),i.uvTransform.value.copy(s.matrix)),r.aoMap?a=r.aoMap:r.lightMap&&(a=r.lightMap),void 0!==a&&(a.isWebGLRenderTarget&&(a=a.texture),!0===a.matrixAutoUpdate&&a.updateMatrix(),i.uv2Transform.value.copy(a.matrix))}return{refreshFogUniforms:function refreshFogUniforms(e,t){e.fogColor.value.copy(t.color),t.isFog?(e.fogNear.value=t.near,e.fogFar.value=t.far):t.isFogExp2&&(e.fogDensity.value=t.density)},refreshMaterialUniforms:function refreshMaterialUniforms(e,i,r,n,s){i.isMeshBasicMaterial||i.isMeshLambertMaterial?refreshUniformsCommon(e,i):i.isMeshToonMaterial?(refreshUniformsCommon(e,i),function refreshUniformsToon(e,t){t.gradientMap&&(e.gradientMap.value=t.gradientMap)}(e,i)):i.isMeshPhongMaterial?(refreshUniformsCommon(e,i),function refreshUniformsPhong(e,t){e.specular.value.copy(t.specular),e.shininess.value=Math.max(t.shininess,1e-4)}(e,i)):i.isMeshStandardMaterial?(refreshUniformsCommon(e,i),function refreshUniformsStandard(e,i){e.roughness.value=i.roughness,e.metalness.value=i.metalness,i.roughnessMap&&(e.roughnessMap.value=i.roughnessMap);i.metalnessMap&&(e.metalnessMap.value=i.metalnessMap);const r=t.get(i).envMap;r&&(e.envMapIntensity.value=i.envMapIntensity)}(e,i),i.isMeshPhysicalMaterial&&function refreshUniformsPhysical(e,t,i){e.ior.value=t.ior,t.sheen>0&&(e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen),e.sheenRoughness.value=t.sheenRoughness,t.sheenColorMap&&(e.sheenColorMap.value=t.sheenColorMap),t.sheenRoughnessMap&&(e.sheenRoughnessMap.value=t.sheenRoughnessMap));t.clearcoat>0&&(e.clearcoat.value=t.clearcoat,e.clearcoatRoughness.value=t.clearcoatRoughness,t.clearcoatMap&&(e.clearcoatMap.value=t.clearcoatMap),t.clearcoatRoughnessMap&&(e.clearcoatRoughnessMap.value=t.clearcoatRoughnessMap),t.clearcoatNormalMap&&(e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale),e.clearcoatNormalMap.value=t.clearcoatNormalMap,t.side===m&&e.clearcoatNormalScale.value.negate()));t.iridescence>0&&(e.iridescence.value=t.iridescence,e.iridescenceIOR.value=t.iridescenceIOR,e.iridescenceThicknessMinimum.value=t.iridescenceThicknessRange[0],e.iridescenceThicknessMaximum.value=t.iridescenceThicknessRange[1],t.iridescenceMap&&(e.iridescenceMap.value=t.iridescenceMap),t.iridescenceThicknessMap&&(e.iridescenceThicknessMap.value=t.iridescenceThicknessMap));t.transmission>0&&(e.transmission.value=t.transmission,e.transmissionSamplerMap.value=i.texture,e.transmissionSamplerSize.value.set(i.width,i.height),t.transmissionMap&&(e.transmissionMap.value=t.transmissionMap),e.thickness.value=t.thickness,t.thicknessMap&&(e.thicknessMap.value=t.thicknessMap),e.attenuationDistance.value=t.attenuationDistance,e.attenuationColor.value.copy(t.attenuationColor));e.specularIntensity.value=t.specularIntensity,e.specularColor.value.copy(t.specularColor),t.specularIntensityMap&&(e.specularIntensityMap.value=t.specularIntensityMap);t.specularColorMap&&(e.specularColorMap.value=t.specularColorMap)}(e,i,s)):i.isMeshMatcapMaterial?(refreshUniformsCommon(e,i),function refreshUniformsMatcap(e,t){t.matcap&&(e.matcap.value=t.matcap)}(e,i)):i.isMeshDepthMaterial?refreshUniformsCommon(e,i):i.isMeshDistanceMaterial?(refreshUniformsCommon(e,i),function refreshUniformsDistance(e,t){e.referencePosition.value.copy(t.referencePosition),e.nearDistance.value=t.nearDistance,e.farDistance.value=t.farDistance}(e,i)):i.isMeshNormalMaterial?refreshUniformsCommon(e,i):i.isLineBasicMaterial?(!function refreshUniformsLine(e,t){e.diffuse.value.copy(t.color),e.opacity.value=t.opacity}(e,i),i.isLineDashedMaterial&&function refreshUniformsDash(e,t){e.dashSize.value=t.dashSize,e.totalSize.value=t.dashSize+t.gapSize,e.scale.value=t.scale}(e,i)):i.isPointsMaterial?function refreshUniformsPoints(e,t,i,r){e.diffuse.value.copy(t.color),e.opacity.value=t.opacity,e.size.value=t.size*i,e.scale.value=.5*r,t.map&&(e.map.value=t.map);t.alphaMap&&(e.alphaMap.value=t.alphaMap);t.alphaTest>0&&(e.alphaTest.value=t.alphaTest);let n;t.map?n=t.map:t.alphaMap&&(n=t.alphaMap);void 0!==n&&(!0===n.matrixAutoUpdate&&n.updateMatrix(),e.uvTransform.value.copy(n.matrix))}(e,i,r,n):i.isSpriteMaterial?function refreshUniformsSprites(e,t){e.diffuse.value.copy(t.color),e.opacity.value=t.opacity,e.rotation.value=t.rotation,t.map&&(e.map.value=t.map);t.alphaMap&&(e.alphaMap.value=t.alphaMap);t.alphaTest>0&&(e.alphaTest.value=t.alphaTest);let i;t.map?i=t.map:t.alphaMap&&(i=t.alphaMap);void 0!==i&&(!0===i.matrixAutoUpdate&&i.updateMatrix(),e.uvTransform.value.copy(i.matrix))}(e,i):i.isShadowMaterial?(e.color.value.copy(i.color),e.opacity.value=i.opacity):i.isShaderMaterial&&(i.uniformsNeedUpdate=!1)}}}function WebGLUniformsGroups(e,t,i,r){let n={},s={},a=[];const o=i.isWebGL2?e.getParameter(35375):0;function hasUniformChanged(e,t,i){const r=e.value;if(void 0===i[t])return i[t]="number"===typeof r?r:r.clone(),!0;if("number"===typeof r){if(i[t]!==r)return i[t]=r,!0}else{const e=i[t];if(!1===e.equals(r))return e.copy(r),!0}return!1}function getUniformSize(e){const t=e.value,i={boundary:0,storage:0};return"number"===typeof t?(i.boundary=4,i.storage=4):t.isVector2?(i.boundary=8,i.storage=8):t.isVector3||t.isColor?(i.boundary=16,i.storage=12):t.isVector4?(i.boundary=16,i.storage=16):t.isMatrix3?(i.boundary=48,i.storage=48):t.isMatrix4?(i.boundary=64,i.storage=64):t.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",t),i}function onUniformsGroupsDispose(t){const i=t.target;i.removeEventListener("dispose",onUniformsGroupsDispose);const r=a.indexOf(i.__bindingPointIndex);a.splice(r,1),e.deleteBuffer(n[i.id]),delete n[i.id],delete s[i.id]}return{bind:function bind(e,t){const i=t.program;r.uniformBlockBinding(e,i)},update:function update(i,l){let c=n[i.id];void 0===c&&(!function prepareUniformsGroup(e){const t=e.uniforms;let i=0;const r=16;let n=0;for(let s=0,a=t.length;s<a;s++){const e=t[s],a=getUniformSize(e);if(e.__data=new Float32Array(a.storage/Float32Array.BYTES_PER_ELEMENT),e.__offset=i,s>0){n=i%r;0!==n&&r-n-a.boundary<0&&(i+=r-n,e.__offset=i)}i+=a.storage}n=i%r,n>0&&(i+=r-n);return e.__size=i,e.__cache={},this}(i),c=function createBuffer(t){const i=function allocateBindingPointIndex(){for(let e=0;e<o;e++)if(-1===a.indexOf(e))return a.push(e),e;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}();t.__bindingPointIndex=i;const r=e.createBuffer(),n=t.__size,s=t.usage;return e.bindBuffer(35345,r),e.bufferData(35345,n,s),e.bindBuffer(35345,null),e.bindBufferBase(35345,i,r),r}(i),n[i.id]=c,i.addEventListener("dispose",onUniformsGroupsDispose));const h=l.program;r.updateUBOMapping(i,h);const u=t.render.frame;s[i.id]!==u&&(!function updateBufferData(t){const i=n[t.id],r=t.uniforms,s=t.__cache;e.bindBuffer(35345,i);for(let n=0,a=r.length;n<a;n++){const t=r[n];if(!0===hasUniformChanged(t,n,s)){const i=t.value,r=t.__offset;"number"===typeof i?(t.__data[0]=i,e.bufferSubData(35345,r,t.__data)):(t.value.isMatrix3?(t.__data[0]=t.value.elements[0],t.__data[1]=t.value.elements[1],t.__data[2]=t.value.elements[2],t.__data[3]=t.value.elements[0],t.__data[4]=t.value.elements[3],t.__data[5]=t.value.elements[4],t.__data[6]=t.value.elements[5],t.__data[7]=t.value.elements[0],t.__data[8]=t.value.elements[6],t.__data[9]=t.value.elements[7],t.__data[10]=t.value.elements[8],t.__data[11]=t.value.elements[0]):i.toArray(t.__data),e.bufferSubData(35345,r,t.__data))}}e.bindBuffer(35345,null)}(i),s[i.id]=u)},dispose:function dispose(){for(const t in n)e.deleteBuffer(n[t]);a=[],n={},s={}}}}function WebGLRenderer(e={}){this.isWebGLRenderer=!0;const t=void 0!==e.canvas?e.canvas:function createCanvasElement(){const e=createElementNS("canvas");return e.style.display="block",e}(),r=void 0!==e.context?e.context:null,n=void 0===e.depth||e.depth,s=void 0===e.stencil||e.stencil,a=void 0!==e.antialias&&e.antialias,o=void 0===e.premultipliedAlpha||e.premultipliedAlpha,l=void 0!==e.preserveDrawingBuffer&&e.preserveDrawingBuffer,c=void 0!==e.powerPreference?e.powerPreference:"default",h=void 0!==e.failIfMajorPerformanceCaveat&&e.failIfMajorPerformanceCaveat;let u;u=null!==r?r.getContextAttributes().alpha:void 0!==e.alpha&&e.alpha;let d=null,g=null;const x=[],y=[];this.domElement=t,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.outputEncoding=Dt,this.physicallyCorrectLights=!1,this.toneMapping=Q,this.toneMappingExposure=1,Object.defineProperties(this,{gammaFactor:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."),2},set:function(){console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")}}});const _=this;let b=!1,M=0,S=0,w=null,T=-1,A=null;const C=new Vector4,E=new Vector4;let L=null,P=t.width,R=t.height,D=1,I=null,B=null;const V=new Vector4(0,0,P,R),N=new Vector4(0,0,P,R);let O=!1;const z=new Frustum;let F=!1,G=!1,U=null;const k=new Matrix4,W=new Vector2,H=new Vector3,j={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function getTargetPixelRatio(){return null===w?D:1}let q,X,Y,Z,J,K,$,ee,te,ie,re,ne,se,ae,oe,le,ce,he,ue,de,pe,me,fe,ge,ve=r;function getContext(e,i){for(let r=0;r<e.length;r++){const n=e[r],s=t.getContext(n,i);if(null!==s)return s}return null}try{const e={alpha:!0,depth:n,stencil:s,antialias:a,premultipliedAlpha:o,preserveDrawingBuffer:l,powerPreference:c,failIfMajorPerformanceCaveat:h};if("setAttribute"in t&&t.setAttribute("data-engine",`three.js r${i}`),t.addEventListener("webglcontextlost",onContextLost,!1),t.addEventListener("webglcontextrestored",onContextRestore,!1),t.addEventListener("webglcontextcreationerror",onContextCreationError,!1),null===ve){const t=["webgl2","webgl","experimental-webgl"];if(!0===_.isWebGL1Renderer&&t.shift(),ve=getContext(t,e),null===ve)throw getContext(t)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}void 0===ve.getShaderPrecisionFormat&&(ve.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(Me){throw console.error("THREE.WebGLRenderer: "+Me.message),Me}function initGLContext(){q=new WebGLExtensions(ve),X=new WebGLCapabilities(ve,q,e),q.init(X),me=new WebGLUtils(ve,q,X),Y=new WebGLState(ve,q,X),Z=new WebGLInfo,J=new WebGLProperties,K=new WebGLTextures(ve,q,Y,J,X,me,Z),$=new WebGLCubeMaps(_),ee=new WebGLCubeUVMaps(_),te=new WebGLAttributes(ve,X),fe=new WebGLBindingStates(ve,q,te,X),ie=new WebGLGeometries(ve,te,Z,fe),re=new WebGLObjects(ve,ie,te,Z),ue=new WebGLMorphtargets(ve,X,K),le=new WebGLClipping(J),ne=new WebGLPrograms(_,$,ee,q,X,fe,le),se=new WebGLMaterials(_,J),ae=new WebGLRenderLists,oe=new WebGLRenderStates(q,X),he=new WebGLBackground(_,$,Y,re,u,o),ce=new WebGLShadowMap(_,re,X),ge=new WebGLUniformsGroups(ve,Z,X,Y),de=new WebGLBufferRenderer(ve,q,Z,X),pe=new WebGLIndexedBufferRenderer(ve,q,Z,X),Z.programs=ne.programs,_.capabilities=X,_.extensions=q,_.properties=J,_.renderLists=ae,_.shadowMap=ce,_.state=Y,_.info=Z}initGLContext();const xe=new WebXRManager(_,ve);function onContextLost(e){e.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),b=!0}function onContextRestore(){console.log("THREE.WebGLRenderer: Context Restored."),b=!1;const e=Z.autoReset,t=ce.enabled,i=ce.autoUpdate,r=ce.needsUpdate,n=ce.type;initGLContext(),Z.autoReset=e,ce.enabled=t,ce.autoUpdate=i,ce.needsUpdate=r,ce.type=n}function onContextCreationError(e){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",e.statusMessage)}function onMaterialDispose(e){const t=e.target;t.removeEventListener("dispose",onMaterialDispose),function deallocateMaterial(e){(function releaseMaterialProgramReferences(e){const t=J.get(e).programs;void 0!==t&&(t.forEach((function(e){ne.releaseProgram(e)})),e.isShaderMaterial&&ne.releaseShaderCache(e))})(e),J.remove(e)}(t)}this.xr=xe,this.getContext=function(){return ve},this.getContextAttributes=function(){return ve.getContextAttributes()},this.forceContextLoss=function(){const e=q.get("WEBGL_lose_context");e&&e.loseContext()},this.forceContextRestore=function(){const e=q.get("WEBGL_lose_context");e&&e.restoreContext()},this.getPixelRatio=function(){return D},this.setPixelRatio=function(e){void 0!==e&&(D=e,this.setSize(P,R,!1))},this.getSize=function(e){return e.set(P,R)},this.setSize=function(e,i,r){xe.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):(P=e,R=i,t.width=Math.floor(e*D),t.height=Math.floor(i*D),!1!==r&&(t.style.width=e+"px",t.style.height=i+"px"),this.setViewport(0,0,e,i))},this.getDrawingBufferSize=function(e){return e.set(P*D,R*D).floor()},this.setDrawingBufferSize=function(e,i,r){P=e,R=i,D=r,t.width=Math.floor(e*r),t.height=Math.floor(i*r),this.setViewport(0,0,e,i)},this.getCurrentViewport=function(e){return e.copy(C)},this.getViewport=function(e){return e.copy(V)},this.setViewport=function(e,t,i,r){e.isVector4?V.set(e.x,e.y,e.z,e.w):V.set(e,t,i,r),Y.viewport(C.copy(V).multiplyScalar(D).floor())},this.getScissor=function(e){return e.copy(N)},this.setScissor=function(e,t,i,r){e.isVector4?N.set(e.x,e.y,e.z,e.w):N.set(e,t,i,r),Y.scissor(E.copy(N).multiplyScalar(D).floor())},this.getScissorTest=function(){return O},this.setScissorTest=function(e){Y.setScissorTest(O=e)},this.setOpaqueSort=function(e){I=e},this.setTransparentSort=function(e){B=e},this.getClearColor=function(e){return e.copy(he.getClearColor())},this.setClearColor=function(){he.setClearColor.apply(he,arguments)},this.getClearAlpha=function(){return he.getClearAlpha()},this.setClearAlpha=function(){he.setClearAlpha.apply(he,arguments)},this.clear=function(e=!0,t=!0,i=!0){let r=0;e&&(r|=16384),t&&(r|=256),i&&(r|=1024),ve.clear(r)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",onContextLost,!1),t.removeEventListener("webglcontextrestored",onContextRestore,!1),t.removeEventListener("webglcontextcreationerror",onContextCreationError,!1),ae.dispose(),oe.dispose(),J.dispose(),$.dispose(),ee.dispose(),re.dispose(),fe.dispose(),ge.dispose(),ne.dispose(),xe.dispose(),xe.removeEventListener("sessionstart",onXRSessionStart),xe.removeEventListener("sessionend",onXRSessionEnd),U&&(U.dispose(),U=null),_e.stop()},this.renderBufferDirect=function(e,t,i,r,n,s){null===t&&(t=j);const a=n.isMesh&&n.matrixWorld.determinant()<0,o=function setProgram(e,t,i,r,n){!0!==t.isScene&&(t=j);K.resetTextureUnits();const s=t.fog,a=r.isMeshStandardMaterial?t.environment:null,o=null===w?_.outputEncoding:!0===w.isXRRenderTarget?w.texture.encoding:Dt,l=(r.isMeshStandardMaterial?ee:$).get(r.envMap||a),c=!0===r.vertexColors&&!!i.attributes.color&&4===i.attributes.color.itemSize,h=!!r.normalMap&&!!i.attributes.tangent,u=!!i.morphAttributes.position,d=!!i.morphAttributes.normal,p=!!i.morphAttributes.color,m=r.toneMapped?_.toneMapping:Q,f=i.morphAttributes.position||i.morphAttributes.normal||i.morphAttributes.color,x=void 0!==f?f.length:0,y=J.get(r),b=g.state.lights;if(!0===F&&(!0===G||e!==A)){const t=e===A&&r.id===T;le.setState(r,e,t)}let M=!1;r.version===y.__version?y.needsLights&&y.lightsStateVersion!==b.state.version||y.outputEncoding!==o||n.isInstancedMesh&&!1===y.instancing?M=!0:n.isInstancedMesh||!0!==y.instancing?n.isSkinnedMesh&&!1===y.skinning?M=!0:n.isSkinnedMesh||!0!==y.skinning?y.envMap!==l||!0===r.fog&&y.fog!==s?M=!0:void 0===y.numClippingPlanes||y.numClippingPlanes===le.numPlanes&&y.numIntersection===le.numIntersection?(y.vertexAlphas!==c||y.vertexTangents!==h||y.morphTargets!==u||y.morphNormals!==d||y.morphColors!==p||y.toneMapping!==m||!0===X.isWebGL2&&y.morphTargetsCount!==x)&&(M=!0):M=!0:M=!0:M=!0:(M=!0,y.__version=r.version);let S=y.currentProgram;!0===M&&(S=getProgram(r,t,n));let C=!1,E=!1,L=!1;const P=S.getUniforms(),I=y.uniforms;Y.useProgram(S.program)&&(C=!0,E=!0,L=!0);r.id!==T&&(T=r.id,E=!0);if(C||A!==e){if(P.setValue(ve,"projectionMatrix",e.projectionMatrix),X.logarithmicDepthBuffer&&P.setValue(ve,"logDepthBufFC",2/(Math.log(e.far+1)/Math.LN2)),A!==e&&(A=e,E=!0,L=!0),r.isShaderMaterial||r.isMeshPhongMaterial||r.isMeshToonMaterial||r.isMeshStandardMaterial||r.envMap){const t=P.map.cameraPosition;void 0!==t&&t.setValue(ve,H.setFromMatrixPosition(e.matrixWorld))}(r.isMeshPhongMaterial||r.isMeshToonMaterial||r.isMeshLambertMaterial||r.isMeshBasicMaterial||r.isMeshStandardMaterial||r.isShaderMaterial)&&P.setValue(ve,"isOrthographic",!0===e.isOrthographicCamera),(r.isMeshPhongMaterial||r.isMeshToonMaterial||r.isMeshLambertMaterial||r.isMeshBasicMaterial||r.isMeshStandardMaterial||r.isShaderMaterial||r.isShadowMaterial||n.isSkinnedMesh)&&P.setValue(ve,"viewMatrix",e.matrixWorldInverse)}if(n.isSkinnedMesh){P.setOptional(ve,n,"bindMatrix"),P.setOptional(ve,n,"bindMatrixInverse");const e=n.skeleton;e&&(X.floatVertexTextures?(null===e.boneTexture&&e.computeBoneTexture(),P.setValue(ve,"boneTexture",e.boneTexture,K),P.setValue(ve,"boneTextureSize",e.boneTextureSize)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}const B=i.morphAttributes;(void 0!==B.position||void 0!==B.normal||void 0!==B.color&&!0===X.isWebGL2)&&ue.update(n,i,r,S);(E||y.receiveShadow!==n.receiveShadow)&&(y.receiveShadow=n.receiveShadow,P.setValue(ve,"receiveShadow",n.receiveShadow));E&&(P.setValue(ve,"toneMappingExposure",_.toneMappingExposure),y.needsLights&&function markUniformsLightsNeedsUpdate(e,t){e.ambientLightColor.needsUpdate=t,e.lightProbe.needsUpdate=t,e.directionalLights.needsUpdate=t,e.directionalLightShadows.needsUpdate=t,e.pointLights.needsUpdate=t,e.pointLightShadows.needsUpdate=t,e.spotLights.needsUpdate=t,e.spotLightShadows.needsUpdate=t,e.rectAreaLights.needsUpdate=t,e.hemisphereLights.needsUpdate=t}(I,L),s&&!0===r.fog&&se.refreshFogUniforms(I,s),se.refreshMaterialUniforms(I,r,D,R,U),WebGLUniforms.upload(ve,y.uniformsList,I,K));r.isShaderMaterial&&!0===r.uniformsNeedUpdate&&(WebGLUniforms.upload(ve,y.uniformsList,I,K),r.uniformsNeedUpdate=!1);r.isSpriteMaterial&&P.setValue(ve,"center",n.center);if(P.setValue(ve,"modelViewMatrix",n.modelViewMatrix),P.setValue(ve,"normalMatrix",n.normalMatrix),P.setValue(ve,"modelMatrix",n.matrixWorld),r.isShaderMaterial||r.isRawShaderMaterial){const e=r.uniformsGroups;for(let t=0,i=e.length;t<i;t++)if(X.isWebGL2){const i=e[t];ge.update(i,S),ge.bind(i,S)}else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")}return S}(e,t,i,r,n);Y.setMaterial(r,a);let l=i.index;const c=i.attributes.position;if(null===l){if(void 0===c||0===c.count)return}else if(0===l.count)return;let h,u=1;!0===r.wireframe&&(l=ie.getWireframeAttribute(i),u=2),fe.setup(n,r,o,i,l);let d=de;null!==l&&(h=te.get(l),d=pe,d.setIndex(h));const p=null!==l?l.count:c.count,m=i.drawRange.start*u,f=i.drawRange.count*u,x=null!==s?s.start*u:0,y=null!==s?s.count*u:1/0,b=Math.max(m,x),M=Math.min(p,m+f,x+y)-1,S=Math.max(0,M-b+1);if(0!==S){if(n.isMesh)!0===r.wireframe?(Y.setLineWidth(r.wireframeLinewidth*getTargetPixelRatio()),d.setMode(1)):d.setMode(4);else if(n.isLine){let e=r.linewidth;void 0===e&&(e=1),Y.setLineWidth(e*getTargetPixelRatio()),n.isLineSegments?d.setMode(1):n.isLineLoop?d.setMode(2):d.setMode(3)}else n.isPoints?d.setMode(0):n.isSprite&&d.setMode(4);if(n.isInstancedMesh)d.renderInstances(b,S,n.count);else if(i.isInstancedBufferGeometry){const e=Math.min(i.instanceCount,i._maxInstanceCount);d.renderInstances(b,S,e)}else d.render(b,S)}},this.compile=function(e,t){g=oe.get(e),g.init(),y.push(g),e.traverseVisible((function(e){e.isLight&&e.layers.test(t.layers)&&(g.pushLight(e),e.castShadow&&g.pushShadow(e))})),g.setupLights(_.physicallyCorrectLights),e.traverse((function(t){const i=t.material;if(i)if(Array.isArray(i))for(let r=0;r<i.length;r++){getProgram(i[r],e,t)}else getProgram(i,e,t)})),y.pop(),g=null};let ye=null;function onXRSessionStart(){_e.stop()}function onXRSessionEnd(){_e.start()}const _e=new WebGLAnimation;function projectObject(e,t,i,r){if(!1===e.visible)return;if(e.layers.test(t.layers))if(e.isGroup)i=e.renderOrder;else if(e.isLOD)!0===e.autoUpdate&&e.update(t);else if(e.isLight)g.pushLight(e),e.castShadow&&g.pushShadow(e);else if(e.isSprite){if(!e.frustumCulled||z.intersectsSprite(e)){r&&H.setFromMatrixPosition(e.matrixWorld).applyMatrix4(k);const t=re.update(e),n=e.material;n.visible&&d.push(e,t,n,i,H.z,null)}}else if((e.isMesh||e.isLine||e.isPoints)&&(e.isSkinnedMesh&&e.skeleton.frame!==Z.render.frame&&(e.skeleton.update(),e.skeleton.frame=Z.render.frame),!e.frustumCulled||z.intersectsObject(e))){r&&H.setFromMatrixPosition(e.matrixWorld).applyMatrix4(k);const t=re.update(e),n=e.material;if(Array.isArray(n)){const r=t.groups;for(let s=0,a=r.length;s<a;s++){const a=r[s],o=n[a.materialIndex];o&&o.visible&&d.push(e,t,o,i,H.z,a)}}else n.visible&&d.push(e,t,n,i,H.z,null)}const n=e.children;for(let s=0,a=n.length;s<a;s++)projectObject(n[s],t,i,r)}function renderScene(e,t,i,r){const n=e.opaque,s=e.transmissive,o=e.transparent;g.setupLightsView(i),s.length>0&&function renderTransmissionPass(e,t,i){const r=X.isWebGL2;null===U&&(U=new WebGLRenderTarget(1,1,{generateMipmaps:!0,type:q.has("EXT_color_buffer_half_float")?Pe:Se,minFilter:be,samples:r&&!0===a?4:0}));_.getDrawingBufferSize(W),r?U.setSize(W.x,W.y):U.setSize(floorPowerOfTwo(W.x),floorPowerOfTwo(W.y));const n=_.getRenderTarget();_.setRenderTarget(U),_.clear();const s=_.toneMapping;_.toneMapping=Q,renderObjects(e,t,i),_.toneMapping=s,K.updateMultisampleRenderTarget(U),K.updateRenderTargetMipmap(U),_.setRenderTarget(n)}(n,t,i),r&&Y.viewport(C.copy(r)),n.length>0&&renderObjects(n,t,i),s.length>0&&renderObjects(s,t,i),o.length>0&&renderObjects(o,t,i),Y.buffers.depth.setTest(!0),Y.buffers.depth.setMask(!0),Y.buffers.color.setMask(!0),Y.setPolygonOffset(!1)}function renderObjects(e,t,i){const r=!0===t.isScene?t.overrideMaterial:null;for(let n=0,s=e.length;n<s;n++){const s=e[n],a=s.object,o=s.geometry,l=null===r?s.material:r,c=s.group;a.layers.test(i.layers)&&renderObject(a,t,i,o,l,c)}}function renderObject(e,t,i,r,n,s){e.onBeforeRender(_,t,i,r,n,s),e.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse,e.matrixWorld),e.normalMatrix.getNormalMatrix(e.modelViewMatrix),n.onBeforeRender(_,t,i,r,e,s),!0===n.transparent&&n.side===f?(n.side=m,n.needsUpdate=!0,_.renderBufferDirect(i,t,r,n,e,s),n.side=p,n.needsUpdate=!0,_.renderBufferDirect(i,t,r,n,e,s),n.side=f):_.renderBufferDirect(i,t,r,n,e,s),e.onAfterRender(_,t,i,r,n,s)}function getProgram(e,t,i){!0!==t.isScene&&(t=j);const r=J.get(e),n=g.state.lights,s=g.state.shadowsArray,a=n.state.version,o=ne.getParameters(e,n.state,s,t,i),l=ne.getProgramCacheKey(o);let c=r.programs;r.environment=e.isMeshStandardMaterial?t.environment:null,r.fog=t.fog,r.envMap=(e.isMeshStandardMaterial?ee:$).get(e.envMap||r.environment),void 0===c&&(e.addEventListener("dispose",onMaterialDispose),c=new Map,r.programs=c);let h=c.get(l);if(void 0!==h){if(r.currentProgram===h&&r.lightsStateVersion===a)return updateCommonMaterialProperties(e,o),h}else o.uniforms=ne.getUniforms(e),e.onBuild(i,o,_),e.onBeforeCompile(o,_),h=ne.acquireProgram(o,l),c.set(l,h),r.uniforms=o.uniforms;const u=r.uniforms;(e.isShaderMaterial||e.isRawShaderMaterial)&&!0!==e.clipping||(u.clippingPlanes=le.uniform),updateCommonMaterialProperties(e,o),r.needsLights=function materialNeedsLights(e){return e.isMeshLambertMaterial||e.isMeshToonMaterial||e.isMeshPhongMaterial||e.isMeshStandardMaterial||e.isShadowMaterial||e.isShaderMaterial&&!0===e.lights}(e),r.lightsStateVersion=a,r.needsLights&&(u.ambientLightColor.value=n.state.ambient,u.lightProbe.value=n.state.probe,u.directionalLights.value=n.state.directional,u.directionalLightShadows.value=n.state.directionalShadow,u.spotLights.value=n.state.spot,u.spotLightShadows.value=n.state.spotShadow,u.rectAreaLights.value=n.state.rectArea,u.ltc_1.value=n.state.rectAreaLTC1,u.ltc_2.value=n.state.rectAreaLTC2,u.pointLights.value=n.state.point,u.pointLightShadows.value=n.state.pointShadow,u.hemisphereLights.value=n.state.hemi,u.directionalShadowMap.value=n.state.directionalShadowMap,u.directionalShadowMatrix.value=n.state.directionalShadowMatrix,u.spotShadowMap.value=n.state.spotShadowMap,u.spotShadowMatrix.value=n.state.spotShadowMatrix,u.pointShadowMap.value=n.state.pointShadowMap,u.pointShadowMatrix.value=n.state.pointShadowMatrix);const d=h.getUniforms(),p=WebGLUniforms.seqWithValue(d.seq,u);return r.currentProgram=h,r.uniformsList=p,h}function updateCommonMaterialProperties(e,t){const i=J.get(e);i.outputEncoding=t.outputEncoding,i.instancing=t.instancing,i.skinning=t.skinning,i.morphTargets=t.morphTargets,i.morphNormals=t.morphNormals,i.morphColors=t.morphColors,i.morphTargetsCount=t.morphTargetsCount,i.numClippingPlanes=t.numClippingPlanes,i.numIntersection=t.numClipIntersection,i.vertexAlphas=t.vertexAlphas,i.vertexTangents=t.vertexTangents,i.toneMapping=t.toneMapping}_e.setAnimationLoop((function onAnimationFrame(e){ye&&ye(e)})),"undefined"!==typeof self&&_e.setContext(self),this.setAnimationLoop=function(e){ye=e,xe.setAnimationLoop(e),null===e?_e.stop():_e.start()},xe.addEventListener("sessionstart",onXRSessionStart),xe.addEventListener("sessionend",onXRSessionEnd),this.render=function(e,t){if(void 0!==t&&!0!==t.isCamera)return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");if(!0===b)return;!0===e.autoUpdate&&e.updateMatrixWorld(),null===t.parent&&t.updateMatrixWorld(),!0===xe.enabled&&!0===xe.isPresenting&&(!0===xe.cameraAutoUpdate&&xe.updateCamera(t),t=xe.getCamera()),!0===e.isScene&&e.onBeforeRender(_,e,t,w),g=oe.get(e,y.length),g.init(),y.push(g),k.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),z.setFromProjectionMatrix(k),G=this.localClippingEnabled,F=le.init(this.clippingPlanes,G,t),d=ae.get(e,x.length),d.init(),x.push(d),projectObject(e,t,0,_.sortObjects),d.finish(),!0===_.sortObjects&&d.sort(I,B),!0===F&&le.beginShadows();const i=g.state.shadowsArray;if(ce.render(i,e,t),!0===F&&le.endShadows(),!0===this.info.autoReset&&this.info.reset(),he.render(d,e),g.setupLights(_.physicallyCorrectLights),t.isArrayCamera){const i=t.cameras;for(let t=0,r=i.length;t<r;t++){const r=i[t];renderScene(d,e,r,r.viewport)}}else renderScene(d,e,t);null!==w&&(K.updateMultisampleRenderTarget(w),K.updateRenderTargetMipmap(w)),!0===e.isScene&&e.onAfterRender(_,e,t),fe.resetDefaultState(),T=-1,A=null,y.pop(),g=y.length>0?y[y.length-1]:null,x.pop(),d=x.length>0?x[x.length-1]:null},this.getActiveCubeFace=function(){return M},this.getActiveMipmapLevel=function(){return S},this.getRenderTarget=function(){return w},this.setRenderTargetTextures=function(e,t,i){J.get(e.texture).__webglTexture=t,J.get(e.depthTexture).__webglTexture=i;const r=J.get(e);r.__hasExternalTextures=!0,r.__hasExternalTextures&&(r.__autoAllocateDepthBuffer=void 0===i,r.__autoAllocateDepthBuffer||!0===q.has("WEBGL_multisampled_render_to_texture")&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),r.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(e,t){const i=J.get(e);i.__webglFramebuffer=t,i.__useDefaultFramebuffer=void 0===t},this.setRenderTarget=function(e,t=0,i=0){w=e,M=t,S=i;let r=!0;if(e){const t=J.get(e);void 0!==t.__useDefaultFramebuffer?(Y.bindFramebuffer(36160,null),r=!1):void 0===t.__webglFramebuffer?K.setupRenderTarget(e):t.__hasExternalTextures&&K.rebindTextures(e,J.get(e.texture).__webglTexture,J.get(e.depthTexture).__webglTexture)}let n=null,s=!1,a=!1;if(e){const i=e.texture;(i.isData3DTexture||i.isDataArrayTexture)&&(a=!0);const r=J.get(e).__webglFramebuffer;e.isWebGLCubeRenderTarget?(n=r[t],s=!0):n=X.isWebGL2&&e.samples>0&&!1===K.useMultisampledRTT(e)?J.get(e).__webglMultisampledFramebuffer:r,C.copy(e.viewport),E.copy(e.scissor),L=e.scissorTest}else C.copy(V).multiplyScalar(D).floor(),E.copy(N).multiplyScalar(D).floor(),L=O;if(Y.bindFramebuffer(36160,n)&&X.drawBuffers&&r&&Y.drawBuffers(e,n),Y.viewport(C),Y.scissor(E),Y.setScissorTest(L),s){const r=J.get(e.texture);ve.framebufferTexture2D(36160,36064,34069+t,r.__webglTexture,i)}else if(a){const r=J.get(e.texture),n=t||0;ve.framebufferTextureLayer(36160,36064,r.__webglTexture,i||0,n)}T=-1},this.readRenderTargetPixels=function(e,t,i,r,n,s,a){if(!e||!e.isWebGLRenderTarget)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let o=J.get(e).__webglFramebuffer;if(e.isWebGLCubeRenderTarget&&void 0!==a&&(o=o[a]),o){Y.bindFramebuffer(36160,o);try{const a=e.texture,o=a.format,l=a.type;if(o!==Ne&&me.convert(o)!==ve.getParameter(35739))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");const c=l===Pe&&(q.has("EXT_color_buffer_half_float")||X.isWebGL2&&q.has("EXT_color_buffer_float"));if(l!==Se&&me.convert(l)!==ve.getParameter(35738)&&(l!==Le||!(X.isWebGL2||q.has("OES_texture_float")||q.has("WEBGL_color_buffer_float")))&&!c)return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");t>=0&&t<=e.width-r&&i>=0&&i<=e.height-n&&ve.readPixels(t,i,r,n,me.convert(o),me.convert(l),s)}finally{const e=null!==w?J.get(w).__webglFramebuffer:null;Y.bindFramebuffer(36160,e)}}},this.copyFramebufferToTexture=function(e,t,i=0){const r=Math.pow(2,-i),n=Math.floor(t.image.width*r),s=Math.floor(t.image.height*r);K.setTexture2D(t,0),ve.copyTexSubImage2D(3553,i,0,0,e.x,e.y,n,s),Y.unbindTexture()},this.copyTextureToTexture=function(e,t,i,r=0){const n=t.image.width,s=t.image.height,a=me.convert(i.format),o=me.convert(i.type);K.setTexture2D(i,0),ve.pixelStorei(37440,i.flipY),ve.pixelStorei(37441,i.premultiplyAlpha),ve.pixelStorei(3317,i.unpackAlignment),t.isDataTexture?ve.texSubImage2D(3553,r,e.x,e.y,n,s,a,o,t.image.data):t.isCompressedTexture?ve.compressedTexSubImage2D(3553,r,e.x,e.y,t.mipmaps[0].width,t.mipmaps[0].height,a,t.mipmaps[0].data):ve.texSubImage2D(3553,r,e.x,e.y,a,o,t.image),0===r&&i.generateMipmaps&&ve.generateMipmap(3553),Y.unbindTexture()},this.copyTextureToTexture3D=function(e,t,i,r,n=0){if(_.isWebGL1Renderer)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");const s=e.max.x-e.min.x+1,a=e.max.y-e.min.y+1,o=e.max.z-e.min.z+1,l=me.convert(r.format),c=me.convert(r.type);let h;if(r.isData3DTexture)K.setTexture3D(r,0),h=32879;else{if(!r.isDataArrayTexture)return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");K.setTexture2DArray(r,0),h=35866}ve.pixelStorei(37440,r.flipY),ve.pixelStorei(37441,r.premultiplyAlpha),ve.pixelStorei(3317,r.unpackAlignment);const u=ve.getParameter(3314),d=ve.getParameter(32878),p=ve.getParameter(3316),m=ve.getParameter(3315),f=ve.getParameter(32877),g=i.isCompressedTexture?i.mipmaps[0]:i.image;ve.pixelStorei(3314,g.width),ve.pixelStorei(32878,g.height),ve.pixelStorei(3316,e.min.x),ve.pixelStorei(3315,e.min.y),ve.pixelStorei(32877,e.min.z),i.isDataTexture||i.isData3DTexture?ve.texSubImage3D(h,n,t.x,t.y,t.z,s,a,o,l,c,g.data):i.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),ve.compressedTexSubImage3D(h,n,t.x,t.y,t.z,s,a,o,l,g.data)):ve.texSubImage3D(h,n,t.x,t.y,t.z,s,a,o,l,c,g),ve.pixelStorei(3314,u),ve.pixelStorei(32878,d),ve.pixelStorei(3316,p),ve.pixelStorei(3315,m),ve.pixelStorei(32877,f),0===n&&r.generateMipmaps&&ve.generateMipmap(h),Y.unbindTexture()},this.initTexture=function(e){e.isCubeTexture?K.setTextureCube(e,0):e.isData3DTexture?K.setTexture3D(e,0):e.isDataArrayTexture?K.setTexture2DArray(e,0):K.setTexture2D(e,0),Y.unbindTexture()},this.resetState=function(){M=0,S=0,w=null,Y.reset(),fe.reset()},"undefined"!==typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}class WebGL1Renderer extends WebGLRenderer{}WebGL1Renderer.prototype.isWebGL1Renderer=!0;class FogExp2{constructor(e,t=25e-5){this.isFogExp2=!0,this.name="",this.color=new Color(e),this.density=t}clone(){return new FogExp2(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}class Fog{constructor(e,t=1,i=1e3){this.isFog=!0,this.name="",this.color=new Color(e),this.near=t,this.far=i}clone(){return new Fog(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}class Scene extends Object3D{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,"undefined"!==typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),null!==e.background&&(this.background=e.background.clone()),null!==e.environment&&(this.environment=e.environment.clone()),null!==e.fog&&(this.fog=e.fog.clone()),null!==e.overrideMaterial&&(this.overrideMaterial=e.overrideMaterial.clone()),this.autoUpdate=e.autoUpdate,this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return null!==this.fog&&(t.object.fog=this.fog.toJSON()),t}}class InterleavedBuffer{constructor(e,t){this.isInterleavedBuffer=!0,this.array=e,this.stride=t,this.count=void 0!==e?e.length/t:0,this.usage=ri,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=generateUUID()}onUploadCallback(){}set needsUpdate(e){!0===e&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,i){e*=this.stride,i*=t.stride;for(let r=0,n=this.stride;r<n;r++)this.array[e+r]=t.array[i+r];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){void 0===e.arrayBuffers&&(e.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=generateUUID()),void 0===e.arrayBuffers[this.array.buffer._uuid]&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),i=new this.constructor(t,this.stride);return i.setUsage(this.usage),i}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return void 0===e.arrayBuffers&&(e.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=generateUUID()),void 0===e.arrayBuffers[this.array.buffer._uuid]&&(e.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const jn=new Vector3;class InterleavedBufferAttribute{constructor(e,t,i,r=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=e,this.itemSize=t,this.offset=i,this.normalized=!0===r}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,i=this.data.count;t<i;t++)jn.fromBufferAttribute(this,t),jn.applyMatrix4(e),this.setXYZ(t,jn.x,jn.y,jn.z);return this}applyNormalMatrix(e){for(let t=0,i=this.count;t<i;t++)jn.fromBufferAttribute(this,t),jn.applyNormalMatrix(e),this.setXYZ(t,jn.x,jn.y,jn.z);return this}transformDirection(e){for(let t=0,i=this.count;t<i;t++)jn.fromBufferAttribute(this,t),jn.transformDirection(e),this.setXYZ(t,jn.x,jn.y,jn.z);return this}setX(e,t){return this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){return this.data.array[e*this.data.stride+this.offset]}getY(e){return this.data.array[e*this.data.stride+this.offset+1]}getZ(e){return this.data.array[e*this.data.stride+this.offset+2]}getW(e){return this.data.array[e*this.data.stride+this.offset+3]}setXY(e,t,i){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=i,this}setXYZ(e,t,i,r){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=i,this.data.array[e+2]=r,this}setXYZW(e,t,i,r,n){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=i,this.data.array[e+2]=r,this.data.array[e+3]=n,this}clone(e){if(void 0===e){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will deinterleave buffer data.");const e=[];for(let t=0;t<this.count;t++){const i=t*this.data.stride+this.offset;for(let t=0;t<this.itemSize;t++)e.push(this.data.array[i+t])}return new BufferAttribute(new this.array.constructor(e),this.itemSize,this.normalized)}return void 0===e.interleavedBuffers&&(e.interleavedBuffers={}),void 0===e.interleavedBuffers[this.data.uuid]&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new InterleavedBufferAttribute(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(void 0===e){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will deinterleave buffer data.");const e=[];for(let t=0;t<this.count;t++){const i=t*this.data.stride+this.offset;for(let t=0;t<this.itemSize;t++)e.push(this.data.array[i+t])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}return void 0===e.interleavedBuffers&&(e.interleavedBuffers={}),void 0===e.interleavedBuffers[this.data.uuid]&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class SpriteMaterial extends Material{constructor(e){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new Color(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}let qn;const Xn=new Vector3,Yn=new Vector3,Zn=new Vector3,Jn=new Vector2,Kn=new Vector2,Qn=new Matrix4,$n=new Vector3,es=new Vector3,ts=new Vector3,is=new Vector2,rs=new Vector2,ns=new Vector2;class Sprite extends Object3D{constructor(e){if(super(),this.isSprite=!0,this.type="Sprite",void 0===qn){qn=new BufferGeometry;const e=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),t=new InterleavedBuffer(e,5);qn.setIndex([0,1,2,0,2,3]),qn.setAttribute("position",new InterleavedBufferAttribute(t,3,0,!1)),qn.setAttribute("uv",new InterleavedBufferAttribute(t,2,3,!1))}this.geometry=qn,this.material=void 0!==e?e:new SpriteMaterial,this.center=new Vector2(.5,.5)}raycast(e,t){null===e.camera&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Yn.setFromMatrixScale(this.matrixWorld),Qn.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),Zn.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&Yn.multiplyScalar(-Zn.z);const i=this.material.rotation;let r,n;0!==i&&(n=Math.cos(i),r=Math.sin(i));const s=this.center;transformVertex($n.set(-.5,-.5,0),Zn,s,Yn,r,n),transformVertex(es.set(.5,-.5,0),Zn,s,Yn,r,n),transformVertex(ts.set(.5,.5,0),Zn,s,Yn,r,n),is.set(0,0),rs.set(1,0),ns.set(1,1);let a=e.ray.intersectTriangle($n,es,ts,!1,Xn);if(null===a&&(transformVertex(es.set(-.5,.5,0),Zn,s,Yn,r,n),rs.set(0,1),a=e.ray.intersectTriangle($n,ts,es,!1,Xn),null===a))return;const o=e.ray.origin.distanceTo(Xn);o<e.near||o>e.far||t.push({distance:o,point:Xn.clone(),uv:Triangle.getUV(Xn,$n,es,ts,is,rs,ns,new Vector2),face:null,object:this})}copy(e,t){return super.copy(e,t),void 0!==e.center&&this.center.copy(e.center),this.material=e.material,this}}function transformVertex(e,t,i,r,n,s){Jn.subVectors(e,i).addScalar(.5).multiply(r),void 0!==n?(Kn.x=s*Jn.x-n*Jn.y,Kn.y=n*Jn.x+s*Jn.y):Kn.copy(Jn),e.copy(t),e.x+=Kn.x,e.y+=Kn.y,e.applyMatrix4(Qn)}const ss=new Vector3,as=new Vector3;class LOD extends Object3D{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(e){super.copy(e,!1);const t=e.levels;for(let i=0,r=t.length;i<r;i++){const e=t[i];this.addLevel(e.object.clone(),e.distance)}return this.autoUpdate=e.autoUpdate,this}addLevel(e,t=0){t=Math.abs(t);const i=this.levels;let r;for(r=0;r<i.length&&!(t<i[r].distance);r++);return i.splice(r,0,{distance:t,object:e}),this.add(e),this}getCurrentLevel(){return this._currentLevel}getObjectForDistance(e){const t=this.levels;if(t.length>0){let i,r;for(i=1,r=t.length;i<r&&!(e<t[i].distance);i++);return t[i-1].object}return null}raycast(e,t){if(this.levels.length>0){ss.setFromMatrixPosition(this.matrixWorld);const i=e.ray.origin.distanceTo(ss);this.getObjectForDistance(i).raycast(e,t)}}update(e){const t=this.levels;if(t.length>1){ss.setFromMatrixPosition(e.matrixWorld),as.setFromMatrixPosition(this.matrixWorld);const i=ss.distanceTo(as)/e.zoom;let r,n;for(t[0].object.visible=!0,r=1,n=t.length;r<n&&i>=t[r].distance;r++)t[r-1].object.visible=!1,t[r].object.visible=!0;for(this._currentLevel=r-1;r<n;r++)t[r].object.visible=!1}}toJSON(e){const t=super.toJSON(e);!1===this.autoUpdate&&(t.object.autoUpdate=!1),t.object.levels=[];const i=this.levels;for(let r=0,n=i.length;r<n;r++){const e=i[r];t.object.levels.push({object:e.object.uuid,distance:e.distance})}return t}}const os=new Vector3,ls=new Vector4,cs=new Vector4,hs=new Vector3,us=new Matrix4;class SkinnedMesh extends Mesh{constructor(e,t){super(e,t),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Matrix4,this.bindMatrixInverse=new Matrix4}copy(e,t){return super.copy(e,t),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,this}bind(e,t){this.skeleton=e,void 0===t&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new Vector4,t=this.geometry.attributes.skinWeight;for(let i=0,r=t.count;i<r;i++){e.fromBufferAttribute(t,i);const r=1/e.manhattanLength();r!==1/0?e.multiplyScalar(r):e.set(1,0,0,0),t.setXYZW(i,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),"attached"===this.bindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():"detached"===this.bindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(e,t){const i=this.skeleton,r=this.geometry;ls.fromBufferAttribute(r.attributes.skinIndex,e),cs.fromBufferAttribute(r.attributes.skinWeight,e),os.copy(t).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let n=0;n<4;n++){const e=cs.getComponent(n);if(0!==e){const r=ls.getComponent(n);us.multiplyMatrices(i.bones[r].matrixWorld,i.boneInverses[r]),t.addScaledVector(hs.copy(os).applyMatrix4(us),e)}}return t.applyMatrix4(this.bindMatrixInverse)}}class Bone extends Object3D{constructor(){super(),this.isBone=!0,this.type="Bone"}}class DataTexture extends Texture{constructor(e=null,t=1,i=1,r,n,s,a,o,l=pe,c=pe,h,u){super(null,s,a,o,l,c,r,n,h,u),this.isDataTexture=!0,this.image={data:e,width:t,height:i},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const ds=new Matrix4,ps=new Matrix4;class Skeleton{constructor(e=[],t=[]){this.uuid=generateUUID(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}init(){const e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(16*e.length),0===t.length)this.calculateInverses();else if(e.length!==t.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let e=0,t=this.bones.length;e<t;e++)this.boneInverses.push(new Matrix4)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const t=new Matrix4;this.bones[e]&&t.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(t)}}pose(){for(let e=0,t=this.bones.length;e<t;e++){const t=this.bones[e];t&&t.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const t=this.bones[e];t&&(t.parent&&t.parent.isBone?(t.matrix.copy(t.parent.matrixWorld).invert(),t.matrix.multiply(t.matrixWorld)):t.matrix.copy(t.matrixWorld),t.matrix.decompose(t.position,t.quaternion,t.scale))}}update(){const e=this.bones,t=this.boneInverses,i=this.boneMatrices,r=this.boneTexture;for(let n=0,s=e.length;n<s;n++){const r=e[n]?e[n].matrixWorld:ps;ds.multiplyMatrices(r,t[n]),ds.toArray(i,16*n)}null!==r&&(r.needsUpdate=!0)}clone(){return new Skeleton(this.bones,this.boneInverses)}computeBoneTexture(){let e=Math.sqrt(4*this.bones.length);e=ceilPowerOfTwo(e),e=Math.max(e,4);const t=new Float32Array(e*e*4);t.set(this.boneMatrices);const i=new DataTexture(t,e,e,Ne,Le);return i.needsUpdate=!0,this.boneMatrices=t,this.boneTexture=i,this.boneTextureSize=e,this}getBoneByName(e){for(let t=0,i=this.bones.length;t<i;t++){const i=this.bones[t];if(i.name===e)return i}}dispose(){null!==this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,t){this.uuid=e.uuid;for(let i=0,r=e.bones.length;i<r;i++){const r=e.bones[i];let n=t[r];void 0===n&&(console.warn("THREE.Skeleton: No bone found with UUID:",r),n=new Bone),this.bones.push(n),this.boneInverses.push((new Matrix4).fromArray(e.boneInverses[i]))}return this.init(),this}toJSON(){const e={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones,i=this.boneInverses;for(let r=0,n=t.length;r<n;r++){const n=t[r];e.bones.push(n.uuid);const s=i[r];e.boneInverses.push(s.toArray())}return e}}class InstancedBufferAttribute extends BufferAttribute{constructor(e,t,i,r=1){"number"===typeof i&&(r=i,i=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),super(e,t,i),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=r}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}const ms=new Matrix4,fs=new Matrix4,gs=[],vs=new Mesh;class InstancedMesh extends Mesh{constructor(e,t,i){super(e,t),this.isInstancedMesh=!0,this.instanceMatrix=new InstancedBufferAttribute(new Float32Array(16*i),16),this.instanceColor=null,this.count=i,this.frustumCulled=!1}copy(e,t){return super.copy(e,t),this.instanceMatrix.copy(e.instanceMatrix),null!==e.instanceColor&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,this}getColorAt(e,t){t.fromArray(this.instanceColor.array,3*e)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,16*e)}raycast(e,t){const i=this.matrixWorld,r=this.count;if(vs.geometry=this.geometry,vs.material=this.material,void 0!==vs.material)for(let n=0;n<r;n++){this.getMatrixAt(n,ms),fs.multiplyMatrices(i,ms),vs.matrixWorld=fs,vs.raycast(e,gs);for(let e=0,i=gs.length;e<i;e++){const i=gs[e];i.instanceId=n,i.object=this,t.push(i)}gs.length=0}}setColorAt(e,t){null===this.instanceColor&&(this.instanceColor=new InstancedBufferAttribute(new Float32Array(3*this.instanceMatrix.count),3)),t.toArray(this.instanceColor.array,3*e)}setMatrixAt(e,t){t.toArray(this.instanceMatrix.array,16*e)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}class LineBasicMaterial extends Material{constructor(e){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new Color(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.fog=e.fog,this}}const xs=new Vector3,ys=new Vector3,_s=new Matrix4,bs=new Ray,Ms=new Sphere;class Line extends Object3D{constructor(e=new BufferGeometry,t=new LineBasicMaterial){super(),this.isLine=!0,this.type="Line",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(null===e.index){const t=e.attributes.position,i=[0];for(let e=1,r=t.count;e<r;e++)xs.fromBufferAttribute(t,e-1),ys.fromBufferAttribute(t,e),i[e]=i[e-1],i[e]+=xs.distanceTo(ys);e.setAttribute("lineDistance",new Float32BufferAttribute(i,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(e,t){const i=this.geometry,r=this.matrixWorld,n=e.params.Line.threshold,s=i.drawRange;if(null===i.boundingSphere&&i.computeBoundingSphere(),Ms.copy(i.boundingSphere),Ms.applyMatrix4(r),Ms.radius+=n,!1===e.ray.intersectsSphere(Ms))return;_s.copy(r).invert(),bs.copy(e.ray).applyMatrix4(_s);const a=n/((this.scale.x+this.scale.y+this.scale.z)/3),o=a*a,l=new Vector3,c=new Vector3,h=new Vector3,u=new Vector3,d=this.isLineSegments?2:1,p=i.index,m=i.attributes.position;if(null!==p){for(let i=Math.max(0,s.start),r=Math.min(p.count,s.start+s.count)-1;i<r;i+=d){const r=p.getX(i),n=p.getX(i+1);l.fromBufferAttribute(m,r),c.fromBufferAttribute(m,n);if(bs.distanceSqToSegment(l,c,u,h)>o)continue;u.applyMatrix4(this.matrixWorld);const s=e.ray.origin.distanceTo(u);s<e.near||s>e.far||t.push({distance:s,point:h.clone().applyMatrix4(this.matrixWorld),index:i,face:null,faceIndex:null,object:this})}}else{for(let i=Math.max(0,s.start),r=Math.min(m.count,s.start+s.count)-1;i<r;i+=d){l.fromBufferAttribute(m,i),c.fromBufferAttribute(m,i+1);if(bs.distanceSqToSegment(l,c,u,h)>o)continue;u.applyMatrix4(this.matrixWorld);const r=e.ray.origin.distanceTo(u);r<e.near||r>e.far||t.push({distance:r,point:h.clone().applyMatrix4(this.matrixWorld),index:i,face:null,faceIndex:null,object:this})}}}updateMorphTargets(){const e=this.geometry.morphAttributes,t=Object.keys(e);if(t.length>0){const i=e[t[0]];if(void 0!==i){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,t=i.length;e<t;e++){const t=i[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[t]=e}}}}}const Ss=new Vector3,ws=new Vector3;class LineSegments extends Line{constructor(e,t){super(e,t),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(null===e.index){const t=e.attributes.position,i=[];for(let e=0,r=t.count;e<r;e+=2)Ss.fromBufferAttribute(t,e),ws.fromBufferAttribute(t,e+1),i[e]=0===e?0:i[e-1],i[e+1]=i[e]+Ss.distanceTo(ws);e.setAttribute("lineDistance",new Float32BufferAttribute(i,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class LineLoop extends Line{constructor(e,t){super(e,t),this.isLineLoop=!0,this.type="LineLoop"}}class PointsMaterial extends Material{constructor(e){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new Color(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}const Ts=new Matrix4,As=new Ray,Cs=new Sphere,Es=new Vector3;class Points extends Object3D{constructor(e=new BufferGeometry,t=new PointsMaterial){super(),this.isPoints=!0,this.type="Points",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=e.material,this.geometry=e.geometry,this}raycast(e,t){const i=this.geometry,r=this.matrixWorld,n=e.params.Points.threshold,s=i.drawRange;if(null===i.boundingSphere&&i.computeBoundingSphere(),Cs.copy(i.boundingSphere),Cs.applyMatrix4(r),Cs.radius+=n,!1===e.ray.intersectsSphere(Cs))return;Ts.copy(r).invert(),As.copy(e.ray).applyMatrix4(Ts);const a=n/((this.scale.x+this.scale.y+this.scale.z)/3),o=a*a,l=i.index,c=i.attributes.position;if(null!==l){for(let i=Math.max(0,s.start),n=Math.min(l.count,s.start+s.count);i<n;i++){const n=l.getX(i);Es.fromBufferAttribute(c,n),testPoint(Es,n,o,r,e,t,this)}}else{for(let i=Math.max(0,s.start),n=Math.min(c.count,s.start+s.count);i<n;i++)Es.fromBufferAttribute(c,i),testPoint(Es,i,o,r,e,t,this)}}updateMorphTargets(){const e=this.geometry.morphAttributes,t=Object.keys(e);if(t.length>0){const i=e[t[0]];if(void 0!==i){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let e=0,t=i.length;e<t;e++){const t=i[e].name||String(e);this.morphTargetInfluences.push(0),this.morphTargetDictionary[t]=e}}}}}function testPoint(e,t,i,r,n,s,a){const o=As.distanceSqToPoint(e);if(o<i){const i=new Vector3;As.closestPointToPoint(e,i),i.applyMatrix4(r);const l=n.ray.origin.distanceTo(i);if(l<n.near||l>n.far)return;s.push({distance:l,distanceToRay:Math.sqrt(o),point:i,index:t,face:null,object:a})}}class VideoTexture extends Texture{constructor(e,t,i,r,n,s,a,o,l){super(e,t,i,r,n,s,a,o,l),this.isVideoTexture=!0,this.minFilter=void 0!==s?s:xe,this.magFilter=void 0!==n?n:xe,this.generateMipmaps=!1;const c=this;"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback((function updateVideo(){c.needsUpdate=!0,e.requestVideoFrameCallback(updateVideo)}))}clone(){return new this.constructor(this.image).copy(this)}update(){const e=this.image;!1==="requestVideoFrameCallback"in e&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}class FramebufferTexture extends Texture{constructor(e,t,i){super({width:e,height:t}),this.isFramebufferTexture=!0,this.format=i,this.magFilter=pe,this.minFilter=pe,this.generateMipmaps=!1,this.needsUpdate=!0}}class CompressedTexture extends Texture{constructor(e,t,i,r,n,s,a,o,l,c,h,u){super(null,s,a,o,l,c,r,n,h,u),this.isCompressedTexture=!0,this.image={width:t,height:i},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}}class CanvasTexture extends Texture{constructor(e,t,i,r,n,s,a,o,l){super(e,t,i,r,n,s,a,o,l),this.isCanvasTexture=!0,this.needsUpdate=!0}}class Curve{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(e,t){const i=this.getUtoTmapping(e);return this.getPoint(i,t)}getPoints(e=5){const t=[];for(let i=0;i<=e;i++)t.push(this.getPoint(i/e));return t}getSpacedPoints(e=5){const t=[];for(let i=0;i<=e;i++)t.push(this.getPointAt(i/e));return t}getLength(){const e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let i,r=this.getPoint(0),n=0;t.push(0);for(let s=1;s<=e;s++)i=this.getPoint(s/e),n+=i.distanceTo(r),t.push(n),r=i;return this.cacheArcLengths=t,t}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,t){const i=this.getLengths();let r=0;const n=i.length;let s;s=t||e*i[n-1];let a,o=0,l=n-1;for(;o<=l;)if(r=Math.floor(o+(l-o)/2),a=i[r]-s,a<0)o=r+1;else{if(!(a>0)){l=r;break}l=r-1}if(r=l,i[r]===s)return r/(n-1);const c=i[r];return(r+(s-c)/(i[r+1]-c))/(n-1)}getTangent(e,t){const i=1e-4;let r=e-i,n=e+i;r<0&&(r=0),n>1&&(n=1);const s=this.getPoint(r),a=this.getPoint(n),o=t||(s.isVector2?new Vector2:new Vector3);return o.copy(a).sub(s).normalize(),o}getTangentAt(e,t){const i=this.getUtoTmapping(e);return this.getTangent(i,t)}computeFrenetFrames(e,t){const i=new Vector3,r=[],n=[],s=[],a=new Vector3,o=new Matrix4;for(let d=0;d<=e;d++){const t=d/e;r[d]=this.getTangentAt(t,new Vector3)}n[0]=new Vector3,s[0]=new Vector3;let l=Number.MAX_VALUE;const c=Math.abs(r[0].x),h=Math.abs(r[0].y),u=Math.abs(r[0].z);c<=l&&(l=c,i.set(1,0,0)),h<=l&&(l=h,i.set(0,1,0)),u<=l&&i.set(0,0,1),a.crossVectors(r[0],i).normalize(),n[0].crossVectors(r[0],a),s[0].crossVectors(r[0],n[0]);for(let d=1;d<=e;d++){if(n[d]=n[d-1].clone(),s[d]=s[d-1].clone(),a.crossVectors(r[d-1],r[d]),a.length()>Number.EPSILON){a.normalize();const e=Math.acos(clamp(r[d-1].dot(r[d]),-1,1));n[d].applyMatrix4(o.makeRotationAxis(a,e))}s[d].crossVectors(r[d],n[d])}if(!0===t){let t=Math.acos(clamp(n[0].dot(n[e]),-1,1));t/=e,r[0].dot(a.crossVectors(n[0],n[e]))>0&&(t=-t);for(let i=1;i<=e;i++)n[i].applyMatrix4(o.makeRotationAxis(r[i],t*i)),s[i].crossVectors(r[i],n[i])}return{tangents:r,normals:n,binormals:s}}clone(){return(new this.constructor).copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){const e={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}class EllipseCurve extends Curve{constructor(e=0,t=0,i=1,r=1,n=0,s=2*Math.PI,a=!1,o=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=e,this.aY=t,this.xRadius=i,this.yRadius=r,this.aStartAngle=n,this.aEndAngle=s,this.aClockwise=a,this.aRotation=o}getPoint(e,t){const i=t||new Vector2,r=2*Math.PI;let n=this.aEndAngle-this.aStartAngle;const s=Math.abs(n)<Number.EPSILON;for(;n<0;)n+=r;for(;n>r;)n-=r;n<Number.EPSILON&&(n=s?0:r),!0!==this.aClockwise||s||(n===r?n=-r:n-=r);const a=this.aStartAngle+e*n;let o=this.aX+this.xRadius*Math.cos(a),l=this.aY+this.yRadius*Math.sin(a);if(0!==this.aRotation){const e=Math.cos(this.aRotation),t=Math.sin(this.aRotation),i=o-this.aX,r=l-this.aY;o=i*e-r*t+this.aX,l=i*t+r*e+this.aY}return i.set(o,l)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){const e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}}class ArcCurve extends EllipseCurve{constructor(e,t,i,r,n,s){super(e,t,i,i,r,n,s),this.isArcCurve=!0,this.type="ArcCurve"}}function CubicPoly(){let e=0,t=0,i=0,r=0;function init(n,s,a,o){e=n,t=a,i=-3*n+3*s-2*a-o,r=2*n-2*s+a+o}return{initCatmullRom:function(e,t,i,r,n){init(t,i,n*(i-e),n*(r-t))},initNonuniformCatmullRom:function(e,t,i,r,n,s,a){let o=(t-e)/n-(i-e)/(n+s)+(i-t)/s,l=(i-t)/s-(r-t)/(s+a)+(r-i)/a;o*=s,l*=s,init(t,i,o,l)},calc:function(n){const s=n*n;return e+t*n+i*s+r*(s*n)}}}const Ls=new Vector3,Ps=new CubicPoly,Rs=new CubicPoly,Ds=new CubicPoly;class CatmullRomCurve3 extends Curve{constructor(e=[],t=!1,i="centripetal",r=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=e,this.closed=t,this.curveType=i,this.tension=r}getPoint(e,t=new Vector3){const i=t,r=this.points,n=r.length,s=(n-(this.closed?0:1))*e;let a,o,l=Math.floor(s),c=s-l;this.closed?l+=l>0?0:(Math.floor(Math.abs(l)/n)+1)*n:0===c&&l===n-1&&(l=n-2,c=1),this.closed||l>0?a=r[(l-1)%n]:(Ls.subVectors(r[0],r[1]).add(r[0]),a=Ls);const h=r[l%n],u=r[(l+1)%n];if(this.closed||l+2<n?o=r[(l+2)%n]:(Ls.subVectors(r[n-1],r[n-2]).add(r[n-1]),o=Ls),"centripetal"===this.curveType||"chordal"===this.curveType){const e="chordal"===this.curveType?.5:.25;let t=Math.pow(a.distanceToSquared(h),e),i=Math.pow(h.distanceToSquared(u),e),r=Math.pow(u.distanceToSquared(o),e);i<1e-4&&(i=1),t<1e-4&&(t=i),r<1e-4&&(r=i),Ps.initNonuniformCatmullRom(a.x,h.x,u.x,o.x,t,i,r),Rs.initNonuniformCatmullRom(a.y,h.y,u.y,o.y,t,i,r),Ds.initNonuniformCatmullRom(a.z,h.z,u.z,o.z,t,i,r)}else"catmullrom"===this.curveType&&(Ps.initCatmullRom(a.x,h.x,u.x,o.x,this.tension),Rs.initCatmullRom(a.y,h.y,u.y,o.y,this.tension),Ds.initCatmullRom(a.z,h.z,u.z,o.z,this.tension));return i.set(Ps.calc(c),Rs.calc(c),Ds.calc(c)),i}copy(e){super.copy(e),this.points=[];for(let t=0,i=e.points.length;t<i;t++){const i=e.points[t];this.points.push(i.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,i=this.points.length;t<i;t++){const i=this.points[t];e.points.push(i.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,i=e.points.length;t<i;t++){const i=e.points[t];this.points.push((new Vector3).fromArray(i))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}}function CatmullRom(e,t,i,r,n){const s=.5*(r-t),a=.5*(n-i),o=e*e;return(2*i-2*r+s+a)*(e*o)+(-3*i+3*r-2*s-a)*o+s*e+i}function QuadraticBezier(e,t,i,r){return function QuadraticBezierP0(e,t){const i=1-e;return i*i*t}(e,t)+function QuadraticBezierP1(e,t){return 2*(1-e)*e*t}(e,i)+function QuadraticBezierP2(e,t){return e*e*t}(e,r)}function CubicBezier(e,t,i,r,n){return function CubicBezierP0(e,t){const i=1-e;return i*i*i*t}(e,t)+function CubicBezierP1(e,t){const i=1-e;return 3*i*i*e*t}(e,i)+function CubicBezierP2(e,t){return 3*(1-e)*e*e*t}(e,r)+function CubicBezierP3(e,t){return e*e*e*t}(e,n)}class CubicBezierCurve extends Curve{constructor(e=new Vector2,t=new Vector2,i=new Vector2,r=new Vector2){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=i,this.v3=r}getPoint(e,t=new Vector2){const i=t,r=this.v0,n=this.v1,s=this.v2,a=this.v3;return i.set(CubicBezier(e,r.x,n.x,s.x,a.x),CubicBezier(e,r.y,n.y,s.y,a.y)),i}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class CubicBezierCurve3 extends Curve{constructor(e=new Vector3,t=new Vector3,i=new Vector3,r=new Vector3){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=e,this.v1=t,this.v2=i,this.v3=r}getPoint(e,t=new Vector3){const i=t,r=this.v0,n=this.v1,s=this.v2,a=this.v3;return i.set(CubicBezier(e,r.x,n.x,s.x,a.x),CubicBezier(e,r.y,n.y,s.y,a.y),CubicBezier(e,r.z,n.z,s.z,a.z)),i}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class LineCurve extends Curve{constructor(e=new Vector2,t=new Vector2){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=e,this.v2=t}getPoint(e,t=new Vector2){const i=t;return 1===e?i.copy(this.v2):(i.copy(this.v2).sub(this.v1),i.multiplyScalar(e).add(this.v1)),i}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t){const i=t||new Vector2;return i.copy(this.v2).sub(this.v1).normalize(),i}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class LineCurve3 extends Curve{constructor(e=new Vector3,t=new Vector3){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=e,this.v2=t}getPoint(e,t=new Vector3){const i=t;return 1===e?i.copy(this.v2):(i.copy(this.v2).sub(this.v1),i.multiplyScalar(e).add(this.v1)),i}getPointAt(e,t){return this.getPoint(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class QuadraticBezierCurve extends Curve{constructor(e=new Vector2,t=new Vector2,i=new Vector2){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=e,this.v1=t,this.v2=i}getPoint(e,t=new Vector2){const i=t,r=this.v0,n=this.v1,s=this.v2;return i.set(QuadraticBezier(e,r.x,n.x,s.x),QuadraticBezier(e,r.y,n.y,s.y)),i}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class QuadraticBezierCurve3 extends Curve{constructor(e=new Vector3,t=new Vector3,i=new Vector3){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=e,this.v1=t,this.v2=i}getPoint(e,t=new Vector3){const i=t,r=this.v0,n=this.v1,s=this.v2;return i.set(QuadraticBezier(e,r.x,n.x,s.x),QuadraticBezier(e,r.y,n.y,s.y),QuadraticBezier(e,r.z,n.z,s.z)),i}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class SplineCurve extends Curve{constructor(e=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=e}getPoint(e,t=new Vector2){const i=t,r=this.points,n=(r.length-1)*e,s=Math.floor(n),a=n-s,o=r[0===s?s:s-1],l=r[s],c=r[s>r.length-2?r.length-1:s+1],h=r[s>r.length-3?r.length-1:s+2];return i.set(CatmullRom(a,o.x,l.x,c.x,h.x),CatmullRom(a,o.y,l.y,c.y,h.y)),i}copy(e){super.copy(e),this.points=[];for(let t=0,i=e.points.length;t<i;t++){const i=e.points[t];this.points.push(i.clone())}return this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,i=this.points.length;t<i;t++){const i=this.points[t];e.points.push(i.toArray())}return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,i=e.points.length;t<i;t++){const i=e.points[t];this.points.push((new Vector2).fromArray(i))}return this}}var Is=Object.freeze({__proto__:null,ArcCurve:ArcCurve,CatmullRomCurve3:CatmullRomCurve3,CubicBezierCurve:CubicBezierCurve,CubicBezierCurve3:CubicBezierCurve3,EllipseCurve:EllipseCurve,LineCurve:LineCurve,LineCurve3:LineCurve3,QuadraticBezierCurve:QuadraticBezierCurve,QuadraticBezierCurve3:QuadraticBezierCurve3,SplineCurve:SplineCurve});class CurvePath extends Curve{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){const e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);e.equals(t)||this.curves.push(new LineCurve(t,e))}getPoint(e,t){const i=e*this.getLength(),r=this.getCurveLengths();let n=0;for(;n<r.length;){if(r[n]>=i){const e=r[n]-i,s=this.curves[n],a=s.getLength(),o=0===a?0:1-e/a;return s.getPointAt(o,t)}n++}return null}getLength(){const e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let t=0;for(let i=0,r=this.curves.length;i<r;i++)t+=this.curves[i].getLength(),e.push(t);return this.cacheLengths=e,e}getSpacedPoints(e=40){const t=[];for(let i=0;i<=e;i++)t.push(this.getPoint(i/e));return this.autoClose&&t.push(t[0]),t}getPoints(e=12){const t=[];let i;for(let r=0,n=this.curves;r<n.length;r++){const s=n[r],a=s.isEllipseCurve?2*e:s.isLineCurve||s.isLineCurve3?1:s.isSplineCurve?e*s.points.length:e,o=s.getPoints(a);for(let e=0;e<o.length;e++){const r=o[e];i&&i.equals(r)||(t.push(r),i=r)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t}copy(e){super.copy(e),this.curves=[];for(let t=0,i=e.curves.length;t<i;t++){const i=e.curves[t];this.curves.push(i.clone())}return this.autoClose=e.autoClose,this}toJSON(){const e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let t=0,i=this.curves.length;t<i;t++){const i=this.curves[t];e.curves.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,i=e.curves.length;t<i;t++){const i=e.curves[t];this.curves.push((new Is[i.type]).fromJSON(i))}return this}}class Path extends CurvePath{constructor(e){super(),this.type="Path",this.currentPoint=new Vector2,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let t=1,i=e.length;t<i;t++)this.lineTo(e[t].x,e[t].y);return this}moveTo(e,t){return this.currentPoint.set(e,t),this}lineTo(e,t){const i=new LineCurve(this.currentPoint.clone(),new Vector2(e,t));return this.curves.push(i),this.currentPoint.set(e,t),this}quadraticCurveTo(e,t,i,r){const n=new QuadraticBezierCurve(this.currentPoint.clone(),new Vector2(e,t),new Vector2(i,r));return this.curves.push(n),this.currentPoint.set(i,r),this}bezierCurveTo(e,t,i,r,n,s){const a=new CubicBezierCurve(this.currentPoint.clone(),new Vector2(e,t),new Vector2(i,r),new Vector2(n,s));return this.curves.push(a),this.currentPoint.set(n,s),this}splineThru(e){const t=[this.currentPoint.clone()].concat(e),i=new SplineCurve(t);return this.curves.push(i),this.currentPoint.copy(e[e.length-1]),this}arc(e,t,i,r,n,s){const a=this.currentPoint.x,o=this.currentPoint.y;return this.absarc(e+a,t+o,i,r,n,s),this}absarc(e,t,i,r,n,s){return this.absellipse(e,t,i,i,r,n,s),this}ellipse(e,t,i,r,n,s,a,o){const l=this.currentPoint.x,c=this.currentPoint.y;return this.absellipse(e+l,t+c,i,r,n,s,a,o),this}absellipse(e,t,i,r,n,s,a,o){const l=new EllipseCurve(e,t,i,r,n,s,a,o);if(this.curves.length>0){const e=l.getPoint(0);e.equals(this.currentPoint)||this.lineTo(e.x,e.y)}this.curves.push(l);const c=l.getPoint(1);return this.currentPoint.copy(c),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){const e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class LatheGeometry extends BufferGeometry{constructor(e=[new Vector2(0,-.5),new Vector2(.5,0),new Vector2(0,.5)],t=12,i=0,r=2*Math.PI){super(),this.type="LatheGeometry",this.parameters={points:e,segments:t,phiStart:i,phiLength:r},t=Math.floor(t),r=clamp(r,0,2*Math.PI);const n=[],s=[],a=[],o=[],l=[],c=1/t,h=new Vector3,u=new Vector2,d=new Vector3,p=new Vector3,m=new Vector3;let f=0,g=0;for(let x=0;x<=e.length-1;x++)switch(x){case 0:f=e[x+1].x-e[x].x,g=e[x+1].y-e[x].y,d.x=1*g,d.y=-f,d.z=0*g,m.copy(d),d.normalize(),o.push(d.x,d.y,d.z);break;case e.length-1:o.push(m.x,m.y,m.z);break;default:f=e[x+1].x-e[x].x,g=e[x+1].y-e[x].y,d.x=1*g,d.y=-f,d.z=0*g,p.copy(d),d.x+=m.x,d.y+=m.y,d.z+=m.z,d.normalize(),o.push(d.x,d.y,d.z),m.copy(p)}for(let x=0;x<=t;x++){const n=i+x*c*r,d=Math.sin(n),p=Math.cos(n);for(let i=0;i<=e.length-1;i++){h.x=e[i].x*d,h.y=e[i].y,h.z=e[i].x*p,s.push(h.x,h.y,h.z),u.x=x/t,u.y=i/(e.length-1),a.push(u.x,u.y);const r=o[3*i+0]*d,n=o[3*i+1],c=o[3*i+0]*p;l.push(r,n,c)}}for(let x=0;x<t;x++)for(let t=0;t<e.length-1;t++){const i=t+x*e.length,r=i,s=i+e.length,a=i+e.length+1,o=i+1;n.push(r,s,o),n.push(a,o,s)}this.setIndex(n),this.setAttribute("position",new Float32BufferAttribute(s,3)),this.setAttribute("uv",new Float32BufferAttribute(a,2)),this.setAttribute("normal",new Float32BufferAttribute(l,3))}static fromJSON(e){return new LatheGeometry(e.points,e.segments,e.phiStart,e.phiLength)}}class CapsuleGeometry extends LatheGeometry{constructor(e=1,t=1,i=4,r=8){const n=new Path;n.absarc(0,-t/2,e,1.5*Math.PI,0),n.absarc(0,t/2,e,0,.5*Math.PI),super(n.getPoints(i),r),this.type="CapsuleGeometry",this.parameters={radius:e,height:t,capSegments:i,radialSegments:r}}static fromJSON(e){return new CapsuleGeometry(e.radius,e.length,e.capSegments,e.radialSegments)}}class CircleGeometry extends BufferGeometry{constructor(e=1,t=8,i=0,r=2*Math.PI){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:t,thetaStart:i,thetaLength:r},t=Math.max(3,t);const n=[],s=[],a=[],o=[],l=new Vector3,c=new Vector2;s.push(0,0,0),a.push(0,0,1),o.push(.5,.5);for(let h=0,u=3;h<=t;h++,u+=3){const n=i+h/t*r;l.x=e*Math.cos(n),l.y=e*Math.sin(n),s.push(l.x,l.y,l.z),a.push(0,0,1),c.x=(s[u]/e+1)/2,c.y=(s[u+1]/e+1)/2,o.push(c.x,c.y)}for(let h=1;h<=t;h++)n.push(h,h+1,0);this.setIndex(n),this.setAttribute("position",new Float32BufferAttribute(s,3)),this.setAttribute("normal",new Float32BufferAttribute(a,3)),this.setAttribute("uv",new Float32BufferAttribute(o,2))}static fromJSON(e){return new CircleGeometry(e.radius,e.segments,e.thetaStart,e.thetaLength)}}class CylinderGeometry extends BufferGeometry{constructor(e=1,t=1,i=1,r=8,n=1,s=!1,a=0,o=2*Math.PI){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:i,radialSegments:r,heightSegments:n,openEnded:s,thetaStart:a,thetaLength:o};const l=this;r=Math.floor(r),n=Math.floor(n);const c=[],h=[],u=[],d=[];let p=0;const m=[],f=i/2;let g=0;function generateCap(i){const n=p,s=new Vector2,m=new Vector3;let x=0;const y=!0===i?e:t,_=!0===i?1:-1;for(let e=1;e<=r;e++)h.push(0,f*_,0),u.push(0,_,0),d.push(.5,.5),p++;const b=p;for(let e=0;e<=r;e++){const t=e/r*o+a,i=Math.cos(t),n=Math.sin(t);m.x=y*n,m.y=f*_,m.z=y*i,h.push(m.x,m.y,m.z),u.push(0,_,0),s.x=.5*i+.5,s.y=.5*n*_+.5,d.push(s.x,s.y),p++}for(let e=0;e<r;e++){const t=n+e,r=b+e;!0===i?c.push(r,r+1,t):c.push(r+1,r,t),x+=3}l.addGroup(g,x,!0===i?1:2),g+=x}!function generateTorso(){const s=new Vector3,x=new Vector3;let y=0;const _=(t-e)/i;for(let l=0;l<=n;l++){const c=[],g=l/n,y=g*(t-e)+e;for(let e=0;e<=r;e++){const t=e/r,n=t*o+a,l=Math.sin(n),m=Math.cos(n);x.x=y*l,x.y=-g*i+f,x.z=y*m,h.push(x.x,x.y,x.z),s.set(l,_,m).normalize(),u.push(s.x,s.y,s.z),d.push(t,1-g),c.push(p++)}m.push(c)}for(let e=0;e<r;e++)for(let t=0;t<n;t++){const i=m[t][e],r=m[t+1][e],n=m[t+1][e+1],s=m[t][e+1];c.push(i,r,s),c.push(r,n,s),y+=6}l.addGroup(g,y,0),g+=y}(),!1===s&&(e>0&&generateCap(!0),t>0&&generateCap(!1)),this.setIndex(c),this.setAttribute("position",new Float32BufferAttribute(h,3)),this.setAttribute("normal",new Float32BufferAttribute(u,3)),this.setAttribute("uv",new Float32BufferAttribute(d,2))}static fromJSON(e){return new CylinderGeometry(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class ConeGeometry extends CylinderGeometry{constructor(e=1,t=1,i=8,r=1,n=!1,s=0,a=2*Math.PI){super(0,e,t,i,r,n,s,a),this.type="ConeGeometry",this.parameters={radius:e,height:t,radialSegments:i,heightSegments:r,openEnded:n,thetaStart:s,thetaLength:a}}static fromJSON(e){return new ConeGeometry(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class PolyhedronGeometry extends BufferGeometry{constructor(e=[],t=[],i=1,r=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:t,radius:i,detail:r};const n=[],s=[];function subdivideFace(e,t,i,r){const n=r+1,s=[];for(let a=0;a<=n;a++){s[a]=[];const r=e.clone().lerp(i,a/n),o=t.clone().lerp(i,a/n),l=n-a;for(let e=0;e<=l;e++)s[a][e]=0===e&&a===n?r:r.clone().lerp(o,e/l)}for(let a=0;a<n;a++)for(let e=0;e<2*(n-a)-1;e++){const t=Math.floor(e/2);e%2===0?(pushVertex(s[a][t+1]),pushVertex(s[a+1][t]),pushVertex(s[a][t])):(pushVertex(s[a][t+1]),pushVertex(s[a+1][t+1]),pushVertex(s[a+1][t]))}}function pushVertex(e){n.push(e.x,e.y,e.z)}function getVertexByIndex(t,i){const r=3*t;i.x=e[r+0],i.y=e[r+1],i.z=e[r+2]}function correctUV(e,t,i,r){r<0&&1===e.x&&(s[t]=e.x-1),0===i.x&&0===i.z&&(s[t]=r/2/Math.PI+.5)}function azimuth(e){return Math.atan2(e.z,-e.x)}!function subdivide(e){const i=new Vector3,r=new Vector3,n=new Vector3;for(let s=0;s<t.length;s+=3)getVertexByIndex(t[s+0],i),getVertexByIndex(t[s+1],r),getVertexByIndex(t[s+2],n),subdivideFace(i,r,n,e)}(r),function applyRadius(e){const t=new Vector3;for(let i=0;i<n.length;i+=3)t.x=n[i+0],t.y=n[i+1],t.z=n[i+2],t.normalize().multiplyScalar(e),n[i+0]=t.x,n[i+1]=t.y,n[i+2]=t.z}(i),function generateUVs(){const e=new Vector3;for(let i=0;i<n.length;i+=3){e.x=n[i+0],e.y=n[i+1],e.z=n[i+2];const r=azimuth(e)/2/Math.PI+.5,a=(t=e,Math.atan2(-t.y,Math.sqrt(t.x*t.x+t.z*t.z))/Math.PI+.5);s.push(r,1-a)}var t;(function correctUVs(){const e=new Vector3,t=new Vector3,i=new Vector3,r=new Vector3,a=new Vector2,o=new Vector2,l=new Vector2;for(let c=0,h=0;c<n.length;c+=9,h+=6){e.set(n[c+0],n[c+1],n[c+2]),t.set(n[c+3],n[c+4],n[c+5]),i.set(n[c+6],n[c+7],n[c+8]),a.set(s[h+0],s[h+1]),o.set(s[h+2],s[h+3]),l.set(s[h+4],s[h+5]),r.copy(e).add(t).add(i).divideScalar(3);const u=azimuth(r);correctUV(a,h+0,e,u),correctUV(o,h+2,t,u),correctUV(l,h+4,i,u)}})(),function correctSeam(){for(let e=0;e<s.length;e+=6){const t=s[e+0],i=s[e+2],r=s[e+4],n=Math.max(t,i,r),a=Math.min(t,i,r);n>.9&&a<.1&&(t<.2&&(s[e+0]+=1),i<.2&&(s[e+2]+=1),r<.2&&(s[e+4]+=1))}}()}(),this.setAttribute("position",new Float32BufferAttribute(n,3)),this.setAttribute("normal",new Float32BufferAttribute(n.slice(),3)),this.setAttribute("uv",new Float32BufferAttribute(s,2)),0===r?this.computeVertexNormals():this.normalizeNormals()}static fromJSON(e){return new PolyhedronGeometry(e.vertices,e.indices,e.radius,e.details)}}class DodecahedronGeometry extends PolyhedronGeometry{constructor(e=1,t=0){const i=(1+Math.sqrt(5))/2,r=1/i;super([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-r,-i,0,-r,i,0,r,-i,0,r,i,-r,-i,0,-r,i,0,r,-i,0,r,i,0,-i,0,-r,i,0,-r,-i,0,r,i,0,r],[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],e,t),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new DodecahedronGeometry(e.radius,e.detail)}}const Bs=new Vector3,Vs=new Vector3,Ns=new Vector3,Os=new Triangle;class EdgesGeometry extends BufferGeometry{constructor(e=null,t=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:e,thresholdAngle:t},null!==e){const i=4,r=Math.pow(10,i),n=Math.cos(vi*t),s=e.getIndex(),a=e.getAttribute("position"),o=s?s.count:a.count,l=[0,0,0],c=["a","b","c"],h=new Array(3),u={},d=[];for(let e=0;e<o;e+=3){s?(l[0]=s.getX(e),l[1]=s.getX(e+1),l[2]=s.getX(e+2)):(l[0]=e,l[1]=e+1,l[2]=e+2);const{a:t,b:i,c:o}=Os;if(t.fromBufferAttribute(a,l[0]),i.fromBufferAttribute(a,l[1]),o.fromBufferAttribute(a,l[2]),Os.getNormal(Ns),h[0]=`${Math.round(t.x*r)},${Math.round(t.y*r)},${Math.round(t.z*r)}`,h[1]=`${Math.round(i.x*r)},${Math.round(i.y*r)},${Math.round(i.z*r)}`,h[2]=`${Math.round(o.x*r)},${Math.round(o.y*r)},${Math.round(o.z*r)}`,h[0]!==h[1]&&h[1]!==h[2]&&h[2]!==h[0])for(let e=0;e<3;e++){const t=(e+1)%3,i=h[e],r=h[t],s=Os[c[e]],a=Os[c[t]],o=`${i}_${r}`,p=`${r}_${i}`;p in u&&u[p]?(Ns.dot(u[p].normal)<=n&&(d.push(s.x,s.y,s.z),d.push(a.x,a.y,a.z)),u[p]=null):o in u||(u[o]={index0:l[e],index1:l[t],normal:Ns.clone()})}}for(const e in u)if(u[e]){const{index0:t,index1:i}=u[e];Bs.fromBufferAttribute(a,t),Vs.fromBufferAttribute(a,i),d.push(Bs.x,Bs.y,Bs.z),d.push(Vs.x,Vs.y,Vs.z)}this.setAttribute("position",new Float32BufferAttribute(d,3))}}}class Shape extends Path{constructor(e){super(e),this.uuid=generateUUID(),this.type="Shape",this.holes=[]}getPointsHoles(e){const t=[];for(let i=0,r=this.holes.length;i<r;i++)t[i]=this.holes[i].getPoints(e);return t}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let t=0,i=e.holes.length;t<i;t++){const i=e.holes[t];this.holes.push(i.clone())}return this}toJSON(){const e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let t=0,i=this.holes.length;t<i;t++){const i=this.holes[t];e.holes.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let t=0,i=e.holes.length;t<i;t++){const i=e.holes[t];this.holes.push((new Path).fromJSON(i))}return this}}const Earcut_triangulate=function(e,t,i=2){const r=t&&t.length,n=r?t[0]*i:e.length;let s=linkedList(e,0,n,i,!0);const a=[];if(!s||s.next===s.prev)return a;let o,l,c,h,u,d,p;if(r&&(s=function eliminateHoles(e,t,i,r){const n=[];let s,a,o,l,c;for(s=0,a=t.length;s<a;s++)o=t[s]*r,l=s<a-1?t[s+1]*r:e.length,c=linkedList(e,o,l,r,!1),c===c.next&&(c.steiner=!0),n.push(getLeftmost(c));for(n.sort(compareX),s=0;s<n.length;s++)eliminateHole(n[s],i),i=filterPoints(i,i.next);return i}(e,t,s,i)),e.length>80*i){o=c=e[0],l=h=e[1];for(let t=i;t<n;t+=i)u=e[t],d=e[t+1],u<o&&(o=u),d<l&&(l=d),u>c&&(c=u),d>h&&(h=d);p=Math.max(c-o,h-l),p=0!==p?1/p:0}return earcutLinked(s,a,i,o,l,p),a};function linkedList(e,t,i,r,n){let s,a;if(n===function signedArea(e,t,i,r){let n=0;for(let s=t,a=i-r;s<i;s+=r)n+=(e[a]-e[s])*(e[s+1]+e[a+1]),a=s;return n}(e,t,i,r)>0)for(s=t;s<i;s+=r)a=insertNode(s,e[s],e[s+1],a);else for(s=i-r;s>=t;s-=r)a=insertNode(s,e[s],e[s+1],a);return a&&equals(a,a.next)&&(removeNode(a),a=a.next),a}function filterPoints(e,t){if(!e)return e;t||(t=e);let i,r=e;do{if(i=!1,r.steiner||!equals(r,r.next)&&0!==area(r.prev,r,r.next))r=r.next;else{if(removeNode(r),r=t=r.prev,r===r.next)break;i=!0}}while(i||r!==t);return t}function earcutLinked(e,t,i,r,n,s,a){if(!e)return;!a&&s&&function indexCurve(e,t,i,r){let n=e;do{null===n.z&&(n.z=zOrder(n.x,n.y,t,i,r)),n.prevZ=n.prev,n.nextZ=n.next,n=n.next}while(n!==e);n.prevZ.nextZ=null,n.prevZ=null,function sortLinked(e){let t,i,r,n,s,a,o,l,c=1;do{for(i=e,e=null,s=null,a=0;i;){for(a++,r=i,o=0,t=0;t<c&&(o++,r=r.nextZ,r);t++);for(l=c;o>0||l>0&&r;)0!==o&&(0===l||!r||i.z<=r.z)?(n=i,i=i.nextZ,o--):(n=r,r=r.nextZ,l--),s?s.nextZ=n:e=n,n.prevZ=s,s=n;i=r}s.nextZ=null,c*=2}while(a>1);return e}(n)}(e,r,n,s);let o,l,c=e;for(;e.prev!==e.next;)if(o=e.prev,l=e.next,s?isEarHashed(e,r,n,s):isEar(e))t.push(o.i/i),t.push(e.i/i),t.push(l.i/i),removeNode(e),e=l.next,c=l.next;else if((e=l)===c){a?1===a?earcutLinked(e=cureLocalIntersections(filterPoints(e),t,i),t,i,r,n,s,2):2===a&&splitEarcut(e,t,i,r,n,s):earcutLinked(filterPoints(e),t,i,r,n,s,1);break}}function isEar(e){const t=e.prev,i=e,r=e.next;if(area(t,i,r)>=0)return!1;let n=e.next.next;for(;n!==e.prev;){if(pointInTriangle(t.x,t.y,i.x,i.y,r.x,r.y,n.x,n.y)&&area(n.prev,n,n.next)>=0)return!1;n=n.next}return!0}function isEarHashed(e,t,i,r){const n=e.prev,s=e,a=e.next;if(area(n,s,a)>=0)return!1;const o=n.x<s.x?n.x<a.x?n.x:a.x:s.x<a.x?s.x:a.x,l=n.y<s.y?n.y<a.y?n.y:a.y:s.y<a.y?s.y:a.y,c=n.x>s.x?n.x>a.x?n.x:a.x:s.x>a.x?s.x:a.x,h=n.y>s.y?n.y>a.y?n.y:a.y:s.y>a.y?s.y:a.y,u=zOrder(o,l,t,i,r),d=zOrder(c,h,t,i,r);let p=e.prevZ,m=e.nextZ;for(;p&&p.z>=u&&m&&m.z<=d;){if(p!==e.prev&&p!==e.next&&pointInTriangle(n.x,n.y,s.x,s.y,a.x,a.y,p.x,p.y)&&area(p.prev,p,p.next)>=0)return!1;if(p=p.prevZ,m!==e.prev&&m!==e.next&&pointInTriangle(n.x,n.y,s.x,s.y,a.x,a.y,m.x,m.y)&&area(m.prev,m,m.next)>=0)return!1;m=m.nextZ}for(;p&&p.z>=u;){if(p!==e.prev&&p!==e.next&&pointInTriangle(n.x,n.y,s.x,s.y,a.x,a.y,p.x,p.y)&&area(p.prev,p,p.next)>=0)return!1;p=p.prevZ}for(;m&&m.z<=d;){if(m!==e.prev&&m!==e.next&&pointInTriangle(n.x,n.y,s.x,s.y,a.x,a.y,m.x,m.y)&&area(m.prev,m,m.next)>=0)return!1;m=m.nextZ}return!0}function cureLocalIntersections(e,t,i){let r=e;do{const n=r.prev,s=r.next.next;!equals(n,s)&&intersects(n,r,r.next,s)&&locallyInside(n,s)&&locallyInside(s,n)&&(t.push(n.i/i),t.push(r.i/i),t.push(s.i/i),removeNode(r),removeNode(r.next),r=e=s),r=r.next}while(r!==e);return filterPoints(r)}function splitEarcut(e,t,i,r,n,s){let a=e;do{let e=a.next.next;for(;e!==a.prev;){if(a.i!==e.i&&isValidDiagonal(a,e)){let o=splitPolygon(a,e);return a=filterPoints(a,a.next),o=filterPoints(o,o.next),earcutLinked(a,t,i,r,n,s),void earcutLinked(o,t,i,r,n,s)}e=e.next}a=a.next}while(a!==e)}function compareX(e,t){return e.x-t.x}function eliminateHole(e,t){if(t=function findHoleBridge(e,t){let i=t;const r=e.x,n=e.y;let s,a=-1/0;do{if(n<=i.y&&n>=i.next.y&&i.next.y!==i.y){const e=i.x+(n-i.y)*(i.next.x-i.x)/(i.next.y-i.y);if(e<=r&&e>a){if(a=e,e===r){if(n===i.y)return i;if(n===i.next.y)return i.next}s=i.x<i.next.x?i:i.next}}i=i.next}while(i!==t);if(!s)return null;if(r===a)return s;const o=s,l=s.x,c=s.y;let h,u=1/0;i=s;do{r>=i.x&&i.x>=l&&r!==i.x&&pointInTriangle(n<c?r:a,n,l,c,n<c?a:r,n,i.x,i.y)&&(h=Math.abs(n-i.y)/(r-i.x),locallyInside(i,e)&&(h<u||h===u&&(i.x>s.x||i.x===s.x&&sectorContainsSector(s,i)))&&(s=i,u=h)),i=i.next}while(i!==o);return s}(e,t),t){const i=splitPolygon(t,e);filterPoints(t,t.next),filterPoints(i,i.next)}}function sectorContainsSector(e,t){return area(e.prev,e,t.prev)<0&&area(t.next,e,e.next)<0}function zOrder(e,t,i,r,n){return(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-i)*n)|e<<8))|e<<4))|e<<2))|e<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-r)*n)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function getLeftmost(e){let t=e,i=e;do{(t.x<i.x||t.x===i.x&&t.y<i.y)&&(i=t),t=t.next}while(t!==e);return i}function pointInTriangle(e,t,i,r,n,s,a,o){return(n-a)*(t-o)-(e-a)*(s-o)>=0&&(e-a)*(r-o)-(i-a)*(t-o)>=0&&(i-a)*(s-o)-(n-a)*(r-o)>=0}function isValidDiagonal(e,t){return e.next.i!==t.i&&e.prev.i!==t.i&&!function intersectsPolygon(e,t){let i=e;do{if(i.i!==e.i&&i.next.i!==e.i&&i.i!==t.i&&i.next.i!==t.i&&intersects(i,i.next,e,t))return!0;i=i.next}while(i!==e);return!1}(e,t)&&(locallyInside(e,t)&&locallyInside(t,e)&&function middleInside(e,t){let i=e,r=!1;const n=(e.x+t.x)/2,s=(e.y+t.y)/2;do{i.y>s!==i.next.y>s&&i.next.y!==i.y&&n<(i.next.x-i.x)*(s-i.y)/(i.next.y-i.y)+i.x&&(r=!r),i=i.next}while(i!==e);return r}(e,t)&&(area(e.prev,e,t.prev)||area(e,t.prev,t))||equals(e,t)&&area(e.prev,e,e.next)>0&&area(t.prev,t,t.next)>0)}function area(e,t,i){return(t.y-e.y)*(i.x-t.x)-(t.x-e.x)*(i.y-t.y)}function equals(e,t){return e.x===t.x&&e.y===t.y}function intersects(e,t,i,r){const n=sign(area(e,t,i)),s=sign(area(e,t,r)),a=sign(area(i,r,e)),o=sign(area(i,r,t));return n!==s&&a!==o||(!(0!==n||!onSegment(e,i,t))||(!(0!==s||!onSegment(e,r,t))||(!(0!==a||!onSegment(i,e,r))||!(0!==o||!onSegment(i,t,r)))))}function onSegment(e,t,i){return t.x<=Math.max(e.x,i.x)&&t.x>=Math.min(e.x,i.x)&&t.y<=Math.max(e.y,i.y)&&t.y>=Math.min(e.y,i.y)}function sign(e){return e>0?1:e<0?-1:0}function locallyInside(e,t){return area(e.prev,e,e.next)<0?area(e,t,e.next)>=0&&area(e,e.prev,t)>=0:area(e,t,e.prev)<0||area(e,e.next,t)<0}function splitPolygon(e,t){const i=new Node(e.i,e.x,e.y),r=new Node(t.i,t.x,t.y),n=e.next,s=t.prev;return e.next=t,t.prev=e,i.next=n,n.prev=i,r.next=i,i.prev=r,s.next=r,r.prev=s,r}function insertNode(e,t,i,r){const n=new Node(e,t,i);return r?(n.next=r.next,n.prev=r,r.next.prev=n,r.next=n):(n.prev=n,n.next=n),n}function removeNode(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function Node(e,t,i){this.i=e,this.x=t,this.y=i,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}class ShapeUtils{static area(e){const t=e.length;let i=0;for(let r=t-1,n=0;n<t;r=n++)i+=e[r].x*e[n].y-e[n].x*e[r].y;return.5*i}static isClockWise(e){return ShapeUtils.area(e)<0}static triangulateShape(e,t){const i=[],r=[],n=[];removeDupEndPts(e),addContour(i,e);let s=e.length;t.forEach(removeDupEndPts);for(let o=0;o<t.length;o++)r.push(s),s+=t[o].length,addContour(i,t[o]);const a=Earcut_triangulate(i,r);for(let o=0;o<a.length;o+=3)n.push(a.slice(o,o+3));return n}}function removeDupEndPts(e){const t=e.length;t>2&&e[t-1].equals(e[0])&&e.pop()}function addContour(e,t){for(let i=0;i<t.length;i++)e.push(t[i].x),e.push(t[i].y)}class ExtrudeGeometry extends BufferGeometry{constructor(e=new Shape([new Vector2(.5,.5),new Vector2(-.5,.5),new Vector2(-.5,-.5),new Vector2(.5,-.5)]),t={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const i=this,r=[],n=[];for(let s=0,a=e.length;s<a;s++){addShape(e[s])}function addShape(e){const s=[],a=void 0!==t.curveSegments?t.curveSegments:12,o=void 0!==t.steps?t.steps:1,l=void 0!==t.depth?t.depth:1;let c=void 0===t.bevelEnabled||t.bevelEnabled,h=void 0!==t.bevelThickness?t.bevelThickness:.2,u=void 0!==t.bevelSize?t.bevelSize:h-.1,d=void 0!==t.bevelOffset?t.bevelOffset:0,p=void 0!==t.bevelSegments?t.bevelSegments:3;const m=t.extrudePath,f=void 0!==t.UVGenerator?t.UVGenerator:zs;let g,x,y,_,b,M=!1;m&&(g=m.getSpacedPoints(o),M=!0,c=!1,x=m.computeFrenetFrames(o,!1),y=new Vector3,_=new Vector3,b=new Vector3),c||(p=0,h=0,u=0,d=0);const S=e.extractPoints(a);let w=S.shape;const T=S.holes;if(!ShapeUtils.isClockWise(w)){w=w.reverse();for(let e=0,t=T.length;e<t;e++){const t=T[e];ShapeUtils.isClockWise(t)&&(T[e]=t.reverse())}}const A=ShapeUtils.triangulateShape(w,T),C=w;for(let t=0,i=T.length;t<i;t++){const e=T[t];w=w.concat(e)}function scalePt2(e,t,i){return t||console.error("THREE.ExtrudeGeometry: vec does not exist"),t.clone().multiplyScalar(i).add(e)}const E=w.length,L=A.length;function getBevelVec(e,t,i){let r,n,s;const a=e.x-t.x,o=e.y-t.y,l=i.x-e.x,c=i.y-e.y,h=a*a+o*o,u=a*c-o*l;if(Math.abs(u)>Number.EPSILON){const u=Math.sqrt(h),d=Math.sqrt(l*l+c*c),p=t.x-o/u,m=t.y+a/u,f=((i.x-c/d-p)*c-(i.y+l/d-m)*l)/(a*c-o*l);r=p+a*f-e.x,n=m+o*f-e.y;const g=r*r+n*n;if(g<=2)return new Vector2(r,n);s=Math.sqrt(g/2)}else{let e=!1;a>Number.EPSILON?l>Number.EPSILON&&(e=!0):a<-Number.EPSILON?l<-Number.EPSILON&&(e=!0):Math.sign(o)===Math.sign(c)&&(e=!0),e?(r=-o,n=a,s=Math.sqrt(h)):(r=a,n=o,s=Math.sqrt(h/2))}return new Vector2(r/s,n/s)}const P=[];for(let t=0,i=C.length,r=i-1,n=t+1;t<i;t++,r++,n++)r===i&&(r=0),n===i&&(n=0),P[t]=getBevelVec(C[t],C[r],C[n]);const R=[];let D,I=P.concat();for(let t=0,i=T.length;t<i;t++){const e=T[t];D=[];for(let t=0,i=e.length,r=i-1,n=t+1;t<i;t++,r++,n++)r===i&&(r=0),n===i&&(n=0),D[t]=getBevelVec(e[t],e[r],e[n]);R.push(D),I=I.concat(D)}for(let t=0;t<p;t++){const e=t/p,i=h*Math.cos(e*Math.PI/2),r=u*Math.sin(e*Math.PI/2)+d;for(let t=0,n=C.length;t<n;t++){const e=scalePt2(C[t],P[t],r);v(e.x,e.y,-i)}for(let t=0,n=T.length;t<n;t++){const e=T[t];D=R[t];for(let t=0,n=e.length;t<n;t++){const n=scalePt2(e[t],D[t],r);v(n.x,n.y,-i)}}}const B=u+d;for(let t=0;t<E;t++){const e=c?scalePt2(w[t],I[t],B):w[t];M?(_.copy(x.normals[0]).multiplyScalar(e.x),y.copy(x.binormals[0]).multiplyScalar(e.y),b.copy(g[0]).add(_).add(y),v(b.x,b.y,b.z)):v(e.x,e.y,0)}for(let t=1;t<=o;t++)for(let e=0;e<E;e++){const i=c?scalePt2(w[e],I[e],B):w[e];M?(_.copy(x.normals[t]).multiplyScalar(i.x),y.copy(x.binormals[t]).multiplyScalar(i.y),b.copy(g[t]).add(_).add(y),v(b.x,b.y,b.z)):v(i.x,i.y,l/o*t)}for(let t=p-1;t>=0;t--){const e=t/p,i=h*Math.cos(e*Math.PI/2),r=u*Math.sin(e*Math.PI/2)+d;for(let t=0,n=C.length;t<n;t++){const e=scalePt2(C[t],P[t],r);v(e.x,e.y,l+i)}for(let t=0,n=T.length;t<n;t++){const e=T[t];D=R[t];for(let t=0,n=e.length;t<n;t++){const n=scalePt2(e[t],D[t],r);M?v(n.x,n.y+g[o-1].y,g[o-1].x+i):v(n.x,n.y,l+i)}}}function sidewalls(e,t){let i=e.length;for(;--i>=0;){const r=i;let n=i-1;n<0&&(n=e.length-1);for(let e=0,i=o+2*p;e<i;e++){const i=E*e,s=E*(e+1);f4(t+r+i,t+n+i,t+n+s,t+r+s)}}}function v(e,t,i){s.push(e),s.push(t),s.push(i)}function f3(e,t,n){addVertex(e),addVertex(t),addVertex(n);const s=r.length/3,a=f.generateTopUV(i,r,s-3,s-2,s-1);addUV(a[0]),addUV(a[1]),addUV(a[2])}function f4(e,t,n,s){addVertex(e),addVertex(t),addVertex(s),addVertex(t),addVertex(n),addVertex(s);const a=r.length/3,o=f.generateSideWallUV(i,r,a-6,a-3,a-2,a-1);addUV(o[0]),addUV(o[1]),addUV(o[3]),addUV(o[1]),addUV(o[2]),addUV(o[3])}function addVertex(e){r.push(s[3*e+0]),r.push(s[3*e+1]),r.push(s[3*e+2])}function addUV(e){n.push(e.x),n.push(e.y)}!function buildLidFaces(){const e=r.length/3;if(c){let e=0,t=E*e;for(let i=0;i<L;i++){const e=A[i];f3(e[2]+t,e[1]+t,e[0]+t)}e=o+2*p,t=E*e;for(let i=0;i<L;i++){const e=A[i];f3(e[0]+t,e[1]+t,e[2]+t)}}else{for(let e=0;e<L;e++){const t=A[e];f3(t[2],t[1],t[0])}for(let e=0;e<L;e++){const t=A[e];f3(t[0]+E*o,t[1]+E*o,t[2]+E*o)}}i.addGroup(e,r.length/3-e,0)}(),function buildSideFaces(){const e=r.length/3;let t=0;sidewalls(C,t),t+=C.length;for(let i=0,r=T.length;i<r;i++){const e=T[i];sidewalls(e,t),t+=e.length}i.addGroup(e,r.length/3-e,1)}()}this.setAttribute("position",new Float32BufferAttribute(r,3)),this.setAttribute("uv",new Float32BufferAttribute(n,2)),this.computeVertexNormals()}toJSON(){const e=super.toJSON();return function toJSON$1(e,t,i){if(i.shapes=[],Array.isArray(e))for(let r=0,n=e.length;r<n;r++){const t=e[r];i.shapes.push(t.uuid)}else i.shapes.push(e.uuid);i.options=Object.assign({},t),void 0!==t.extrudePath&&(i.options.extrudePath=t.extrudePath.toJSON());return i}(this.parameters.shapes,this.parameters.options,e)}static fromJSON(e,t){const i=[];for(let n=0,s=e.shapes.length;n<s;n++){const r=t[e.shapes[n]];i.push(r)}const r=e.options.extrudePath;return void 0!==r&&(e.options.extrudePath=(new Is[r.type]).fromJSON(r)),new ExtrudeGeometry(i,e.options)}}const zs={generateTopUV:function(e,t,i,r,n){const s=t[3*i],a=t[3*i+1],o=t[3*r],l=t[3*r+1],c=t[3*n],h=t[3*n+1];return[new Vector2(s,a),new Vector2(o,l),new Vector2(c,h)]},generateSideWallUV:function(e,t,i,r,n,s){const a=t[3*i],o=t[3*i+1],l=t[3*i+2],c=t[3*r],h=t[3*r+1],u=t[3*r+2],d=t[3*n],p=t[3*n+1],m=t[3*n+2],f=t[3*s],g=t[3*s+1],x=t[3*s+2];return Math.abs(o-h)<Math.abs(a-c)?[new Vector2(a,1-l),new Vector2(c,1-u),new Vector2(d,1-m),new Vector2(f,1-x)]:[new Vector2(o,1-l),new Vector2(h,1-u),new Vector2(p,1-m),new Vector2(g,1-x)]}};class IcosahedronGeometry extends PolyhedronGeometry{constructor(e=1,t=0){const i=(1+Math.sqrt(5))/2;super([-1,i,0,1,i,0,-1,-i,0,1,-i,0,0,-1,i,0,1,i,0,-1,-i,0,1,-i,i,0,-1,i,0,1,-i,0,-1,-i,0,1],[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],e,t),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new IcosahedronGeometry(e.radius,e.detail)}}class OctahedronGeometry extends PolyhedronGeometry{constructor(e=1,t=0){super([1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],e,t),this.type="OctahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new OctahedronGeometry(e.radius,e.detail)}}class RingGeometry extends BufferGeometry{constructor(e=.5,t=1,i=8,r=1,n=0,s=2*Math.PI){super(),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:i,phiSegments:r,thetaStart:n,thetaLength:s},i=Math.max(3,i);const a=[],o=[],l=[],c=[];let h=e;const u=(t-e)/(r=Math.max(1,r)),d=new Vector3,p=new Vector2;for(let m=0;m<=r;m++){for(let e=0;e<=i;e++){const r=n+e/i*s;d.x=h*Math.cos(r),d.y=h*Math.sin(r),o.push(d.x,d.y,d.z),l.push(0,0,1),p.x=(d.x/t+1)/2,p.y=(d.y/t+1)/2,c.push(p.x,p.y)}h+=u}for(let m=0;m<r;m++){const e=m*(i+1);for(let t=0;t<i;t++){const r=t+e,n=r,s=r+i+1,o=r+i+2,l=r+1;a.push(n,s,l),a.push(s,o,l)}}this.setIndex(a),this.setAttribute("position",new Float32BufferAttribute(o,3)),this.setAttribute("normal",new Float32BufferAttribute(l,3)),this.setAttribute("uv",new Float32BufferAttribute(c,2))}static fromJSON(e){return new RingGeometry(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)}}class ShapeGeometry extends BufferGeometry{constructor(e=new Shape([new Vector2(0,.5),new Vector2(-.5,-.5),new Vector2(.5,-.5)]),t=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};const i=[],r=[],n=[],s=[];let a=0,o=0;if(!1===Array.isArray(e))addShape(e);else for(let l=0;l<e.length;l++)addShape(e[l]),this.addGroup(a,o,l),a+=o,o=0;function addShape(e){const a=r.length/3,l=e.extractPoints(t);let c=l.shape;const h=l.holes;!1===ShapeUtils.isClockWise(c)&&(c=c.reverse());for(let t=0,i=h.length;t<i;t++){const e=h[t];!0===ShapeUtils.isClockWise(e)&&(h[t]=e.reverse())}const u=ShapeUtils.triangulateShape(c,h);for(let t=0,i=h.length;t<i;t++){const e=h[t];c=c.concat(e)}for(let t=0,i=c.length;t<i;t++){const e=c[t];r.push(e.x,e.y,0),n.push(0,0,1),s.push(e.x,e.y)}for(let t=0,r=u.length;t<r;t++){const e=u[t],r=e[0]+a,n=e[1]+a,s=e[2]+a;i.push(r,n,s),o+=3}}this.setIndex(i),this.setAttribute("position",new Float32BufferAttribute(r,3)),this.setAttribute("normal",new Float32BufferAttribute(n,3)),this.setAttribute("uv",new Float32BufferAttribute(s,2))}toJSON(){const e=super.toJSON();return function toJSON(e,t){if(t.shapes=[],Array.isArray(e))for(let i=0,r=e.length;i<r;i++){const r=e[i];t.shapes.push(r.uuid)}else t.shapes.push(e.uuid);return t}(this.parameters.shapes,e)}static fromJSON(e,t){const i=[];for(let r=0,n=e.shapes.length;r<n;r++){const n=t[e.shapes[r]];i.push(n)}return new ShapeGeometry(i,e.curveSegments)}}class SphereGeometry extends BufferGeometry{constructor(e=1,t=32,i=16,r=0,n=2*Math.PI,s=0,a=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:i,phiStart:r,phiLength:n,thetaStart:s,thetaLength:a},t=Math.max(3,Math.floor(t)),i=Math.max(2,Math.floor(i));const o=Math.min(s+a,Math.PI);let l=0;const c=[],h=new Vector3,u=new Vector3,d=[],p=[],m=[],f=[];for(let g=0;g<=i;g++){const d=[],x=g/i;let y=0;0==g&&0==s?y=.5/t:g==i&&o==Math.PI&&(y=-.5/t);for(let i=0;i<=t;i++){const o=i/t;h.x=-e*Math.cos(r+o*n)*Math.sin(s+x*a),h.y=e*Math.cos(s+x*a),h.z=e*Math.sin(r+o*n)*Math.sin(s+x*a),p.push(h.x,h.y,h.z),u.copy(h).normalize(),m.push(u.x,u.y,u.z),f.push(o+y,1-x),d.push(l++)}c.push(d)}for(let g=0;g<i;g++)for(let e=0;e<t;e++){const t=c[g][e+1],r=c[g][e],n=c[g+1][e],a=c[g+1][e+1];(0!==g||s>0)&&d.push(t,r,a),(g!==i-1||o<Math.PI)&&d.push(r,n,a)}this.setIndex(d),this.setAttribute("position",new Float32BufferAttribute(p,3)),this.setAttribute("normal",new Float32BufferAttribute(m,3)),this.setAttribute("uv",new Float32BufferAttribute(f,2))}static fromJSON(e){return new SphereGeometry(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}}class TetrahedronGeometry extends PolyhedronGeometry{constructor(e=1,t=0){super([1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],e,t),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new TetrahedronGeometry(e.radius,e.detail)}}class TorusGeometry extends BufferGeometry{constructor(e=1,t=.4,i=8,r=6,n=2*Math.PI){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:t,radialSegments:i,tubularSegments:r,arc:n},i=Math.floor(i),r=Math.floor(r);const s=[],a=[],o=[],l=[],c=new Vector3,h=new Vector3,u=new Vector3;for(let d=0;d<=i;d++)for(let s=0;s<=r;s++){const p=s/r*n,m=d/i*Math.PI*2;h.x=(e+t*Math.cos(m))*Math.cos(p),h.y=(e+t*Math.cos(m))*Math.sin(p),h.z=t*Math.sin(m),a.push(h.x,h.y,h.z),c.x=e*Math.cos(p),c.y=e*Math.sin(p),u.subVectors(h,c).normalize(),o.push(u.x,u.y,u.z),l.push(s/r),l.push(d/i)}for(let d=1;d<=i;d++)for(let e=1;e<=r;e++){const t=(r+1)*d+e-1,i=(r+1)*(d-1)+e-1,n=(r+1)*(d-1)+e,a=(r+1)*d+e;s.push(t,i,a),s.push(i,n,a)}this.setIndex(s),this.setAttribute("position",new Float32BufferAttribute(a,3)),this.setAttribute("normal",new Float32BufferAttribute(o,3)),this.setAttribute("uv",new Float32BufferAttribute(l,2))}static fromJSON(e){return new TorusGeometry(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)}}class TorusKnotGeometry extends BufferGeometry{constructor(e=1,t=.4,i=64,r=8,n=2,s=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:t,tubularSegments:i,radialSegments:r,p:n,q:s},i=Math.floor(i),r=Math.floor(r);const a=[],o=[],l=[],c=[],h=new Vector3,u=new Vector3,d=new Vector3,p=new Vector3,m=new Vector3,f=new Vector3,g=new Vector3;for(let x=0;x<=i;++x){const a=x/i*n*Math.PI*2;calculatePositionOnCurve(a,n,s,e,d),calculatePositionOnCurve(a+.01,n,s,e,p),f.subVectors(p,d),g.addVectors(p,d),m.crossVectors(f,g),g.crossVectors(m,f),m.normalize(),g.normalize();for(let e=0;e<=r;++e){const n=e/r*Math.PI*2,s=-t*Math.cos(n),a=t*Math.sin(n);h.x=d.x+(s*g.x+a*m.x),h.y=d.y+(s*g.y+a*m.y),h.z=d.z+(s*g.z+a*m.z),o.push(h.x,h.y,h.z),u.subVectors(h,d).normalize(),l.push(u.x,u.y,u.z),c.push(x/i),c.push(e/r)}}for(let x=1;x<=i;x++)for(let e=1;e<=r;e++){const t=(r+1)*(x-1)+(e-1),i=(r+1)*x+(e-1),n=(r+1)*x+e,s=(r+1)*(x-1)+e;a.push(t,i,s),a.push(i,n,s)}function calculatePositionOnCurve(e,t,i,r,n){const s=Math.cos(e),a=Math.sin(e),o=i/t*e,l=Math.cos(o);n.x=r*(2+l)*.5*s,n.y=r*(2+l)*a*.5,n.z=r*Math.sin(o)*.5}this.setIndex(a),this.setAttribute("position",new Float32BufferAttribute(o,3)),this.setAttribute("normal",new Float32BufferAttribute(l,3)),this.setAttribute("uv",new Float32BufferAttribute(c,2))}static fromJSON(e){return new TorusKnotGeometry(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)}}class TubeGeometry extends BufferGeometry{constructor(e=new QuadraticBezierCurve3(new Vector3(-1,-1,0),new Vector3(-1,1,0),new Vector3(1,1,0)),t=64,i=1,r=8,n=!1){super(),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:t,radius:i,radialSegments:r,closed:n};const s=e.computeFrenetFrames(t,n);this.tangents=s.tangents,this.normals=s.normals,this.binormals=s.binormals;const a=new Vector3,o=new Vector3,l=new Vector2;let c=new Vector3;const h=[],u=[],d=[],p=[];function generateSegment(n){c=e.getPointAt(n/t,c);const l=s.normals[n],d=s.binormals[n];for(let e=0;e<=r;e++){const t=e/r*Math.PI*2,n=Math.sin(t),s=-Math.cos(t);o.x=s*l.x+n*d.x,o.y=s*l.y+n*d.y,o.z=s*l.z+n*d.z,o.normalize(),u.push(o.x,o.y,o.z),a.x=c.x+i*o.x,a.y=c.y+i*o.y,a.z=c.z+i*o.z,h.push(a.x,a.y,a.z)}}!function generateBufferData(){for(let e=0;e<t;e++)generateSegment(e);generateSegment(!1===n?t:0),function generateUVs(){for(let e=0;e<=t;e++)for(let i=0;i<=r;i++)l.x=e/t,l.y=i/r,d.push(l.x,l.y)}(),function generateIndices(){for(let e=1;e<=t;e++)for(let t=1;t<=r;t++){const i=(r+1)*(e-1)+(t-1),n=(r+1)*e+(t-1),s=(r+1)*e+t,a=(r+1)*(e-1)+t;p.push(i,n,a),p.push(n,s,a)}}()}(),this.setIndex(p),this.setAttribute("position",new Float32BufferAttribute(h,3)),this.setAttribute("normal",new Float32BufferAttribute(u,3)),this.setAttribute("uv",new Float32BufferAttribute(d,2))}toJSON(){const e=super.toJSON();return e.path=this.parameters.path.toJSON(),e}static fromJSON(e){return new TubeGeometry((new Is[e.path.type]).fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)}}class WireframeGeometry extends BufferGeometry{constructor(e=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:e},null!==e){const t=[],i=new Set,r=new Vector3,n=new Vector3;if(null!==e.index){const s=e.attributes.position,a=e.index;let o=e.groups;0===o.length&&(o=[{start:0,count:a.count,materialIndex:0}]);for(let e=0,l=o.length;e<l;++e){const l=o[e],c=l.start;for(let e=c,o=c+l.count;e<o;e+=3)for(let l=0;l<3;l++){const o=a.getX(e+l),c=a.getX(e+(l+1)%3);r.fromBufferAttribute(s,o),n.fromBufferAttribute(s,c),!0===isUniqueEdge(r,n,i)&&(t.push(r.x,r.y,r.z),t.push(n.x,n.y,n.z))}}}else{const s=e.attributes.position;for(let e=0,a=s.count/3;e<a;e++)for(let o=0;o<3;o++){const a=3*e+o,l=3*e+(o+1)%3;r.fromBufferAttribute(s,a),n.fromBufferAttribute(s,l),!0===isUniqueEdge(r,n,i)&&(t.push(r.x,r.y,r.z),t.push(n.x,n.y,n.z))}}this.setAttribute("position",new Float32BufferAttribute(t,3))}}}function isUniqueEdge(e,t,i){const r=`${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`,n=`${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`;return!0!==i.has(r)&&!0!==i.has(n)&&(i.add(r),i.add(n),!0)}var Fs=Object.freeze({__proto__:null,BoxGeometry:BoxGeometry,BoxBufferGeometry:BoxGeometry,CapsuleGeometry:CapsuleGeometry,CapsuleBufferGeometry:CapsuleGeometry,CircleGeometry:CircleGeometry,CircleBufferGeometry:CircleGeometry,ConeGeometry:ConeGeometry,ConeBufferGeometry:ConeGeometry,CylinderGeometry:CylinderGeometry,CylinderBufferGeometry:CylinderGeometry,DodecahedronGeometry:DodecahedronGeometry,DodecahedronBufferGeometry:DodecahedronGeometry,EdgesGeometry:EdgesGeometry,ExtrudeGeometry:ExtrudeGeometry,ExtrudeBufferGeometry:ExtrudeGeometry,IcosahedronGeometry:IcosahedronGeometry,IcosahedronBufferGeometry:IcosahedronGeometry,LatheGeometry:LatheGeometry,LatheBufferGeometry:LatheGeometry,OctahedronGeometry:OctahedronGeometry,OctahedronBufferGeometry:OctahedronGeometry,PlaneGeometry:PlaneGeometry,PlaneBufferGeometry:PlaneGeometry,PolyhedronGeometry:PolyhedronGeometry,PolyhedronBufferGeometry:PolyhedronGeometry,RingGeometry:RingGeometry,RingBufferGeometry:RingGeometry,ShapeGeometry:ShapeGeometry,ShapeBufferGeometry:ShapeGeometry,SphereGeometry:SphereGeometry,SphereBufferGeometry:SphereGeometry,TetrahedronGeometry:TetrahedronGeometry,TetrahedronBufferGeometry:TetrahedronGeometry,TorusGeometry:TorusGeometry,TorusBufferGeometry:TorusGeometry,TorusKnotGeometry:TorusKnotGeometry,TorusKnotBufferGeometry:TorusKnotGeometry,TubeGeometry:TubeGeometry,TubeBufferGeometry:TubeGeometry,WireframeGeometry:WireframeGeometry});class ShadowMaterial extends Material{constructor(e){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new Color(0),this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.fog=e.fog,this}}class RawShaderMaterial extends ShaderMaterial{constructor(e){super(e),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class MeshStandardMaterial extends Material{constructor(e){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Color(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Nt,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class MeshPhysicalMaterial extends MeshStandardMaterial{constructor(e){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Vector2(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return clamp(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(e){this.ior=(1+.4*e)/(1-.4*e)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new Color(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=0,this.attenuationColor=new Color(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Color(1,1,1),this.specularColorMap=null,this._sheen=0,this._clearcoat=0,this._iridescence=0,this._transmission=0,this.setValues(e)}get sheen(){return this._sheen}set sheen(e){this._sheen>0!==e>0&&this.version++,this._sheen=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!==e>0&&this.version++,this._clearcoat=e}get iridescence(){return this._iridescence}set iridescence(e){this._iridescence>0!==e>0&&this.version++,this._iridescence=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!==e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.ior=e.ior,this.iridescence=e.iridescence,this.iridescenceMap=e.iridescenceMap,this.iridescenceIOR=e.iridescenceIOR,this.iridescenceThicknessRange=[...e.iridescenceThicknessRange],this.iridescenceThicknessMap=e.iridescenceThicknessMap,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}class MeshPhongMaterial extends Material{constructor(e){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new Color(16777215),this.specular=new Color(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Nt,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Z,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class MeshToonMaterial extends Material{constructor(e){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Color(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Nt,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}class MeshNormalMaterial extends Material{constructor(e){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Nt,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.flatShading=e.flatShading,this}}class MeshLambertMaterial extends Material{constructor(e){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new Color(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Z,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}class MeshMatcapMaterial extends Material{constructor(e){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Color(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Nt,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.flatShading=e.flatShading,this.fog=e.fog,this}}class LineDashedMaterial extends LineBasicMaterial{constructor(e){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}}function arraySlice(e,t,i){return isTypedArray(e)?new e.constructor(e.subarray(t,void 0!==i?i:e.length)):e.slice(t,i)}function convertArray(e,t,i){return!e||!i&&e.constructor===t?e:"number"===typeof t.BYTES_PER_ELEMENT?new t(e):Array.prototype.slice.call(e)}function isTypedArray(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)}function getKeyframeOrder(e){const t=e.length,i=new Array(t);for(let r=0;r!==t;++r)i[r]=r;return i.sort((function compareTime(t,i){return e[t]-e[i]})),i}function sortedArray(e,t,i){const r=e.length,n=new e.constructor(r);for(let s=0,a=0;a!==r;++s){const r=i[s]*t;for(let i=0;i!==t;++i)n[a++]=e[r+i]}return n}function flattenJSON(e,t,i,r){let n=1,s=e[0];for(;void 0!==s&&void 0===s[r];)s=e[n++];if(void 0===s)return;let a=s[r];if(void 0!==a)if(Array.isArray(a))do{a=s[r],void 0!==a&&(t.push(s.time),i.push.apply(i,a)),s=e[n++]}while(void 0!==s);else if(void 0!==a.toArray)do{a=s[r],void 0!==a&&(t.push(s.time),a.toArray(i,i.length)),s=e[n++]}while(void 0!==s);else do{a=s[r],void 0!==a&&(t.push(s.time),i.push(a)),s=e[n++]}while(void 0!==s)}var Gs=Object.freeze({__proto__:null,arraySlice:arraySlice,convertArray:convertArray,isTypedArray:isTypedArray,getKeyframeOrder:getKeyframeOrder,sortedArray:sortedArray,flattenJSON:flattenJSON,subclip:function subclip(e,t,i,r,n=30){const s=e.clone();s.name=t;const a=[];for(let l=0;l<s.tracks.length;++l){const e=s.tracks[l],t=e.getValueSize(),o=[],c=[];for(let s=0;s<e.times.length;++s){const a=e.times[s]*n;if(!(a<i||a>=r)){o.push(e.times[s]);for(let i=0;i<t;++i)c.push(e.values[s*t+i])}}0!==o.length&&(e.times=convertArray(o,e.times.constructor),e.values=convertArray(c,e.values.constructor),a.push(e))}s.tracks=a;let o=1/0;for(let l=0;l<s.tracks.length;++l)o>s.tracks[l].times[0]&&(o=s.tracks[l].times[0]);for(let l=0;l<s.tracks.length;++l)s.tracks[l].shift(-1*o);return s.resetDuration(),s},makeClipAdditive:function makeClipAdditive(e,t=0,i=e,r=30){r<=0&&(r=30);const n=i.tracks.length,s=t/r;for(let a=0;a<n;++a){const t=i.tracks[a],r=t.ValueTypeName;if("bool"===r||"string"===r)continue;const n=e.tracks.find((function(e){return e.name===t.name&&e.ValueTypeName===r}));if(void 0===n)continue;let o=0;const l=t.getValueSize();t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(o=l/3);let c=0;const h=n.getValueSize();n.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(c=h/3);const u=t.times.length-1;let d;if(s<=t.times[0]){const e=o,i=l-o;d=arraySlice(t.values,e,i)}else if(s>=t.times[u]){const e=u*l+o,i=e+l-o;d=arraySlice(t.values,e,i)}else{const e=t.createInterpolant(),i=o,r=l-o;e.evaluate(s),d=arraySlice(e.resultBuffer,i,r)}if("quaternion"===r){(new Quaternion).fromArray(d).normalize().conjugate().toArray(d)}const p=n.times.length;for(let e=0;e<p;++e){const t=e*h+c;if("quaternion"===r)Quaternion.multiplyQuaternionsFlat(n.values,t,d,0,n.values,t);else{const e=h-2*c;for(let i=0;i<e;++i)n.values[t+i]-=d[i]}}}return e.blendMode=Et,e}});class Interpolant{constructor(e,t,i,r){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=void 0!==r?r:new t.constructor(i),this.sampleValues=t,this.valueSize=i,this.settings=null,this.DefaultSettings_={}}evaluate(e){const t=this.parameterPositions;let i=this._cachedIndex,r=t[i],n=t[i-1];e:{t:{let s;i:{r:if(!(e<r)){for(let s=i+2;;){if(void 0===r){if(e<n)break r;return i=t.length,this._cachedIndex=i,this.copySampleValue_(i-1)}if(i===s)break;if(n=r,r=t[++i],e<r)break t}s=t.length;break i}if(e>=n)break e;{const a=t[1];e<a&&(i=2,n=a);for(let s=i-2;;){if(void 0===n)return this._cachedIndex=0,this.copySampleValue_(0);if(i===s)break;if(r=n,n=t[--i-1],e>=n)break t}s=i,i=0}}for(;i<s;){const r=i+s>>>1;e<t[r]?s=r:i=r+1}if(r=t[i],n=t[i-1],void 0===n)return this._cachedIndex=0,this.copySampleValue_(0);if(void 0===r)return i=t.length,this._cachedIndex=i,this.copySampleValue_(i-1)}this._cachedIndex=i,this.intervalChanged_(i,n,r)}return this.interpolate_(i,n,e,r)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const t=this.resultBuffer,i=this.sampleValues,r=this.valueSize,n=e*r;for(let s=0;s!==r;++s)t[s]=i[n+s];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class CubicInterpolant extends Interpolant{constructor(e,t,i,r){super(e,t,i,r),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:wt,endingEnd:wt}}intervalChanged_(e,t,i){const r=this.parameterPositions;let n=e-2,s=e+1,a=r[n],o=r[s];if(void 0===a)switch(this.getSettings_().endingStart){case Tt:n=e,a=2*t-i;break;case At:n=r.length-2,a=t+r[n]-r[n+1];break;default:n=e,a=i}if(void 0===o)switch(this.getSettings_().endingEnd){case Tt:s=e,o=2*i-t;break;case At:s=1,o=i+r[1]-r[0];break;default:s=e-1,o=t}const l=.5*(i-t),c=this.valueSize;this._weightPrev=l/(t-a),this._weightNext=l/(o-i),this._offsetPrev=n*c,this._offsetNext=s*c}interpolate_(e,t,i,r){const n=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=e*a,l=o-a,c=this._offsetPrev,h=this._offsetNext,u=this._weightPrev,d=this._weightNext,p=(i-t)/(r-t),m=p*p,f=m*p,g=-u*f+2*u*m-u*p,x=(1+u)*f+(-1.5-2*u)*m+(-.5+u)*p+1,y=(-1-d)*f+(1.5+d)*m+.5*p,_=d*f-d*m;for(let b=0;b!==a;++b)n[b]=g*s[c+b]+x*s[l+b]+y*s[o+b]+_*s[h+b];return n}}class LinearInterpolant extends Interpolant{constructor(e,t,i,r){super(e,t,i,r)}interpolate_(e,t,i,r){const n=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=e*a,l=o-a,c=(i-t)/(r-t),h=1-c;for(let u=0;u!==a;++u)n[u]=s[l+u]*h+s[o+u]*c;return n}}class DiscreteInterpolant extends Interpolant{constructor(e,t,i,r){super(e,t,i,r)}interpolate_(e){return this.copySampleValue_(e-1)}}class KeyframeTrack{constructor(e,t,i,r){if(void 0===e)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===t||0===t.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=convertArray(t,this.TimeBufferType),this.values=convertArray(i,this.ValueBufferType),this.setInterpolation(r||this.DefaultInterpolation)}static toJSON(e){const t=e.constructor;let i;if(t.toJSON!==this.toJSON)i=t.toJSON(e);else{i={name:e.name,times:convertArray(e.times,Array),values:convertArray(e.values,Array)};const t=e.getInterpolation();t!==e.DefaultInterpolation&&(i.interpolation=t)}return i.type=e.ValueTypeName,i}InterpolantFactoryMethodDiscrete(e){return new DiscreteInterpolant(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new LinearInterpolant(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new CubicInterpolant(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case bt:t=this.InterpolantFactoryMethodDiscrete;break;case Mt:t=this.InterpolantFactoryMethodLinear;break;case St:t=this.InterpolantFactoryMethodSmooth}if(void 0===t){const t="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(e===this.DefaultInterpolation)throw new Error(t);this.setInterpolation(this.DefaultInterpolation)}return console.warn("THREE.KeyframeTrack:",t),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return bt;case this.InterpolantFactoryMethodLinear:return Mt;case this.InterpolantFactoryMethodSmooth:return St}}getValueSize(){return this.values.length/this.times.length}shift(e){if(0!==e){const t=this.times;for(let i=0,r=t.length;i!==r;++i)t[i]+=e}return this}scale(e){if(1!==e){const t=this.times;for(let i=0,r=t.length;i!==r;++i)t[i]*=e}return this}trim(e,t){const i=this.times,r=i.length;let n=0,s=r-1;for(;n!==r&&i[n]<e;)++n;for(;-1!==s&&i[s]>t;)--s;if(++s,0!==n||s!==r){n>=s&&(s=Math.max(s,1),n=s-1);const e=this.getValueSize();this.times=arraySlice(i,n,s),this.values=arraySlice(this.values,n*e,s*e)}return this}validate(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const i=this.times,r=this.values,n=i.length;0===n&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let s=null;for(let a=0;a!==n;a++){const t=i[a];if("number"===typeof t&&isNaN(t)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,a,t),e=!1;break}if(null!==s&&s>t){console.error("THREE.KeyframeTrack: Out of order keys.",this,a,t,s),e=!1;break}s=t}if(void 0!==r&&isTypedArray(r))for(let a=0,o=r.length;a!==o;++a){const t=r[a];if(isNaN(t)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,a,t),e=!1;break}}return e}optimize(){const e=arraySlice(this.times),t=arraySlice(this.values),i=this.getValueSize(),r=this.getInterpolation()===St,n=e.length-1;let s=1;for(let a=1;a<n;++a){let n=!1;const o=e[a];if(o!==e[a+1]&&(1!==a||o!==e[0]))if(r)n=!0;else{const e=a*i,r=e-i,s=e+i;for(let a=0;a!==i;++a){const i=t[e+a];if(i!==t[r+a]||i!==t[s+a]){n=!0;break}}}if(n){if(a!==s){e[s]=e[a];const r=a*i,n=s*i;for(let e=0;e!==i;++e)t[n+e]=t[r+e]}++s}}if(n>0){e[s]=e[n];for(let e=n*i,r=s*i,a=0;a!==i;++a)t[r+a]=t[e+a];++s}return s!==e.length?(this.times=arraySlice(e,0,s),this.values=arraySlice(t,0,s*i)):(this.times=e,this.values=t),this}clone(){const e=arraySlice(this.times,0),t=arraySlice(this.values,0),i=new(0,this.constructor)(this.name,e,t);return i.createInterpolant=this.createInterpolant,i}}KeyframeTrack.prototype.TimeBufferType=Float32Array,KeyframeTrack.prototype.ValueBufferType=Float32Array,KeyframeTrack.prototype.DefaultInterpolation=Mt;class BooleanKeyframeTrack extends KeyframeTrack{}BooleanKeyframeTrack.prototype.ValueTypeName="bool",BooleanKeyframeTrack.prototype.ValueBufferType=Array,BooleanKeyframeTrack.prototype.DefaultInterpolation=bt,BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear=void 0,BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=void 0;class ColorKeyframeTrack extends KeyframeTrack{}ColorKeyframeTrack.prototype.ValueTypeName="color";class NumberKeyframeTrack extends KeyframeTrack{}NumberKeyframeTrack.prototype.ValueTypeName="number";class QuaternionLinearInterpolant extends Interpolant{constructor(e,t,i,r){super(e,t,i,r)}interpolate_(e,t,i,r){const n=this.resultBuffer,s=this.sampleValues,a=this.valueSize,o=(i-t)/(r-t);let l=e*a;for(let c=l+a;l!==c;l+=4)Quaternion.slerpFlat(n,0,s,l-a,s,l,o);return n}}class QuaternionKeyframeTrack extends KeyframeTrack{InterpolantFactoryMethodLinear(e){return new QuaternionLinearInterpolant(this.times,this.values,this.getValueSize(),e)}}QuaternionKeyframeTrack.prototype.ValueTypeName="quaternion",QuaternionKeyframeTrack.prototype.DefaultInterpolation=Mt,QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=void 0;class StringKeyframeTrack extends KeyframeTrack{}StringKeyframeTrack.prototype.ValueTypeName="string",StringKeyframeTrack.prototype.ValueBufferType=Array,StringKeyframeTrack.prototype.DefaultInterpolation=bt,StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear=void 0,StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=void 0;class VectorKeyframeTrack extends KeyframeTrack{}VectorKeyframeTrack.prototype.ValueTypeName="vector";class AnimationClip{constructor(e,t=-1,i,r=Ct){this.name=e,this.tracks=i,this.duration=t,this.blendMode=r,this.uuid=generateUUID(),this.duration<0&&this.resetDuration()}static parse(e){const t=[],i=e.tracks,r=1/(e.fps||1);for(let s=0,a=i.length;s!==a;++s)t.push(parseKeyframeTrack(i[s]).scale(r));const n=new this(e.name,e.duration,t,e.blendMode);return n.uuid=e.uuid,n}static toJSON(e){const t=[],i=e.tracks,r={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let n=0,s=i.length;n!==s;++n)t.push(KeyframeTrack.toJSON(i[n]));return r}static CreateFromMorphTargetSequence(e,t,i,r){const n=t.length,s=[];for(let a=0;a<n;a++){let e=[],o=[];e.push((a+n-1)%n,a,(a+1)%n),o.push(0,1,0);const l=getKeyframeOrder(e);e=sortedArray(e,1,l),o=sortedArray(o,1,l),r||0!==e[0]||(e.push(n),o.push(o[0])),s.push(new NumberKeyframeTrack(".morphTargetInfluences["+t[a].name+"]",e,o).scale(1/i))}return new this(e,-1,s)}static findByName(e,t){let i=e;if(!Array.isArray(e)){const t=e;i=t.geometry&&t.geometry.animations||t.animations}for(let r=0;r<i.length;r++)if(i[r].name===t)return i[r];return null}static CreateClipsFromMorphTargetSequences(e,t,i){const r={},n=/^([\w-]*?)([\d]+)$/;for(let a=0,o=e.length;a<o;a++){const t=e[a],i=t.name.match(n);if(i&&i.length>1){const e=i[1];let n=r[e];n||(r[e]=n=[]),n.push(t)}}const s=[];for(const a in r)s.push(this.CreateFromMorphTargetSequence(a,r[a],t,i));return s}static parseAnimation(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const addNonemptyTrack=function(e,t,i,r,n){if(0!==i.length){const s=[],a=[];flattenJSON(i,s,a,r),0!==s.length&&n.push(new e(t,s,a))}},i=[],r=e.name||"default",n=e.fps||30,s=e.blendMode;let a=e.length||-1;const o=e.hierarchy||[];for(let l=0;l<o.length;l++){const e=o[l].keys;if(e&&0!==e.length)if(e[0].morphTargets){const t={};let r;for(r=0;r<e.length;r++)if(e[r].morphTargets)for(let i=0;i<e[r].morphTargets.length;i++)t[e[r].morphTargets[i]]=-1;for(const n in t){const t=[],s=[];for(let i=0;i!==e[r].morphTargets.length;++i){const i=e[r];t.push(i.time),s.push(i.morphTarget===n?1:0)}i.push(new NumberKeyframeTrack(".morphTargetInfluence["+n+"]",t,s))}a=t.length*n}else{const r=".bones["+t[l].name+"]";addNonemptyTrack(VectorKeyframeTrack,r+".position",e,"pos",i),addNonemptyTrack(QuaternionKeyframeTrack,r+".quaternion",e,"rot",i),addNonemptyTrack(VectorKeyframeTrack,r+".scale",e,"scl",i)}}if(0===i.length)return null;return new this(r,a,i,s)}resetDuration(){let e=0;for(let t=0,i=this.tracks.length;t!==i;++t){const i=this.tracks[t];e=Math.max(e,i.times[i.times.length-1])}return this.duration=e,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function parseKeyframeTrack(e){if(void 0===e.type)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const t=function getTrackTypeForValueTypeName(e){switch(e.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return NumberKeyframeTrack;case"vector":case"vector2":case"vector3":case"vector4":return VectorKeyframeTrack;case"color":return ColorKeyframeTrack;case"quaternion":return QuaternionKeyframeTrack;case"bool":case"boolean":return BooleanKeyframeTrack;case"string":return StringKeyframeTrack}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+e)}(e.type);if(void 0===e.times){const t=[],i=[];flattenJSON(e.keys,t,i,"value"),e.times=t,e.values=i}return void 0!==t.parse?t.parse(e):new t(e.name,e.times,e.values,e.interpolation)}const Us={enabled:!1,files:{},add:function(e,t){!1!==this.enabled&&(this.files[e]=t)},get:function(e){if(!1!==this.enabled)return this.files[e]},remove:function(e){delete this.files[e]},clear:function(){this.files={}}};class LoadingManager{constructor(e,t,i){const r=this;let n,s=!1,a=0,o=0;const l=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=i,this.itemStart=function(e){o++,!1===s&&void 0!==r.onStart&&r.onStart(e,a,o),s=!0},this.itemEnd=function(e){a++,void 0!==r.onProgress&&r.onProgress(e,a,o),a===o&&(s=!1,void 0!==r.onLoad&&r.onLoad())},this.itemError=function(e){void 0!==r.onError&&r.onError(e)},this.resolveURL=function(e){return n?n(e):e},this.setURLModifier=function(e){return n=e,this},this.addHandler=function(e,t){return l.push(e,t),this},this.removeHandler=function(e){const t=l.indexOf(e);return-1!==t&&l.splice(t,2),this},this.getHandler=function(e){for(let t=0,i=l.length;t<i;t+=2){const i=l[t],r=l[t+1];if(i.global&&(i.lastIndex=0),i.test(e))return r}return null}}}const ks=new LoadingManager;class Loader{constructor(e){this.manager=void 0!==e?e:ks,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){const i=this;return new Promise((function(r,n){i.load(e,r,t,n)}))}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}const Ws={};class HttpError extends Error{constructor(e,t){super(e),this.response=t}}class FileLoader extends Loader{constructor(e){super(e)}load(e,t,i,r){void 0===e&&(e=""),void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);const n=Us.get(e);if(void 0!==n)return this.manager.itemStart(e),setTimeout((()=>{t&&t(n),this.manager.itemEnd(e)}),0),n;if(void 0!==Ws[e])return void Ws[e].push({onLoad:t,onProgress:i,onError:r});Ws[e]=[],Ws[e].push({onLoad:t,onProgress:i,onError:r});const s=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),a=this.mimeType,o=this.responseType;fetch(s).then((t=>{if(200===t.status||0===t.status){if(0===t.status&&console.warn("THREE.FileLoader: HTTP Status 0 received."),"undefined"===typeof ReadableStream||void 0===t.body||void 0===t.body.getReader)return t;const i=Ws[e],r=t.body.getReader(),n=t.headers.get("Content-Length"),s=n?parseInt(n):0,a=0!==s;let o=0;const l=new ReadableStream({start(e){!function readData(){r.read().then((({done:t,value:r})=>{if(t)e.close();else{o+=r.byteLength;const t=new ProgressEvent("progress",{lengthComputable:a,loaded:o,total:s});for(let e=0,r=i.length;e<r;e++){const r=i[e];r.onProgress&&r.onProgress(t)}e.enqueue(r),readData()}}))}()}});return new Response(l)}throw new HttpError(`fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`,t)})).then((e=>{switch(o){case"arraybuffer":return e.arrayBuffer();case"blob":return e.blob();case"document":return e.text().then((e=>(new DOMParser).parseFromString(e,a)));case"json":return e.json();default:if(void 0===a)return e.text();{const t=/charset="?([^;"\s]*)"?/i.exec(a),i=t&&t[1]?t[1].toLowerCase():void 0,r=new TextDecoder(i);return e.arrayBuffer().then((e=>r.decode(e)))}}})).then((t=>{Us.add(e,t);const i=Ws[e];delete Ws[e];for(let e=0,r=i.length;e<r;e++){const r=i[e];r.onLoad&&r.onLoad(t)}})).catch((t=>{const i=Ws[e];if(void 0===i)throw this.manager.itemError(e),t;delete Ws[e];for(let e=0,r=i.length;e<r;e++){const r=i[e];r.onError&&r.onError(t)}this.manager.itemError(e)})).finally((()=>{this.manager.itemEnd(e)})),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}}class AnimationLoader extends Loader{constructor(e){super(e)}load(e,t,i,r){const n=this,s=new FileLoader(this.manager);s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials),s.load(e,(function(i){try{t(n.parse(JSON.parse(i)))}catch(s){r?r(s):console.error(s),n.manager.itemError(e)}}),i,r)}parse(e){const t=[];for(let i=0;i<e.length;i++){const r=AnimationClip.parse(e[i]);t.push(r)}return t}}class CompressedTextureLoader extends Loader{constructor(e){super(e)}load(e,t,i,r){const n=this,s=[],a=new CompressedTexture,o=new FileLoader(this.manager);o.setPath(this.path),o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setWithCredentials(n.withCredentials);let l=0;function loadTexture(c){o.load(e[c],(function(e){const i=n.parse(e,!0);s[c]={width:i.width,height:i.height,format:i.format,mipmaps:i.mipmaps},l+=1,6===l&&(1===i.mipmapCount&&(a.minFilter=xe),a.image=s,a.format=i.format,a.needsUpdate=!0,t&&t(a))}),i,r)}if(Array.isArray(e))for(let c=0,h=e.length;c<h;++c)loadTexture(c);else o.load(e,(function(e){const i=n.parse(e,!0);if(i.isCubemap){const e=i.mipmaps.length/i.mipmapCount;for(let t=0;t<e;t++){s[t]={mipmaps:[]};for(let e=0;e<i.mipmapCount;e++)s[t].mipmaps.push(i.mipmaps[t*i.mipmapCount+e]),s[t].format=i.format,s[t].width=i.width,s[t].height=i.height}a.image=s}else a.image.width=i.width,a.image.height=i.height,a.mipmaps=i.mipmaps;1===i.mipmapCount&&(a.minFilter=xe),a.format=i.format,a.needsUpdate=!0,t&&t(a)}),i,r);return a}}class ImageLoader extends Loader{constructor(e){super(e)}load(e,t,i,r){void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);const n=this,s=Us.get(e);if(void 0!==s)return n.manager.itemStart(e),setTimeout((function(){t&&t(s),n.manager.itemEnd(e)}),0),s;const a=createElementNS("img");function onImageLoad(){removeEventListeners(),Us.add(e,this),t&&t(this),n.manager.itemEnd(e)}function onImageError(t){removeEventListeners(),r&&r(t),n.manager.itemError(e),n.manager.itemEnd(e)}function removeEventListeners(){a.removeEventListener("load",onImageLoad,!1),a.removeEventListener("error",onImageError,!1)}return a.addEventListener("load",onImageLoad,!1),a.addEventListener("error",onImageError,!1),"data:"!==e.slice(0,5)&&void 0!==this.crossOrigin&&(a.crossOrigin=this.crossOrigin),n.manager.itemStart(e),a.src=e,a}}class CubeTextureLoader extends Loader{constructor(e){super(e)}load(e,t,i,r){const n=new CubeTexture,s=new ImageLoader(this.manager);s.setCrossOrigin(this.crossOrigin),s.setPath(this.path);let a=0;function loadTexture(i){s.load(e[i],(function(e){n.images[i]=e,a++,6===a&&(n.needsUpdate=!0,t&&t(n))}),void 0,r)}for(let o=0;o<e.length;++o)loadTexture(o);return n}}class DataTextureLoader extends Loader{constructor(e){super(e)}load(e,t,i,r){const n=this,s=new DataTexture,a=new FileLoader(this.manager);return a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setPath(this.path),a.setWithCredentials(n.withCredentials),a.load(e,(function(e){const i=n.parse(e);i&&(void 0!==i.image?s.image=i.image:void 0!==i.data&&(s.image.width=i.width,s.image.height=i.height,s.image.data=i.data),s.wrapS=void 0!==i.wrapS?i.wrapS:ue,s.wrapT=void 0!==i.wrapT?i.wrapT:ue,s.magFilter=void 0!==i.magFilter?i.magFilter:xe,s.minFilter=void 0!==i.minFilter?i.minFilter:xe,s.anisotropy=void 0!==i.anisotropy?i.anisotropy:1,void 0!==i.encoding&&(s.encoding=i.encoding),void 0!==i.flipY&&(s.flipY=i.flipY),void 0!==i.format&&(s.format=i.format),void 0!==i.type&&(s.type=i.type),void 0!==i.mipmaps&&(s.mipmaps=i.mipmaps,s.minFilter=be),1===i.mipmapCount&&(s.minFilter=xe),void 0!==i.generateMipmaps&&(s.generateMipmaps=i.generateMipmaps),s.needsUpdate=!0,t&&t(s,i))}),i,r),s}}class TextureLoader extends Loader{constructor(e){super(e)}load(e,t,i,r){const n=new Texture,s=new ImageLoader(this.manager);return s.setCrossOrigin(this.crossOrigin),s.setPath(this.path),s.load(e,(function(e){n.image=e,n.needsUpdate=!0,void 0!==t&&t(n)}),i,r),n}}class Light extends Object3D{constructor(e,t=1){super(),this.isLight=!0,this.type="Light",this.color=new Color(e),this.intensity=t}dispose(){}copy(e,t){return super.copy(e,t),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,void 0!==this.groundColor&&(t.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(t.object.distance=this.distance),void 0!==this.angle&&(t.object.angle=this.angle),void 0!==this.decay&&(t.object.decay=this.decay),void 0!==this.penumbra&&(t.object.penumbra=this.penumbra),void 0!==this.shadow&&(t.object.shadow=this.shadow.toJSON()),t}}class HemisphereLight extends Light{constructor(e,t,i){super(e,i),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(Object3D.DefaultUp),this.updateMatrix(),this.groundColor=new Color(t)}copy(e,t){return super.copy(e,t),this.groundColor.copy(e.groundColor),this}}const Hs=new Matrix4,js=new Vector3,qs=new Vector3;class LightShadow{constructor(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Vector2(512,512),this.map=null,this.mapPass=null,this.matrix=new Matrix4,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Frustum,this._frameExtents=new Vector2(1,1),this._viewportCount=1,this._viewports=[new Vector4(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,i=this.matrix;js.setFromMatrixPosition(e.matrixWorld),t.position.copy(js),qs.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(qs),t.updateMatrixWorld(),Hs.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Hs),i.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),i.multiply(t.projectionMatrix),i.multiply(t.matrixWorldInverse)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return(new this.constructor).copy(this)}toJSON(){const e={};return 0!==this.bias&&(e.bias=this.bias),0!==this.normalBias&&(e.normalBias=this.normalBias),1!==this.radius&&(e.radius=this.radius),512===this.mapSize.x&&512===this.mapSize.y||(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class SpotLightShadow extends LightShadow{constructor(){super(new PerspectiveCamera(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(e){const t=this.camera,i=2*xi*e.angle*this.focus,r=this.mapSize.width/this.mapSize.height,n=e.distance||t.far;i===t.fov&&r===t.aspect&&n===t.far||(t.fov=i,t.aspect=r,t.far=n,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}class SpotLight extends Light{constructor(e,t,i=0,r=Math.PI/3,n=0,s=1){super(e,t),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(Object3D.DefaultUp),this.updateMatrix(),this.target=new Object3D,this.distance=i,this.angle=r,this.penumbra=n,this.decay=s,this.shadow=new SpotLightShadow}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}const Xs=new Matrix4,Ys=new Vector3,Zs=new Vector3;class PointLightShadow extends LightShadow{constructor(){super(new PerspectiveCamera(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new Vector2(4,2),this._viewportCount=6,this._viewports=[new Vector4(2,1,1,1),new Vector4(0,1,1,1),new Vector4(3,1,1,1),new Vector4(1,1,1,1),new Vector4(3,0,1,1),new Vector4(1,0,1,1)],this._cubeDirections=[new Vector3(1,0,0),new Vector3(-1,0,0),new Vector3(0,0,1),new Vector3(0,0,-1),new Vector3(0,1,0),new Vector3(0,-1,0)],this._cubeUps=[new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,0,1),new Vector3(0,0,-1)]}updateMatrices(e,t=0){const i=this.camera,r=this.matrix,n=e.distance||i.far;n!==i.far&&(i.far=n,i.updateProjectionMatrix()),Ys.setFromMatrixPosition(e.matrixWorld),i.position.copy(Ys),Zs.copy(i.position),Zs.add(this._cubeDirections[t]),i.up.copy(this._cubeUps[t]),i.lookAt(Zs),i.updateMatrixWorld(),r.makeTranslation(-Ys.x,-Ys.y,-Ys.z),Xs.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Xs)}}class PointLight extends Light{constructor(e,t,i=0,r=1){super(e,t),this.isPointLight=!0,this.type="PointLight",this.distance=i,this.decay=r,this.shadow=new PointLightShadow}get power(){return 4*this.intensity*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}class DirectionalLightShadow extends LightShadow{constructor(){super(new OrthographicCamera(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class DirectionalLight extends Light{constructor(e,t){super(e,t),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(Object3D.DefaultUp),this.updateMatrix(),this.target=new Object3D,this.shadow=new DirectionalLightShadow}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}class AmbientLight extends Light{constructor(e,t){super(e,t),this.isAmbientLight=!0,this.type="AmbientLight"}}class RectAreaLight extends Light{constructor(e,t,i=10,r=10){super(e,t),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=i,this.height=r}get power(){return this.intensity*this.width*this.height*Math.PI}set power(e){this.intensity=e/(this.width*this.height*Math.PI)}copy(e){return super.copy(e),this.width=e.width,this.height=e.height,this}toJSON(e){const t=super.toJSON(e);return t.object.width=this.width,t.object.height=this.height,t}}class SphericalHarmonics3{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new Vector3)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const i=e.x,r=e.y,n=e.z,s=this.coefficients;return t.copy(s[0]).multiplyScalar(.282095),t.addScaledVector(s[1],.488603*r),t.addScaledVector(s[2],.488603*n),t.addScaledVector(s[3],.488603*i),t.addScaledVector(s[4],i*r*1.092548),t.addScaledVector(s[5],r*n*1.092548),t.addScaledVector(s[6],.315392*(3*n*n-1)),t.addScaledVector(s[7],i*n*1.092548),t.addScaledVector(s[8],.546274*(i*i-r*r)),t}getIrradianceAt(e,t){const i=e.x,r=e.y,n=e.z,s=this.coefficients;return t.copy(s[0]).multiplyScalar(.886227),t.addScaledVector(s[1],1.023328*r),t.addScaledVector(s[2],1.023328*n),t.addScaledVector(s[3],1.023328*i),t.addScaledVector(s[4],.858086*i*r),t.addScaledVector(s[5],.858086*r*n),t.addScaledVector(s[6],.743125*n*n-.247708),t.addScaledVector(s[7],.858086*i*n),t.addScaledVector(s[8],.429043*(i*i-r*r)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let i=0;i<9;i++)this.coefficients[i].addScaledVector(e.coefficients[i],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let i=0;i<9;i++)this.coefficients[i].lerp(e.coefficients[i],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return(new this.constructor).copy(this)}fromArray(e,t=0){const i=this.coefficients;for(let r=0;r<9;r++)i[r].fromArray(e,t+3*r);return this}toArray(e=[],t=0){const i=this.coefficients;for(let r=0;r<9;r++)i[r].toArray(e,t+3*r);return e}static getBasisAt(e,t){const i=e.x,r=e.y,n=e.z;t[0]=.282095,t[1]=.488603*r,t[2]=.488603*n,t[3]=.488603*i,t[4]=1.092548*i*r,t[5]=1.092548*r*n,t[6]=.315392*(3*n*n-1),t[7]=1.092548*i*n,t[8]=.546274*(i*i-r*r)}}class LightProbe extends Light{constructor(e=new SphericalHarmonics3,t=1){super(void 0,t),this.isLightProbe=!0,this.sh=e}copy(e){return super.copy(e),this.sh.copy(e.sh),this}fromJSON(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this}toJSON(e){const t=super.toJSON(e);return t.object.sh=this.sh.toArray(),t}}class MaterialLoader extends Loader{constructor(e){super(e),this.textures={}}load(e,t,i,r){const n=this,s=new FileLoader(n.manager);s.setPath(n.path),s.setRequestHeader(n.requestHeader),s.setWithCredentials(n.withCredentials),s.load(e,(function(i){try{t(n.parse(JSON.parse(i)))}catch(s){r?r(s):console.error(s),n.manager.itemError(e)}}),i,r)}parse(e){const t=this.textures;function getTexture(e){return void 0===t[e]&&console.warn("THREE.MaterialLoader: Undefined texture",e),t[e]}const i=MaterialLoader.createMaterialFromType(e.type);if(void 0!==e.uuid&&(i.uuid=e.uuid),void 0!==e.name&&(i.name=e.name),void 0!==e.color&&void 0!==i.color&&i.color.setHex(e.color),void 0!==e.roughness&&(i.roughness=e.roughness),void 0!==e.metalness&&(i.metalness=e.metalness),void 0!==e.sheen&&(i.sheen=e.sheen),void 0!==e.sheenColor&&(i.sheenColor=(new Color).setHex(e.sheenColor)),void 0!==e.sheenRoughness&&(i.sheenRoughness=e.sheenRoughness),void 0!==e.emissive&&void 0!==i.emissive&&i.emissive.setHex(e.emissive),void 0!==e.specular&&void 0!==i.specular&&i.specular.setHex(e.specular),void 0!==e.specularIntensity&&(i.specularIntensity=e.specularIntensity),void 0!==e.specularColor&&void 0!==i.specularColor&&i.specularColor.setHex(e.specularColor),void 0!==e.shininess&&(i.shininess=e.shininess),void 0!==e.clearcoat&&(i.clearcoat=e.clearcoat),void 0!==e.clearcoatRoughness&&(i.clearcoatRoughness=e.clearcoatRoughness),void 0!==e.iridescence&&(i.iridescence=e.iridescence),void 0!==e.iridescenceIOR&&(i.iridescenceIOR=e.iridescenceIOR),void 0!==e.iridescenceThicknessRange&&(i.iridescenceThicknessRange=e.iridescenceThicknessRange),void 0!==e.transmission&&(i.transmission=e.transmission),void 0!==e.thickness&&(i.thickness=e.thickness),void 0!==e.attenuationDistance&&(i.attenuationDistance=e.attenuationDistance),void 0!==e.attenuationColor&&void 0!==i.attenuationColor&&i.attenuationColor.setHex(e.attenuationColor),void 0!==e.fog&&(i.fog=e.fog),void 0!==e.flatShading&&(i.flatShading=e.flatShading),void 0!==e.blending&&(i.blending=e.blending),void 0!==e.combine&&(i.combine=e.combine),void 0!==e.side&&(i.side=e.side),void 0!==e.shadowSide&&(i.shadowSide=e.shadowSide),void 0!==e.opacity&&(i.opacity=e.opacity),void 0!==e.transparent&&(i.transparent=e.transparent),void 0!==e.alphaTest&&(i.alphaTest=e.alphaTest),void 0!==e.depthTest&&(i.depthTest=e.depthTest),void 0!==e.depthWrite&&(i.depthWrite=e.depthWrite),void 0!==e.colorWrite&&(i.colorWrite=e.colorWrite),void 0!==e.stencilWrite&&(i.stencilWrite=e.stencilWrite),void 0!==e.stencilWriteMask&&(i.stencilWriteMask=e.stencilWriteMask),void 0!==e.stencilFunc&&(i.stencilFunc=e.stencilFunc),void 0!==e.stencilRef&&(i.stencilRef=e.stencilRef),void 0!==e.stencilFuncMask&&(i.stencilFuncMask=e.stencilFuncMask),void 0!==e.stencilFail&&(i.stencilFail=e.stencilFail),void 0!==e.stencilZFail&&(i.stencilZFail=e.stencilZFail),void 0!==e.stencilZPass&&(i.stencilZPass=e.stencilZPass),void 0!==e.wireframe&&(i.wireframe=e.wireframe),void 0!==e.wireframeLinewidth&&(i.wireframeLinewidth=e.wireframeLinewidth),void 0!==e.wireframeLinecap&&(i.wireframeLinecap=e.wireframeLinecap),void 0!==e.wireframeLinejoin&&(i.wireframeLinejoin=e.wireframeLinejoin),void 0!==e.rotation&&(i.rotation=e.rotation),1!==e.linewidth&&(i.linewidth=e.linewidth),void 0!==e.dashSize&&(i.dashSize=e.dashSize),void 0!==e.gapSize&&(i.gapSize=e.gapSize),void 0!==e.scale&&(i.scale=e.scale),void 0!==e.polygonOffset&&(i.polygonOffset=e.polygonOffset),void 0!==e.polygonOffsetFactor&&(i.polygonOffsetFactor=e.polygonOffsetFactor),void 0!==e.polygonOffsetUnits&&(i.polygonOffsetUnits=e.polygonOffsetUnits),void 0!==e.dithering&&(i.dithering=e.dithering),void 0!==e.alphaToCoverage&&(i.alphaToCoverage=e.alphaToCoverage),void 0!==e.premultipliedAlpha&&(i.premultipliedAlpha=e.premultipliedAlpha),void 0!==e.visible&&(i.visible=e.visible),void 0!==e.toneMapped&&(i.toneMapped=e.toneMapped),void 0!==e.userData&&(i.userData=e.userData),void 0!==e.vertexColors&&("number"===typeof e.vertexColors?i.vertexColors=e.vertexColors>0:i.vertexColors=e.vertexColors),void 0!==e.uniforms)for(const r in e.uniforms){const t=e.uniforms[r];switch(i.uniforms[r]={},t.type){case"t":i.uniforms[r].value=getTexture(t.value);break;case"c":i.uniforms[r].value=(new Color).setHex(t.value);break;case"v2":i.uniforms[r].value=(new Vector2).fromArray(t.value);break;case"v3":i.uniforms[r].value=(new Vector3).fromArray(t.value);break;case"v4":i.uniforms[r].value=(new Vector4).fromArray(t.value);break;case"m3":i.uniforms[r].value=(new Matrix3).fromArray(t.value);break;case"m4":i.uniforms[r].value=(new Matrix4).fromArray(t.value);break;default:i.uniforms[r].value=t.value}}if(void 0!==e.defines&&(i.defines=e.defines),void 0!==e.vertexShader&&(i.vertexShader=e.vertexShader),void 0!==e.fragmentShader&&(i.fragmentShader=e.fragmentShader),void 0!==e.extensions)for(const r in e.extensions)i.extensions[r]=e.extensions[r];if(void 0!==e.shading&&(i.flatShading=1===e.shading),void 0!==e.size&&(i.size=e.size),void 0!==e.sizeAttenuation&&(i.sizeAttenuation=e.sizeAttenuation),void 0!==e.map&&(i.map=getTexture(e.map)),void 0!==e.matcap&&(i.matcap=getTexture(e.matcap)),void 0!==e.alphaMap&&(i.alphaMap=getTexture(e.alphaMap)),void 0!==e.bumpMap&&(i.bumpMap=getTexture(e.bumpMap)),void 0!==e.bumpScale&&(i.bumpScale=e.bumpScale),void 0!==e.normalMap&&(i.normalMap=getTexture(e.normalMap)),void 0!==e.normalMapType&&(i.normalMapType=e.normalMapType),void 0!==e.normalScale){let t=e.normalScale;!1===Array.isArray(t)&&(t=[t,t]),i.normalScale=(new Vector2).fromArray(t)}return void 0!==e.displacementMap&&(i.displacementMap=getTexture(e.displacementMap)),void 0!==e.displacementScale&&(i.displacementScale=e.displacementScale),void 0!==e.displacementBias&&(i.displacementBias=e.displacementBias),void 0!==e.roughnessMap&&(i.roughnessMap=getTexture(e.roughnessMap)),void 0!==e.metalnessMap&&(i.metalnessMap=getTexture(e.metalnessMap)),void 0!==e.emissiveMap&&(i.emissiveMap=getTexture(e.emissiveMap)),void 0!==e.emissiveIntensity&&(i.emissiveIntensity=e.emissiveIntensity),void 0!==e.specularMap&&(i.specularMap=getTexture(e.specularMap)),void 0!==e.specularIntensityMap&&(i.specularIntensityMap=getTexture(e.specularIntensityMap)),void 0!==e.specularColorMap&&(i.specularColorMap=getTexture(e.specularColorMap)),void 0!==e.envMap&&(i.envMap=getTexture(e.envMap)),void 0!==e.envMapIntensity&&(i.envMapIntensity=e.envMapIntensity),void 0!==e.reflectivity&&(i.reflectivity=e.reflectivity),void 0!==e.refractionRatio&&(i.refractionRatio=e.refractionRatio),void 0!==e.lightMap&&(i.lightMap=getTexture(e.lightMap)),void 0!==e.lightMapIntensity&&(i.lightMapIntensity=e.lightMapIntensity),void 0!==e.aoMap&&(i.aoMap=getTexture(e.aoMap)),void 0!==e.aoMapIntensity&&(i.aoMapIntensity=e.aoMapIntensity),void 0!==e.gradientMap&&(i.gradientMap=getTexture(e.gradientMap)),void 0!==e.clearcoatMap&&(i.clearcoatMap=getTexture(e.clearcoatMap)),void 0!==e.clearcoatRoughnessMap&&(i.clearcoatRoughnessMap=getTexture(e.clearcoatRoughnessMap)),void 0!==e.clearcoatNormalMap&&(i.clearcoatNormalMap=getTexture(e.clearcoatNormalMap)),void 0!==e.clearcoatNormalScale&&(i.clearcoatNormalScale=(new Vector2).fromArray(e.clearcoatNormalScale)),void 0!==e.iridescenceMap&&(i.iridescenceMap=getTexture(e.iridescenceMap)),void 0!==e.iridescenceThicknessMap&&(i.iridescenceThicknessMap=getTexture(e.iridescenceThicknessMap)),void 0!==e.transmissionMap&&(i.transmissionMap=getTexture(e.transmissionMap)),void 0!==e.thicknessMap&&(i.thicknessMap=getTexture(e.thicknessMap)),void 0!==e.sheenColorMap&&(i.sheenColorMap=getTexture(e.sheenColorMap)),void 0!==e.sheenRoughnessMap&&(i.sheenRoughnessMap=getTexture(e.sheenRoughnessMap)),i}setTextures(e){return this.textures=e,this}static createMaterialFromType(e){return new{ShadowMaterial:ShadowMaterial,SpriteMaterial:SpriteMaterial,RawShaderMaterial:RawShaderMaterial,ShaderMaterial:ShaderMaterial,PointsMaterial:PointsMaterial,MeshPhysicalMaterial:MeshPhysicalMaterial,MeshStandardMaterial:MeshStandardMaterial,MeshPhongMaterial:MeshPhongMaterial,MeshToonMaterial:MeshToonMaterial,MeshNormalMaterial:MeshNormalMaterial,MeshLambertMaterial:MeshLambertMaterial,MeshDepthMaterial:MeshDepthMaterial,MeshDistanceMaterial:MeshDistanceMaterial,MeshBasicMaterial:MeshBasicMaterial,MeshMatcapMaterial:MeshMatcapMaterial,LineDashedMaterial:LineDashedMaterial,LineBasicMaterial:LineBasicMaterial,Material:Material}[e]}}class LoaderUtils{static decodeText(e){if("undefined"!==typeof TextDecoder)return(new TextDecoder).decode(e);let t="";for(let r=0,n=e.length;r<n;r++)t+=String.fromCharCode(e[r]);try{return decodeURIComponent(escape(t))}catch(i){return t}}static extractUrlBase(e){const t=e.lastIndexOf("/");return-1===t?"./":e.slice(0,t+1)}static resolveURL(e,t){return"string"!==typeof e||""===e?"":(/^https?:\/\//i.test(t)&&/^\//.test(e)&&(t=t.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:t+e)}}class InstancedBufferGeometry extends BufferGeometry{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(e){return super.copy(e),this.instanceCount=e.instanceCount,this}clone(){return(new this.constructor).copy(this)}toJSON(){const e=super.toJSON(this);return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}class BufferGeometryLoader extends Loader{constructor(e){super(e)}load(e,t,i,r){const n=this,s=new FileLoader(n.manager);s.setPath(n.path),s.setRequestHeader(n.requestHeader),s.setWithCredentials(n.withCredentials),s.load(e,(function(i){try{t(n.parse(JSON.parse(i)))}catch(s){r?r(s):console.error(s),n.manager.itemError(e)}}),i,r)}parse(e){const t={},i={};function getInterleavedBuffer(e,r){if(void 0!==t[r])return t[r];const n=e.interleavedBuffers[r],s=function getArrayBuffer(e,t){if(void 0!==i[t])return i[t];const r=e.arrayBuffers,n=r[t],s=new Uint32Array(n).buffer;return i[t]=s,s}(e,n.buffer),a=getTypedArray(n.type,s),o=new InterleavedBuffer(a,n.stride);return o.uuid=n.uuid,t[r]=o,o}const r=e.isInstancedBufferGeometry?new InstancedBufferGeometry:new BufferGeometry,n=e.data.index;if(void 0!==n){const e=getTypedArray(n.type,n.array);r.setIndex(new BufferAttribute(e,1))}const s=e.data.attributes;for(const c in s){const t=s[c];let i;if(t.isInterleavedBufferAttribute){const r=getInterleavedBuffer(e.data,t.data);i=new InterleavedBufferAttribute(r,t.itemSize,t.offset,t.normalized)}else{const e=getTypedArray(t.type,t.array);i=new(t.isInstancedBufferAttribute?InstancedBufferAttribute:BufferAttribute)(e,t.itemSize,t.normalized)}void 0!==t.name&&(i.name=t.name),void 0!==t.usage&&i.setUsage(t.usage),void 0!==t.updateRange&&(i.updateRange.offset=t.updateRange.offset,i.updateRange.count=t.updateRange.count),r.setAttribute(c,i)}const a=e.data.morphAttributes;if(a)for(const c in a){const t=a[c],i=[];for(let r=0,n=t.length;r<n;r++){const n=t[r];let s;if(n.isInterleavedBufferAttribute){const t=getInterleavedBuffer(e.data,n.data);s=new InterleavedBufferAttribute(t,n.itemSize,n.offset,n.normalized)}else{const e=getTypedArray(n.type,n.array);s=new BufferAttribute(e,n.itemSize,n.normalized)}void 0!==n.name&&(s.name=n.name),i.push(s)}r.morphAttributes[c]=i}e.data.morphTargetsRelative&&(r.morphTargetsRelative=!0);const o=e.data.groups||e.data.drawcalls||e.data.offsets;if(void 0!==o)for(let c=0,h=o.length;c!==h;++c){const e=o[c];r.addGroup(e.start,e.count,e.materialIndex)}const l=e.data.boundingSphere;if(void 0!==l){const e=new Vector3;void 0!==l.center&&e.fromArray(l.center),r.boundingSphere=new Sphere(e,l.radius)}return e.name&&(r.name=e.name),e.userData&&(r.userData=e.userData),r}}class ObjectLoader extends Loader{constructor(e){super(e)}load(e,t,i,r){const n=this,s=""===this.path?LoaderUtils.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||s;const a=new FileLoader(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,(function(i){let s=null;try{s=JSON.parse(i)}catch(o){return void 0!==r&&r(o),void console.error("THREE:ObjectLoader: Can't parse "+e+".",o.message)}const a=s.metadata;void 0!==a&&void 0!==a.type&&"geometry"!==a.type.toLowerCase()?n.parse(s,t):console.error("THREE.ObjectLoader: Can't load "+e)}),i,r)}async loadAsync(e,t){const i=""===this.path?LoaderUtils.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||i;const r=new FileLoader(this.manager);r.setPath(this.path),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials);const n=await r.loadAsync(e,t),s=JSON.parse(n),a=s.metadata;if(void 0===a||void 0===a.type||"geometry"===a.type.toLowerCase())throw new Error("THREE.ObjectLoader: Can't load "+e);return await this.parseAsync(s)}parse(e,t){const i=this.parseAnimations(e.animations),r=this.parseShapes(e.shapes),n=this.parseGeometries(e.geometries,r),s=this.parseImages(e.images,(function(){void 0!==t&&t(l)})),a=this.parseTextures(e.textures,s),o=this.parseMaterials(e.materials,a),l=this.parseObject(e.object,n,o,a,i),c=this.parseSkeletons(e.skeletons,l);if(this.bindSkeletons(l,c),void 0!==t){let e=!1;for(const t in s)if(s[t].data instanceof HTMLImageElement){e=!0;break}!1===e&&t(l)}return l}async parseAsync(e){const t=this.parseAnimations(e.animations),i=this.parseShapes(e.shapes),r=this.parseGeometries(e.geometries,i),n=await this.parseImagesAsync(e.images),s=this.parseTextures(e.textures,n),a=this.parseMaterials(e.materials,s),o=this.parseObject(e.object,r,a,s,t),l=this.parseSkeletons(e.skeletons,o);return this.bindSkeletons(o,l),o}parseShapes(e){const t={};if(void 0!==e)for(let i=0,r=e.length;i<r;i++){const r=(new Shape).fromJSON(e[i]);t[r.uuid]=r}return t}parseSkeletons(e,t){const i={},r={};if(t.traverse((function(e){e.isBone&&(r[e.uuid]=e)})),void 0!==e)for(let n=0,s=e.length;n<s;n++){const t=(new Skeleton).fromJSON(e[n],r);i[t.uuid]=t}return i}parseGeometries(e,t){const i={};if(void 0!==e){const r=new BufferGeometryLoader;for(let n=0,s=e.length;n<s;n++){let s;const a=e[n];switch(a.type){case"BufferGeometry":case"InstancedBufferGeometry":s=r.parse(a);break;case"Geometry":console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");break;default:a.type in Fs?s=Fs[a.type].fromJSON(a,t):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${a.type}"`)}s.uuid=a.uuid,void 0!==a.name&&(s.name=a.name),!0===s.isBufferGeometry&&void 0!==a.userData&&(s.userData=a.userData),i[a.uuid]=s}}return i}parseMaterials(e,t){const i={},r={};if(void 0!==e){const n=new MaterialLoader;n.setTextures(t);for(let t=0,s=e.length;t<s;t++){const s=e[t];if("MultiMaterial"===s.type){const e=[];for(let t=0;t<s.materials.length;t++){const r=s.materials[t];void 0===i[r.uuid]&&(i[r.uuid]=n.parse(r)),e.push(i[r.uuid])}r[s.uuid]=e}else void 0===i[s.uuid]&&(i[s.uuid]=n.parse(s)),r[s.uuid]=i[s.uuid]}}return r}parseAnimations(e){const t={};if(void 0!==e)for(let i=0;i<e.length;i++){const r=e[i],n=AnimationClip.parse(r);t[n.uuid]=n}return t}parseImages(e,t){const i=this,r={};let n;function deserializeImage(e){if("string"===typeof e){const t=e;return function loadImage(e){return i.manager.itemStart(e),n.load(e,(function(){i.manager.itemEnd(e)}),void 0,(function(){i.manager.itemError(e),i.manager.itemEnd(e)}))}(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(t)?t:i.resourcePath+t)}return e.data?{data:getTypedArray(e.type,e.data),width:e.width,height:e.height}:null}if(void 0!==e&&e.length>0){const i=new LoadingManager(t);n=new ImageLoader(i),n.setCrossOrigin(this.crossOrigin);for(let t=0,n=e.length;t<n;t++){const i=e[t],n=i.url;if(Array.isArray(n)){const e=[];for(let t=0,i=n.length;t<i;t++){const i=deserializeImage(n[t]);null!==i&&(i instanceof HTMLImageElement?e.push(i):e.push(new DataTexture(i.data,i.width,i.height)))}r[i.uuid]=new Source(e)}else{const e=deserializeImage(i.url);r[i.uuid]=new Source(e)}}}return r}async parseImagesAsync(e){const t=this,i={};let r;async function deserializeImage(e){if("string"===typeof e){const i=e,n=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(i)?i:t.resourcePath+i;return await r.loadAsync(n)}return e.data?{data:getTypedArray(e.type,e.data),width:e.width,height:e.height}:null}if(void 0!==e&&e.length>0){r=new ImageLoader(this.manager),r.setCrossOrigin(this.crossOrigin);for(let t=0,r=e.length;t<r;t++){const r=e[t],n=r.url;if(Array.isArray(n)){const e=[];for(let t=0,i=n.length;t<i;t++){const i=n[t],r=await deserializeImage(i);null!==r&&(r instanceof HTMLImageElement?e.push(r):e.push(new DataTexture(r.data,r.width,r.height)))}i[r.uuid]=new Source(e)}else{const e=await deserializeImage(r.url);i[r.uuid]=new Source(e)}}}return i}parseTextures(e,t){function parseConstant(e,t){return"number"===typeof e?e:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",e),t[e])}const i={};if(void 0!==e)for(let r=0,n=e.length;r<n;r++){const n=e[r];void 0===n.image&&console.warn('THREE.ObjectLoader: No "image" specified for',n.uuid),void 0===t[n.image]&&console.warn("THREE.ObjectLoader: Undefined image",n.image);const s=t[n.image],a=s.data;let o;Array.isArray(a)?(o=new CubeTexture,6===a.length&&(o.needsUpdate=!0)):(o=a&&a.data?new DataTexture:new Texture,a&&(o.needsUpdate=!0)),o.source=s,o.uuid=n.uuid,void 0!==n.name&&(o.name=n.name),void 0!==n.mapping&&(o.mapping=parseConstant(n.mapping,Js)),void 0!==n.offset&&o.offset.fromArray(n.offset),void 0!==n.repeat&&o.repeat.fromArray(n.repeat),void 0!==n.center&&o.center.fromArray(n.center),void 0!==n.rotation&&(o.rotation=n.rotation),void 0!==n.wrap&&(o.wrapS=parseConstant(n.wrap[0],Ks),o.wrapT=parseConstant(n.wrap[1],Ks)),void 0!==n.format&&(o.format=n.format),void 0!==n.type&&(o.type=n.type),void 0!==n.encoding&&(o.encoding=n.encoding),void 0!==n.minFilter&&(o.minFilter=parseConstant(n.minFilter,Qs)),void 0!==n.magFilter&&(o.magFilter=parseConstant(n.magFilter,Qs)),void 0!==n.anisotropy&&(o.anisotropy=n.anisotropy),void 0!==n.flipY&&(o.flipY=n.flipY),void 0!==n.premultiplyAlpha&&(o.premultiplyAlpha=n.premultiplyAlpha),void 0!==n.unpackAlignment&&(o.unpackAlignment=n.unpackAlignment),void 0!==n.userData&&(o.userData=n.userData),i[n.uuid]=o}return i}parseObject(e,t,i,r,n){let s,a,o;function getGeometry(e){return void 0===t[e]&&console.warn("THREE.ObjectLoader: Undefined geometry",e),t[e]}function getMaterial(e){if(void 0!==e){if(Array.isArray(e)){const t=[];for(let r=0,n=e.length;r<n;r++){const n=e[r];void 0===i[n]&&console.warn("THREE.ObjectLoader: Undefined material",n),t.push(i[n])}return t}return void 0===i[e]&&console.warn("THREE.ObjectLoader: Undefined material",e),i[e]}}function getTexture(e){return void 0===r[e]&&console.warn("THREE.ObjectLoader: Undefined texture",e),r[e]}switch(e.type){case"Scene":s=new Scene,void 0!==e.background&&(Number.isInteger(e.background)?s.background=new Color(e.background):s.background=getTexture(e.background)),void 0!==e.environment&&(s.environment=getTexture(e.environment)),void 0!==e.fog&&("Fog"===e.fog.type?s.fog=new Fog(e.fog.color,e.fog.near,e.fog.far):"FogExp2"===e.fog.type&&(s.fog=new FogExp2(e.fog.color,e.fog.density)));break;case"PerspectiveCamera":s=new PerspectiveCamera(e.fov,e.aspect,e.near,e.far),void 0!==e.focus&&(s.focus=e.focus),void 0!==e.zoom&&(s.zoom=e.zoom),void 0!==e.filmGauge&&(s.filmGauge=e.filmGauge),void 0!==e.filmOffset&&(s.filmOffset=e.filmOffset),void 0!==e.view&&(s.view=Object.assign({},e.view));break;case"OrthographicCamera":s=new OrthographicCamera(e.left,e.right,e.top,e.bottom,e.near,e.far),void 0!==e.zoom&&(s.zoom=e.zoom),void 0!==e.view&&(s.view=Object.assign({},e.view));break;case"AmbientLight":s=new AmbientLight(e.color,e.intensity);break;case"DirectionalLight":s=new DirectionalLight(e.color,e.intensity);break;case"PointLight":s=new PointLight(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":s=new RectAreaLight(e.color,e.intensity,e.width,e.height);break;case"SpotLight":s=new SpotLight(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);break;case"HemisphereLight":s=new HemisphereLight(e.color,e.groundColor,e.intensity);break;case"LightProbe":s=(new LightProbe).fromJSON(e);break;case"SkinnedMesh":a=getGeometry(e.geometry),o=getMaterial(e.material),s=new SkinnedMesh(a,o),void 0!==e.bindMode&&(s.bindMode=e.bindMode),void 0!==e.bindMatrix&&s.bindMatrix.fromArray(e.bindMatrix),void 0!==e.skeleton&&(s.skeleton=e.skeleton);break;case"Mesh":a=getGeometry(e.geometry),o=getMaterial(e.material),s=new Mesh(a,o);break;case"InstancedMesh":a=getGeometry(e.geometry),o=getMaterial(e.material);const t=e.count,i=e.instanceMatrix,r=e.instanceColor;s=new InstancedMesh(a,o,t),s.instanceMatrix=new InstancedBufferAttribute(new Float32Array(i.array),16),void 0!==r&&(s.instanceColor=new InstancedBufferAttribute(new Float32Array(r.array),r.itemSize));break;case"LOD":s=new LOD;break;case"Line":s=new Line(getGeometry(e.geometry),getMaterial(e.material));break;case"LineLoop":s=new LineLoop(getGeometry(e.geometry),getMaterial(e.material));break;case"LineSegments":s=new LineSegments(getGeometry(e.geometry),getMaterial(e.material));break;case"PointCloud":case"Points":s=new Points(getGeometry(e.geometry),getMaterial(e.material));break;case"Sprite":s=new Sprite(getMaterial(e.material));break;case"Group":s=new Group;break;case"Bone":s=new Bone;break;default:s=new Object3D}if(s.uuid=e.uuid,void 0!==e.name&&(s.name=e.name),void 0!==e.matrix?(s.matrix.fromArray(e.matrix),void 0!==e.matrixAutoUpdate&&(s.matrixAutoUpdate=e.matrixAutoUpdate),s.matrixAutoUpdate&&s.matrix.decompose(s.position,s.quaternion,s.scale)):(void 0!==e.position&&s.position.fromArray(e.position),void 0!==e.rotation&&s.rotation.fromArray(e.rotation),void 0!==e.quaternion&&s.quaternion.fromArray(e.quaternion),void 0!==e.scale&&s.scale.fromArray(e.scale)),void 0!==e.castShadow&&(s.castShadow=e.castShadow),void 0!==e.receiveShadow&&(s.receiveShadow=e.receiveShadow),e.shadow&&(void 0!==e.shadow.bias&&(s.shadow.bias=e.shadow.bias),void 0!==e.shadow.normalBias&&(s.shadow.normalBias=e.shadow.normalBias),void 0!==e.shadow.radius&&(s.shadow.radius=e.shadow.radius),void 0!==e.shadow.mapSize&&s.shadow.mapSize.fromArray(e.shadow.mapSize),void 0!==e.shadow.camera&&(s.shadow.camera=this.parseObject(e.shadow.camera))),void 0!==e.visible&&(s.visible=e.visible),void 0!==e.frustumCulled&&(s.frustumCulled=e.frustumCulled),void 0!==e.renderOrder&&(s.renderOrder=e.renderOrder),void 0!==e.userData&&(s.userData=e.userData),void 0!==e.layers&&(s.layers.mask=e.layers),void 0!==e.children){const a=e.children;for(let e=0;e<a.length;e++)s.add(this.parseObject(a[e],t,i,r,n))}if(void 0!==e.animations){const t=e.animations;for(let e=0;e<t.length;e++){const i=t[e];s.animations.push(n[i])}}if("LOD"===e.type){void 0!==e.autoUpdate&&(s.autoUpdate=e.autoUpdate);const t=e.levels;for(let e=0;e<t.length;e++){const i=t[e],r=s.getObjectByProperty("uuid",i.object);void 0!==r&&s.addLevel(r,i.distance)}}return s}bindSkeletons(e,t){0!==Object.keys(t).length&&e.traverse((function(e){if(!0===e.isSkinnedMesh&&void 0!==e.skeleton){const i=t[e.skeleton];void 0===i?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",e.skeleton):e.bind(i,e.bindMatrix)}}))}}const Js={UVMapping:ne,CubeReflectionMapping:se,CubeRefractionMapping:ae,EquirectangularReflectionMapping:oe,EquirectangularRefractionMapping:le,CubeUVReflectionMapping:ce},Ks={RepeatWrapping:he,ClampToEdgeWrapping:ue,MirroredRepeatWrapping:de},Qs={NearestFilter:pe,NearestMipmapNearestFilter:me,NearestMipmapLinearFilter:ge,LinearFilter:xe,LinearMipmapNearestFilter:ye,LinearMipmapLinearFilter:be};class ImageBitmapLoader extends Loader{constructor(e){super(e),this.isImageBitmapLoader=!0,"undefined"===typeof createImageBitmap&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),"undefined"===typeof fetch&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,t,i,r){void 0===e&&(e=""),void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);const n=this,s=Us.get(e);if(void 0!==s)return n.manager.itemStart(e),setTimeout((function(){t&&t(s),n.manager.itemEnd(e)}),0),s;const a={};a.credentials="anonymous"===this.crossOrigin?"same-origin":"include",a.headers=this.requestHeader,fetch(e,a).then((function(e){return e.blob()})).then((function(e){return createImageBitmap(e,Object.assign(n.options,{colorSpaceConversion:"none"}))})).then((function(i){Us.add(e,i),t&&t(i),n.manager.itemEnd(e)})).catch((function(t){r&&r(t),n.manager.itemError(e),n.manager.itemEnd(e)})),n.manager.itemStart(e)}}let $s;const ea={getContext:function(){return void 0===$s&&($s=new(window.AudioContext||window.webkitAudioContext)),$s},setContext:function(e){$s=e}};class AudioLoader extends Loader{constructor(e){super(e)}load(e,t,i,r){const n=this,s=new FileLoader(this.manager);s.setResponseType("arraybuffer"),s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials),s.load(e,(function(i){try{const e=i.slice(0);ea.getContext().decodeAudioData(e,(function(e){t(e)}))}catch(s){r?r(s):console.error(s),n.manager.itemError(e)}}),i,r)}}class HemisphereLightProbe extends LightProbe{constructor(e,t,i=1){super(void 0,i),this.isHemisphereLightProbe=!0;const r=(new Color).set(e),n=(new Color).set(t),s=new Vector3(r.r,r.g,r.b),a=new Vector3(n.r,n.g,n.b),o=Math.sqrt(Math.PI),l=o*Math.sqrt(.75);this.sh.coefficients[0].copy(s).add(a).multiplyScalar(o),this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(l)}}class AmbientLightProbe extends LightProbe{constructor(e,t=1){super(void 0,t),this.isAmbientLightProbe=!0;const i=(new Color).set(e);this.sh.coefficients[0].set(i.r,i.g,i.b).multiplyScalar(2*Math.sqrt(Math.PI))}}const ta=new Matrix4,ia=new Matrix4,ra=new Matrix4;class StereoCamera{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new PerspectiveCamera,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new PerspectiveCamera,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(e){const t=this._cache;if(t.focus!==e.focus||t.fov!==e.fov||t.aspect!==e.aspect*this.aspect||t.near!==e.near||t.far!==e.far||t.zoom!==e.zoom||t.eyeSep!==this.eyeSep){t.focus=e.focus,t.fov=e.fov,t.aspect=e.aspect*this.aspect,t.near=e.near,t.far=e.far,t.zoom=e.zoom,t.eyeSep=this.eyeSep,ra.copy(e.projectionMatrix);const i=t.eyeSep/2,r=i*t.near/t.focus,n=t.near*Math.tan(vi*t.fov*.5)/t.zoom;let s,a;ia.elements[12]=-i,ta.elements[12]=i,s=-n*t.aspect+r,a=n*t.aspect+r,ra.elements[0]=2*t.near/(a-s),ra.elements[8]=(a+s)/(a-s),this.cameraL.projectionMatrix.copy(ra),s=-n*t.aspect-r,a=n*t.aspect-r,ra.elements[0]=2*t.near/(a-s),ra.elements[8]=(a+s)/(a-s),this.cameraR.projectionMatrix.copy(ra)}this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(ia),this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(ta)}}class Clock{constructor(e=!0){this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=now(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=now();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}function now(){return("undefined"===typeof performance?Date:performance).now()}const na=new Vector3,sa=new Quaternion,aa=new Vector3,oa=new Vector3;class AudioListener extends Object3D{constructor(){super(),this.type="AudioListener",this.context=ea.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new Clock}getInput(){return this.gain}removeFilter(){return null!==this.filter&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(e){return null!==this.filter?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=e,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}updateMatrixWorld(e){super.updateMatrixWorld(e);const t=this.context.listener,i=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(na,sa,aa),oa.set(0,0,-1).applyQuaternion(sa),t.positionX){const e=this.context.currentTime+this.timeDelta;t.positionX.linearRampToValueAtTime(na.x,e),t.positionY.linearRampToValueAtTime(na.y,e),t.positionZ.linearRampToValueAtTime(na.z,e),t.forwardX.linearRampToValueAtTime(oa.x,e),t.forwardY.linearRampToValueAtTime(oa.y,e),t.forwardZ.linearRampToValueAtTime(oa.z,e),t.upX.linearRampToValueAtTime(i.x,e),t.upY.linearRampToValueAtTime(i.y,e),t.upZ.linearRampToValueAtTime(i.z,e)}else t.setPosition(na.x,na.y,na.z),t.setOrientation(oa.x,oa.y,oa.z,i.x,i.y,i.z)}}class Audio extends Object3D{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(!0===this.isPlaying)return void console.warn("THREE.Audio: Audio is already playing.");if(!1===this.hasPlaybackControl)return void console.warn("THREE.Audio: this Audio has no playback control.");this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(!1!==this.hasPlaybackControl)return!0===this.isPlaying&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,!0===this.loop&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this;console.warn("THREE.Audio: this Audio has no playback control.")}stop(){if(!1!==this.hasPlaybackControl)return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this;console.warn("THREE.Audio: this Audio has no playback control.")}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(e){return e||(e=[]),!0===this._connected?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){if(this.detune=e,void 0!==this.source.detune)return!0===this.isPlaying&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(!1!==this.hasPlaybackControl)return this.playbackRate=e,!0===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this;console.warn("THREE.Audio: this Audio has no playback control.")}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return!1===this.hasPlaybackControl?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(!1!==this.hasPlaybackControl)return this.loop=e,!0===this.isPlaying&&(this.source.loop=this.loop),this;console.warn("THREE.Audio: this Audio has no playback control.")}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}}const la=new Vector3,ca=new Quaternion,ha=new Vector3,ua=new Vector3;class PositionalAudio extends Audio{constructor(e){super(e),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}disconnect(){super.disconnect(),this.panner.disconnect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(e){return this.panner.refDistance=e,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(e){return this.panner.rolloffFactor=e,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(e){return this.panner.distanceModel=e,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(e){return this.panner.maxDistance=e,this}setDirectionalCone(e,t,i){return this.panner.coneInnerAngle=e,this.panner.coneOuterAngle=t,this.panner.coneOuterGain=i,this}updateMatrixWorld(e){if(super.updateMatrixWorld(e),!0===this.hasPlaybackControl&&!1===this.isPlaying)return;this.matrixWorld.decompose(la,ca,ha),ua.set(0,0,1).applyQuaternion(ca);const t=this.panner;if(t.positionX){const e=this.context.currentTime+this.listener.timeDelta;t.positionX.linearRampToValueAtTime(la.x,e),t.positionY.linearRampToValueAtTime(la.y,e),t.positionZ.linearRampToValueAtTime(la.z,e),t.orientationX.linearRampToValueAtTime(ua.x,e),t.orientationY.linearRampToValueAtTime(ua.y,e),t.orientationZ.linearRampToValueAtTime(ua.z,e)}else t.setPosition(la.x,la.y,la.z),t.setOrientation(ua.x,ua.y,ua.z)}}class AudioAnalyser{constructor(e,t=2048){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=t,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let e=0;const t=this.getFrequencyData();for(let i=0;i<t.length;i++)e+=t[i];return e/t.length}}class PropertyMixer{constructor(e,t,i){let r,n,s;switch(this.binding=e,this.valueSize=i,t){case"quaternion":r=this._slerp,n=this._slerpAdditive,s=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*i),this._workIndex=5;break;case"string":case"bool":r=this._select,n=this._select,s=this._setAdditiveIdentityOther,this.buffer=new Array(5*i);break;default:r=this._lerp,n=this._lerpAdditive,s=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*i)}this._mixBufferRegion=r,this._mixBufferRegionAdditive=n,this._setIdentity=s,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(e,t){const i=this.buffer,r=this.valueSize,n=e*r+r;let s=this.cumulativeWeight;if(0===s){for(let e=0;e!==r;++e)i[n+e]=i[e];s=t}else{s+=t;const e=t/s;this._mixBufferRegion(i,n,0,e,r)}this.cumulativeWeight=s}accumulateAdditive(e){const t=this.buffer,i=this.valueSize,r=i*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity(),this._mixBufferRegionAdditive(t,r,0,e,i),this.cumulativeWeightAdditive+=e}apply(e){const t=this.valueSize,i=this.buffer,r=e*t+t,n=this.cumulativeWeight,s=this.cumulativeWeightAdditive,a=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,n<1){const e=t*this._origIndex;this._mixBufferRegion(i,r,e,1-n,t)}s>0&&this._mixBufferRegionAdditive(i,r,this._addIndex*t,1,t);for(let o=t,l=t+t;o!==l;++o)if(i[o]!==i[o+t]){a.setValue(i,r);break}}saveOriginalState(){const e=this.binding,t=this.buffer,i=this.valueSize,r=i*this._origIndex;e.getValue(t,r);for(let n=i,s=r;n!==s;++n)t[n]=t[r+n%i];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const e=3*this.valueSize;this.binding.setValue(this.buffer,e)}_setAdditiveIdentityNumeric(){const e=this._addIndex*this.valueSize,t=e+this.valueSize;for(let i=e;i<t;i++)this.buffer[i]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize;for(let i=0;i<this.valueSize;i++)this.buffer[t+i]=this.buffer[e+i]}_select(e,t,i,r,n){if(r>=.5)for(let s=0;s!==n;++s)e[t+s]=e[i+s]}_slerp(e,t,i,r){Quaternion.slerpFlat(e,t,e,t,e,i,r)}_slerpAdditive(e,t,i,r,n){const s=this._workIndex*n;Quaternion.multiplyQuaternionsFlat(e,s,e,t,e,i),Quaternion.slerpFlat(e,t,e,t,e,s,r)}_lerp(e,t,i,r,n){const s=1-r;for(let a=0;a!==n;++a){const n=t+a;e[n]=e[n]*s+e[i+a]*r}}_lerpAdditive(e,t,i,r,n){for(let s=0;s!==n;++s){const n=t+s;e[n]=e[n]+e[i+s]*r}}}const da="\\[\\]\\.:\\/",pa=new RegExp("["+da+"]","g"),ma="[^"+da+"]",fa="[^"+da.replace("\\.","")+"]",ga=new RegExp("^"+/((?:WC+[\/:])*)/.source.replace("WC",ma)+/(WCOD+)?/.source.replace("WCOD",fa)+/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",ma)+/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",ma)+"$"),va=["material","materials","bones"];class PropertyBinding{constructor(e,t,i){this.path=t,this.parsedPath=i||PropertyBinding.parseTrackName(t),this.node=PropertyBinding.findNode(e,this.parsedPath.nodeName)||e,this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,t,i){return e&&e.isAnimationObjectGroup?new PropertyBinding.Composite(e,t,i):new PropertyBinding(e,t,i)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(pa,"")}static parseTrackName(e){const t=ga.exec(e);if(null===t)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const i={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},r=i.nodeName&&i.nodeName.lastIndexOf(".");if(void 0!==r&&-1!==r){const e=i.nodeName.substring(r+1);-1!==va.indexOf(e)&&(i.nodeName=i.nodeName.substring(0,r),i.objectName=e)}if(null===i.propertyName||0===i.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return i}static findNode(e,t){if(void 0===t||""===t||"."===t||-1===t||t===e.name||t===e.uuid)return e;if(e.skeleton){const i=e.skeleton.getBoneByName(t);if(void 0!==i)return i}if(e.children){const searchNodeSubtree=function(e){for(let i=0;i<e.length;i++){const r=e[i];if(r.name===t||r.uuid===t)return r;const n=searchNodeSubtree(r.children);if(n)return n}return null},i=searchNodeSubtree(e.children);if(i)return i}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,t){e[t]=this.targetObject[this.propertyName]}_getValue_array(e,t){const i=this.resolvedProperty;for(let r=0,n=i.length;r!==n;++r)e[t++]=i[r]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,t){const i=this.resolvedProperty;for(let r=0,n=i.length;r!==n;++r)i[r]=e[t++]}_setValue_array_setNeedsUpdate(e,t){const i=this.resolvedProperty;for(let r=0,n=i.length;r!==n;++r)i[r]=e[t++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,t){const i=this.resolvedProperty;for(let r=0,n=i.length;r!==n;++r)i[r]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,t){this.bind(),this.getValue(e,t)}_setValue_unbound(e,t){this.bind(),this.setValue(e,t)}bind(){let e=this.node;const t=this.parsedPath,i=t.objectName,r=t.propertyName;let n=t.propertyIndex;if(e||(e=PropertyBinding.findNode(this.rootNode,t.nodeName)||this.rootNode,this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e)return void console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");if(i){let r=t.objectIndex;switch(i){case"materials":if(!e.material)return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);if(!e.material.materials)return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);e=e.material.materials;break;case"bones":if(!e.skeleton)return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);e=e.skeleton.bones;for(let t=0;t<e.length;t++)if(e[t].name===r){r=t;break}break;default:if(void 0===e[i])return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);e=e[i]}if(void 0!==r){if(void 0===e[r])return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);e=e[r]}}const s=e[r];if(void 0===s){const i=t.nodeName;return void console.error("THREE.PropertyBinding: Trying to update property for track: "+i+"."+r+" but it wasn't found.",e)}let a=this.Versioning.None;this.targetObject=e,void 0!==e.needsUpdate?a=this.Versioning.NeedsUpdate:void 0!==e.matrixWorldNeedsUpdate&&(a=this.Versioning.MatrixWorldNeedsUpdate);let o=this.BindingType.Direct;if(void 0!==n){if("morphTargetInfluences"===r){if(!e.geometry)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!e.geometry.morphAttributes)return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);void 0!==e.morphTargetDictionary[n]&&(n=e.morphTargetDictionary[n])}o=this.BindingType.ArrayElement,this.resolvedProperty=s,this.propertyIndex=n}else void 0!==s.fromArray&&void 0!==s.toArray?(o=this.BindingType.HasFromToArray,this.resolvedProperty=s):Array.isArray(s)?(o=this.BindingType.EntireArray,this.resolvedProperty=s):this.propertyName=r;this.getValue=this.GetterByBindingType[o],this.setValue=this.SetterByBindingTypeAndVersioning[o][a]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}PropertyBinding.Composite=class Composite{constructor(e,t,i){const r=i||PropertyBinding.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,r)}getValue(e,t){this.bind();const i=this._targetGroup.nCachedObjects_,r=this._bindings[i];void 0!==r&&r.getValue(e,t)}setValue(e,t){const i=this._bindings;for(let r=this._targetGroup.nCachedObjects_,n=i.length;r!==n;++r)i[r].setValue(e,t)}bind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,i=e.length;t!==i;++t)e[t].bind()}unbind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,i=e.length;t!==i;++t)e[t].unbind()}},PropertyBinding.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},PropertyBinding.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},PropertyBinding.prototype.GetterByBindingType=[PropertyBinding.prototype._getValue_direct,PropertyBinding.prototype._getValue_array,PropertyBinding.prototype._getValue_arrayElement,PropertyBinding.prototype._getValue_toArray],PropertyBinding.prototype.SetterByBindingTypeAndVersioning=[[PropertyBinding.prototype._setValue_direct,PropertyBinding.prototype._setValue_direct_setNeedsUpdate,PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[PropertyBinding.prototype._setValue_array,PropertyBinding.prototype._setValue_array_setNeedsUpdate,PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate],[PropertyBinding.prototype._setValue_arrayElement,PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[PropertyBinding.prototype._setValue_fromArray,PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class AnimationObjectGroup{constructor(){this.isAnimationObjectGroup=!0,this.uuid=generateUUID(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const e={};this._indicesByUUID=e;for(let i=0,r=arguments.length;i!==r;++i)e[arguments[i].uuid]=i;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const t=this;this.stats={objects:{get total(){return t._objects.length},get inUse(){return this.total-t.nCachedObjects_}},get bindingsPerObject(){return t._bindings.length}}}add(){const e=this._objects,t=this._indicesByUUID,i=this._paths,r=this._parsedPaths,n=this._bindings,s=n.length;let a,o=e.length,l=this.nCachedObjects_;for(let c=0,h=arguments.length;c!==h;++c){const h=arguments[c],u=h.uuid;let d=t[u];if(void 0===d){d=o++,t[u]=d,e.push(h);for(let e=0,t=s;e!==t;++e)n[e].push(new PropertyBinding(h,i[e],r[e]))}else if(d<l){a=e[d];const o=--l,c=e[o];t[c.uuid]=d,e[d]=c,t[u]=o,e[o]=h;for(let e=0,t=s;e!==t;++e){const t=n[e],s=t[o];let a=t[d];t[d]=s,void 0===a&&(a=new PropertyBinding(h,i[e],r[e])),t[o]=a}}else e[d]!==a&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=l}remove(){const e=this._objects,t=this._indicesByUUID,i=this._bindings,r=i.length;let n=this.nCachedObjects_;for(let s=0,a=arguments.length;s!==a;++s){const a=arguments[s],o=a.uuid,l=t[o];if(void 0!==l&&l>=n){const s=n++,c=e[s];t[c.uuid]=l,e[l]=c,t[o]=s,e[s]=a;for(let e=0,t=r;e!==t;++e){const t=i[e],r=t[s],n=t[l];t[l]=r,t[s]=n}}}this.nCachedObjects_=n}uncache(){const e=this._objects,t=this._indicesByUUID,i=this._bindings,r=i.length;let n=this.nCachedObjects_,s=e.length;for(let a=0,o=arguments.length;a!==o;++a){const o=arguments[a].uuid,l=t[o];if(void 0!==l)if(delete t[o],l<n){const a=--n,o=e[a],c=--s,h=e[c];t[o.uuid]=l,e[l]=o,t[h.uuid]=a,e[a]=h,e.pop();for(let e=0,t=r;e!==t;++e){const t=i[e],r=t[a],n=t[c];t[l]=r,t[a]=n,t.pop()}}else{const n=--s,a=e[n];n>0&&(t[a.uuid]=l),e[l]=a,e.pop();for(let e=0,t=r;e!==t;++e){const t=i[e];t[l]=t[n],t.pop()}}}this.nCachedObjects_=n}subscribe_(e,t){const i=this._bindingsIndicesByPath;let r=i[e];const n=this._bindings;if(void 0!==r)return n[r];const s=this._paths,a=this._parsedPaths,o=this._objects,l=o.length,c=this.nCachedObjects_,h=new Array(l);r=n.length,i[e]=r,s.push(e),a.push(t),n.push(h);for(let u=c,d=o.length;u!==d;++u){const i=o[u];h[u]=new PropertyBinding(i,e,t)}return h}unsubscribe_(e){const t=this._bindingsIndicesByPath,i=t[e];if(void 0!==i){const r=this._paths,n=this._parsedPaths,s=this._bindings,a=s.length-1,o=s[a];t[e[a]]=i,s[i]=o,s.pop(),n[i]=n[a],n.pop(),r[i]=r[a],r.pop()}}}class AnimationAction{constructor(e,t,i=null,r=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=i,this.blendMode=r;const n=t.tracks,s=n.length,a=new Array(s),o={endingStart:wt,endingEnd:wt};for(let l=0;l!==s;++l){const e=n[l].createInterpolant(null);a[l]=e,e.settings=o}this._interpolantSettings=o,this._interpolants=a,this._propertyBindings=new Array(s),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=yt,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,i){if(e.fadeOut(t),this.fadeIn(t),i){const i=this._clip.duration,r=e._clip.duration,n=r/i,s=i/r;e.warp(1,n,t),this.warp(s,1,t)}return this}crossFadeTo(e,t,i){return e.crossFadeFrom(this,t,i)}stopFading(){const e=this._weightInterpolant;return null!==e&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,i){const r=this._mixer,n=r.time,s=this.timeScale;let a=this._timeScaleInterpolant;null===a&&(a=r._lendControlInterpolant(),this._timeScaleInterpolant=a);const o=a.parameterPositions,l=a.sampleValues;return o[0]=n,o[1]=n+i,l[0]=e/s,l[1]=t/s,this}stopWarping(){const e=this._timeScaleInterpolant;return null!==e&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,i,r){if(!this.enabled)return void this._updateWeight(e);const n=this._startTime;if(null!==n){const r=(e-n)*i;if(r<0||0===i)return;this._startTime=null,t=i*r}t*=this._updateTimeScale(e);const s=this._updateTime(t),a=this._updateWeight(e);if(a>0){const e=this._interpolants,t=this._propertyBindings;if(this.blendMode===Et)for(let i=0,r=e.length;i!==r;++i)e[i].evaluate(s),t[i].accumulateAdditive(a);else for(let i=0,n=e.length;i!==n;++i)e[i].evaluate(s),t[i].accumulate(r,a)}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const i=this._weightInterpolant;if(null!==i){const r=i.evaluate(e)[0];t*=r,e>i.parameterPositions[1]&&(this.stopFading(),0===r&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const i=this._timeScaleInterpolant;if(null!==i){t*=i.evaluate(e)[0],e>i.parameterPositions[1]&&(this.stopWarping(),0===t?this.paused=!0:this.timeScale=t)}}return this._effectiveTimeScale=t,t}_updateTime(e){const t=this._clip.duration,i=this.loop;let r=this.time+e,n=this._loopCount;const s=i===_t;if(0===e)return-1===n?r:s&&1===(1&n)?t-r:r;if(i===xt){-1===n&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(r>=t)r=t;else{if(!(r<0)){this.time=r;break e}r=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(-1===n&&(e>=0?(n=0,this._setEndings(!0,0===this.repetitions,s)):this._setEndings(0===this.repetitions,!0,s)),r>=t||r<0){const i=Math.floor(r/t);r-=t*i,n+=Math.abs(i);const a=this.repetitions-n;if(a<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,r=e>0?t:0,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(1===a){const t=e<0;this._setEndings(t,!t,s)}else this._setEndings(!1,!1,s);this._loopCount=n,this.time=r,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:i})}}else this.time=r;if(s&&1===(1&n))return t-r}return r}_setEndings(e,t,i){const r=this._interpolantSettings;i?(r.endingStart=Tt,r.endingEnd=Tt):(r.endingStart=e?this.zeroSlopeAtStart?Tt:wt:At,r.endingEnd=t?this.zeroSlopeAtEnd?Tt:wt:At)}_scheduleFading(e,t,i){const r=this._mixer,n=r.time;let s=this._weightInterpolant;null===s&&(s=r._lendControlInterpolant(),this._weightInterpolant=s);const a=s.parameterPositions,o=s.sampleValues;return a[0]=n,o[0]=t,a[1]=n+e,o[1]=i,this}}const xa=new Float32Array(1);class AnimationMixer extends EventDispatcher{constructor(e){super(),this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(e,t){const i=e._localRoot||this._root,r=e._clip.tracks,n=r.length,s=e._propertyBindings,a=e._interpolants,o=i.uuid,l=this._bindingsByRootAndName;let c=l[o];void 0===c&&(c={},l[o]=c);for(let h=0;h!==n;++h){const e=r[h],n=e.name;let l=c[n];if(void 0!==l)++l.referenceCount,s[h]=l;else{if(l=s[h],void 0!==l){null===l._cacheIndex&&(++l.referenceCount,this._addInactiveBinding(l,o,n));continue}const r=t&&t._propertyBindings[h].binding.parsedPath;l=new PropertyMixer(PropertyBinding.create(i,n,r),e.ValueTypeName,e.getValueSize()),++l.referenceCount,this._addInactiveBinding(l,o,n),s[h]=l}a[h].resultBuffer=l.buffer}}_activateAction(e){if(!this._isActiveAction(e)){if(null===e._cacheIndex){const t=(e._localRoot||this._root).uuid,i=e._clip.uuid,r=this._actionsByClip[i];this._bindAction(e,r&&r.knownActions[0]),this._addInactiveAction(e,i,t)}const t=e._propertyBindings;for(let e=0,i=t.length;e!==i;++e){const i=t[e];0===i.useCount++&&(this._lendBinding(i),i.saveOriginalState())}this._lendAction(e)}}_deactivateAction(e){if(this._isActiveAction(e)){const t=e._propertyBindings;for(let e=0,i=t.length;e!==i;++e){const i=t[e];0===--i.useCount&&(i.restoreOriginalState(),this._takeBackBinding(i))}this._takeBackAction(e)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}}_isActiveAction(e){const t=e._cacheIndex;return null!==t&&t<this._nActiveActions}_addInactiveAction(e,t,i){const r=this._actions,n=this._actionsByClip;let s=n[t];if(void 0===s)s={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,n[t]=s;else{const t=s.knownActions;e._byClipCacheIndex=t.length,t.push(e)}e._cacheIndex=r.length,r.push(e),s.actionByRoot[i]=e}_removeInactiveAction(e){const t=this._actions,i=t[t.length-1],r=e._cacheIndex;i._cacheIndex=r,t[r]=i,t.pop(),e._cacheIndex=null;const n=e._clip.uuid,s=this._actionsByClip,a=s[n],o=a.knownActions,l=o[o.length-1],c=e._byClipCacheIndex;l._byClipCacheIndex=c,o[c]=l,o.pop(),e._byClipCacheIndex=null;delete a.actionByRoot[(e._localRoot||this._root).uuid],0===o.length&&delete s[n],this._removeInactiveBindingsForAction(e)}_removeInactiveBindingsForAction(e){const t=e._propertyBindings;for(let i=0,r=t.length;i!==r;++i){const e=t[i];0===--e.referenceCount&&this._removeInactiveBinding(e)}}_lendAction(e){const t=this._actions,i=e._cacheIndex,r=this._nActiveActions++,n=t[r];e._cacheIndex=r,t[r]=e,n._cacheIndex=i,t[i]=n}_takeBackAction(e){const t=this._actions,i=e._cacheIndex,r=--this._nActiveActions,n=t[r];e._cacheIndex=r,t[r]=e,n._cacheIndex=i,t[i]=n}_addInactiveBinding(e,t,i){const r=this._bindingsByRootAndName,n=this._bindings;let s=r[t];void 0===s&&(s={},r[t]=s),s[i]=e,e._cacheIndex=n.length,n.push(e)}_removeInactiveBinding(e){const t=this._bindings,i=e.binding,r=i.rootNode.uuid,n=i.path,s=this._bindingsByRootAndName,a=s[r],o=t[t.length-1],l=e._cacheIndex;o._cacheIndex=l,t[l]=o,t.pop(),delete a[n],0===Object.keys(a).length&&delete s[r]}_lendBinding(e){const t=this._bindings,i=e._cacheIndex,r=this._nActiveBindings++,n=t[r];e._cacheIndex=r,t[r]=e,n._cacheIndex=i,t[i]=n}_takeBackBinding(e){const t=this._bindings,i=e._cacheIndex,r=--this._nActiveBindings,n=t[r];e._cacheIndex=r,t[r]=e,n._cacheIndex=i,t[i]=n}_lendControlInterpolant(){const e=this._controlInterpolants,t=this._nActiveControlInterpolants++;let i=e[t];return void 0===i&&(i=new LinearInterpolant(new Float32Array(2),new Float32Array(2),1,xa),i.__cacheIndex=t,e[t]=i),i}_takeBackControlInterpolant(e){const t=this._controlInterpolants,i=e.__cacheIndex,r=--this._nActiveControlInterpolants,n=t[r];e.__cacheIndex=r,t[r]=e,n.__cacheIndex=i,t[i]=n}clipAction(e,t,i){const r=t||this._root,n=r.uuid;let s="string"===typeof e?AnimationClip.findByName(r,e):e;const a=null!==s?s.uuid:e,o=this._actionsByClip[a];let l=null;if(void 0===i&&(i=null!==s?s.blendMode:Ct),void 0!==o){const e=o.actionByRoot[n];if(void 0!==e&&e.blendMode===i)return e;l=o.knownActions[0],null===s&&(s=l._clip)}if(null===s)return null;const c=new AnimationAction(this,s,t,i);return this._bindAction(c,l),this._addInactiveAction(c,a,n),c}existingAction(e,t){const i=t||this._root,r=i.uuid,n="string"===typeof e?AnimationClip.findByName(i,e):e,s=n?n.uuid:e,a=this._actionsByClip[s];return void 0!==a&&a.actionByRoot[r]||null}stopAllAction(){const e=this._actions;for(let t=this._nActiveActions-1;t>=0;--t)e[t].stop();return this}update(e){e*=this.timeScale;const t=this._actions,i=this._nActiveActions,r=this.time+=e,n=Math.sign(e),s=this._accuIndex^=1;for(let l=0;l!==i;++l){t[l]._update(r,e,n,s)}const a=this._bindings,o=this._nActiveBindings;for(let l=0;l!==o;++l)a[l].apply(s);return this}setTime(e){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(e)}getRoot(){return this._root}uncacheClip(e){const t=this._actions,i=e.uuid,r=this._actionsByClip,n=r[i];if(void 0!==n){const e=n.knownActions;for(let i=0,r=e.length;i!==r;++i){const r=e[i];this._deactivateAction(r);const n=r._cacheIndex,s=t[t.length-1];r._cacheIndex=null,r._byClipCacheIndex=null,s._cacheIndex=n,t[n]=s,t.pop(),this._removeInactiveBindingsForAction(r)}delete r[i]}}uncacheRoot(e){const t=e.uuid,i=this._actionsByClip;for(const n in i){const e=i[n].actionByRoot[t];void 0!==e&&(this._deactivateAction(e),this._removeInactiveAction(e))}const r=this._bindingsByRootAndName[t];if(void 0!==r)for(const n in r){const e=r[n];e.restoreOriginalState(),this._removeInactiveBinding(e)}}uncacheAction(e,t){const i=this.existingAction(e,t);null!==i&&(this._deactivateAction(i),this._removeInactiveAction(i))}}class Uniform{constructor(e){"string"===typeof e&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),e=arguments[1]),this.value=e}clone(){return new Uniform(void 0===this.value.clone?this.value:this.value.clone())}}let ya=0;class UniformsGroup extends EventDispatcher{constructor(){super(),this.isUniformsGroup=!0,Object.defineProperty(this,"id",{value:ya++}),this.name="",this.usage=ri,this.uniforms=[]}add(e){return this.uniforms.push(e),this}remove(e){const t=this.uniforms.indexOf(e);return-1!==t&&this.uniforms.splice(t,1),this}setName(e){return this.name=e,this}setUsage(e){return this.usage=e,this}dispose(){return this.dispatchEvent({type:"dispose"}),this}copy(e){this.name=e.name,this.usage=e.usage;const t=e.uniforms;this.uniforms.length=0;for(let i=0,r=t.length;i<r;i++)this.uniforms.push(t[i].clone());return this}clone(){return(new this.constructor).copy(this)}}class InstancedInterleavedBuffer extends InterleavedBuffer{constructor(e,t,i=1){super(e,t),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=i}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}clone(e){const t=super.clone(e);return t.meshPerAttribute=this.meshPerAttribute,t}toJSON(e){const t=super.toJSON(e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}}class GLBufferAttribute{constructor(e,t,i,r,n){this.isGLBufferAttribute=!0,this.buffer=e,this.type=t,this.itemSize=i,this.elementSize=r,this.count=n,this.version=0}set needsUpdate(e){!0===e&&this.version++}setBuffer(e){return this.buffer=e,this}setType(e,t){return this.type=e,this.elementSize=t,this}setItemSize(e){return this.itemSize=e,this}setCount(e){return this.count=e,this}}class Raycaster{constructor(e,t,i=0,r=1/0){this.ray=new Ray(e,t),this.near=i,this.far=r,this.camera=null,this.layers=new Layers,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(e,t){this.ray.set(e,t)}setFromCamera(e,t){t.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t):t.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t):console.error("THREE.Raycaster: Unsupported camera type: "+t.type)}intersectObject(e,t=!0,i=[]){return intersectObject(e,this,i,t),i.sort(ascSort),i}intersectObjects(e,t=!0,i=[]){for(let r=0,n=e.length;r<n;r++)intersectObject(e[r],this,i,t);return i.sort(ascSort),i}}function ascSort(e,t){return e.distance-t.distance}function intersectObject(e,t,i,r){if(e.layers.test(t.layers)&&e.raycast(t,i),!0===r){const r=e.children;for(let e=0,n=r.length;e<n;e++)intersectObject(r[e],t,i,!0)}}class Spherical{constructor(e=1,t=0,i=0){return this.radius=e,this.phi=t,this.theta=i,this}set(e,t,i){return this.radius=e,this.phi=t,this.theta=i,this}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){const e=1e-6;return this.phi=Math.max(e,Math.min(Math.PI-e,this.phi)),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,i){return this.radius=Math.sqrt(e*e+t*t+i*i),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,i),this.phi=Math.acos(clamp(t/this.radius,-1,1))),this}clone(){return(new this.constructor).copy(this)}}class Cylindrical{constructor(e=1,t=0,i=0){return this.radius=e,this.theta=t,this.y=i,this}set(e,t,i){return this.radius=e,this.theta=t,this.y=i,this}copy(e){return this.radius=e.radius,this.theta=e.theta,this.y=e.y,this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,i){return this.radius=Math.sqrt(e*e+i*i),this.theta=Math.atan2(e,i),this.y=t,this}clone(){return(new this.constructor).copy(this)}}const _a=new Vector2;class Box2{constructor(e=new Vector2(1/0,1/0),t=new Vector2(-1/0,-1/0)){this.isBox2=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromPoints(e){this.makeEmpty();for(let t=0,i=e.length;t<i;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const i=_a.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(i),this.max.copy(e).add(i),this}clone(){return(new this.constructor).copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y)}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return _a.copy(e).clamp(this.min,this.max).sub(e).length()}intersect(e){return this.min.max(e.min),this.max.min(e.max),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const ba=new Vector3,Ma=new Vector3;class Line3{constructor(e=new Vector3,t=new Vector3){this.start=e,this.end=t}set(e,t){return this.start.copy(e),this.end.copy(t),this}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,t){return this.delta(t).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,t){ba.subVectors(e,this.start),Ma.subVectors(this.end,this.start);const i=Ma.dot(Ma);let r=Ma.dot(ba)/i;return t&&(r=clamp(r,0,1)),r}closestPointToPoint(e,t,i){const r=this.closestPointToPointParameter(e,t);return this.delta(i).multiplyScalar(r).add(this.start)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}clone(){return(new this.constructor).copy(this)}}const Sa=new Vector3;class SpotLightHelper extends Object3D{constructor(e,t){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=t;const i=new BufferGeometry,r=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let s=0,a=1,o=32;s<o;s++,a++){const e=s/o*Math.PI*2,t=a/o*Math.PI*2;r.push(Math.cos(e),Math.sin(e),1,Math.cos(t),Math.sin(t),1)}i.setAttribute("position",new Float32BufferAttribute(r,3));const n=new LineBasicMaterial({fog:!1,toneMapped:!1});this.cone=new LineSegments(i,n),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateMatrixWorld();const e=this.light.distance?this.light.distance:1e3,t=e*Math.tan(this.light.angle);this.cone.scale.set(t,t,e),Sa.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(Sa),void 0!==this.color?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const wa=new Vector3,Ta=new Matrix4,Aa=new Matrix4;class SkeletonHelper extends LineSegments{constructor(e){const t=getBoneList(e),i=new BufferGeometry,r=[],n=[],s=new Color(0,0,1),a=new Color(0,1,0);for(let o=0;o<t.length;o++){const e=t[o];e.parent&&e.parent.isBone&&(r.push(0,0,0),r.push(0,0,0),n.push(s.r,s.g,s.b),n.push(a.r,a.g,a.b))}i.setAttribute("position",new Float32BufferAttribute(r,3)),i.setAttribute("color",new Float32BufferAttribute(n,3));super(i,new LineBasicMaterial({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0})),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const t=this.bones,i=this.geometry,r=i.getAttribute("position");Aa.copy(this.root.matrixWorld).invert();for(let n=0,s=0;n<t.length;n++){const e=t[n];e.parent&&e.parent.isBone&&(Ta.multiplyMatrices(Aa,e.matrixWorld),wa.setFromMatrixPosition(Ta),r.setXYZ(s,wa.x,wa.y,wa.z),Ta.multiplyMatrices(Aa,e.parent.matrixWorld),wa.setFromMatrixPosition(Ta),r.setXYZ(s+1,wa.x,wa.y,wa.z),s+=2)}i.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}}function getBoneList(e){const t=[];!0===e.isBone&&t.push(e);for(let i=0;i<e.children.length;i++)t.push.apply(t,getBoneList(e.children[i]));return t}class PointLightHelper extends Mesh{constructor(e,t,i){super(new SphereGeometry(t,4,2),new MeshBasicMaterial({wireframe:!0,fog:!1,toneMapped:!1})),this.light=e,this.light.updateMatrixWorld(),this.color=i,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){void 0!==this.color?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const Ca=new Vector3,Ea=new Color,La=new Color;class HemisphereLightHelper extends Object3D{constructor(e,t,i){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=i;const r=new OctahedronGeometry(t);r.rotateY(.5*Math.PI),this.material=new MeshBasicMaterial({wireframe:!0,fog:!1,toneMapped:!1}),void 0===this.color&&(this.material.vertexColors=!0);const n=r.getAttribute("position"),s=new Float32Array(3*n.count);r.setAttribute("color",new BufferAttribute(s,3)),this.add(new Mesh(r,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const e=this.children[0];if(void 0!==this.color)this.material.color.set(this.color);else{const t=e.geometry.getAttribute("color");Ea.copy(this.light.color),La.copy(this.light.groundColor);for(let e=0,i=t.count;e<i;e++){const r=e<i/2?Ea:La;t.setXYZ(e,r.r,r.g,r.b)}t.needsUpdate=!0}e.lookAt(Ca.setFromMatrixPosition(this.light.matrixWorld).negate())}}class GridHelper extends LineSegments{constructor(e=10,t=10,i=4473924,r=8947848){i=new Color(i),r=new Color(r);const n=t/2,s=e/t,a=e/2,o=[],l=[];for(let h=0,u=0,d=-a;h<=t;h++,d+=s){o.push(-a,0,d,a,0,d),o.push(d,0,-a,d,0,a);const e=h===n?i:r;e.toArray(l,u),u+=3,e.toArray(l,u),u+=3,e.toArray(l,u),u+=3,e.toArray(l,u),u+=3}const c=new BufferGeometry;c.setAttribute("position",new Float32BufferAttribute(o,3)),c.setAttribute("color",new Float32BufferAttribute(l,3));super(c,new LineBasicMaterial({vertexColors:!0,toneMapped:!1})),this.type="GridHelper"}}class PolarGridHelper extends LineSegments{constructor(e=10,t=16,i=8,r=64,n=4473924,s=8947848){n=new Color(n),s=new Color(s);const a=[],o=[];for(let c=0;c<=t;c++){const i=c/t*(2*Math.PI),r=Math.sin(i)*e,l=Math.cos(i)*e;a.push(0,0,0),a.push(r,0,l);const h=1&c?n:s;o.push(h.r,h.g,h.b),o.push(h.r,h.g,h.b)}for(let c=0;c<=i;c++){const t=1&c?n:s,l=e-e/i*c;for(let e=0;e<r;e++){let i=e/r*(2*Math.PI),n=Math.sin(i)*l,s=Math.cos(i)*l;a.push(n,0,s),o.push(t.r,t.g,t.b),i=(e+1)/r*(2*Math.PI),n=Math.sin(i)*l,s=Math.cos(i)*l,a.push(n,0,s),o.push(t.r,t.g,t.b)}}const l=new BufferGeometry;l.setAttribute("position",new Float32BufferAttribute(a,3)),l.setAttribute("color",new Float32BufferAttribute(o,3));super(l,new LineBasicMaterial({vertexColors:!0,toneMapped:!1})),this.type="PolarGridHelper"}}const Pa=new Vector3,Ra=new Vector3,Da=new Vector3;class DirectionalLightHelper extends Object3D{constructor(e,t,i){super(),this.light=e,this.light.updateMatrixWorld(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=i,void 0===t&&(t=1);let r=new BufferGeometry;r.setAttribute("position",new Float32BufferAttribute([-t,t,0,t,t,0,t,-t,0,-t,-t,0,-t,t,0],3));const n=new LineBasicMaterial({fog:!1,toneMapped:!1});this.lightPlane=new Line(r,n),this.add(this.lightPlane),r=new BufferGeometry,r.setAttribute("position",new Float32BufferAttribute([0,0,0,0,0,1],3)),this.targetLine=new Line(r,n),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){Pa.setFromMatrixPosition(this.light.matrixWorld),Ra.setFromMatrixPosition(this.light.target.matrixWorld),Da.subVectors(Ra,Pa),this.lightPlane.lookAt(Ra),void 0!==this.color?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(Ra),this.targetLine.scale.z=Da.length()}}const Ia=new Vector3,Ba=new Camera;class CameraHelper extends LineSegments{constructor(e){const t=new BufferGeometry,i=new LineBasicMaterial({color:16777215,vertexColors:!0,toneMapped:!1}),r=[],n=[],s={};function addLine(e,t){addPoint(e),addPoint(t)}function addPoint(e){r.push(0,0,0),n.push(0,0,0),void 0===s[e]&&(s[e]=[]),s[e].push(r.length/3-1)}addLine("n1","n2"),addLine("n2","n4"),addLine("n4","n3"),addLine("n3","n1"),addLine("f1","f2"),addLine("f2","f4"),addLine("f4","f3"),addLine("f3","f1"),addLine("n1","f1"),addLine("n2","f2"),addLine("n3","f3"),addLine("n4","f4"),addLine("p","n1"),addLine("p","n2"),addLine("p","n3"),addLine("p","n4"),addLine("u1","u2"),addLine("u2","u3"),addLine("u3","u1"),addLine("c","t"),addLine("p","c"),addLine("cn1","cn2"),addLine("cn3","cn4"),addLine("cf1","cf2"),addLine("cf3","cf4"),t.setAttribute("position",new Float32BufferAttribute(r,3)),t.setAttribute("color",new Float32BufferAttribute(n,3)),super(t,i),this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=s,this.update();const a=new Color(16755200),o=new Color(16711680),l=new Color(43775),c=new Color(16777215),h=new Color(3355443);this.setColors(a,o,l,c,h)}setColors(e,t,i,r,n){const s=this.geometry.getAttribute("color");s.setXYZ(0,e.r,e.g,e.b),s.setXYZ(1,e.r,e.g,e.b),s.setXYZ(2,e.r,e.g,e.b),s.setXYZ(3,e.r,e.g,e.b),s.setXYZ(4,e.r,e.g,e.b),s.setXYZ(5,e.r,e.g,e.b),s.setXYZ(6,e.r,e.g,e.b),s.setXYZ(7,e.r,e.g,e.b),s.setXYZ(8,e.r,e.g,e.b),s.setXYZ(9,e.r,e.g,e.b),s.setXYZ(10,e.r,e.g,e.b),s.setXYZ(11,e.r,e.g,e.b),s.setXYZ(12,e.r,e.g,e.b),s.setXYZ(13,e.r,e.g,e.b),s.setXYZ(14,e.r,e.g,e.b),s.setXYZ(15,e.r,e.g,e.b),s.setXYZ(16,e.r,e.g,e.b),s.setXYZ(17,e.r,e.g,e.b),s.setXYZ(18,e.r,e.g,e.b),s.setXYZ(19,e.r,e.g,e.b),s.setXYZ(20,e.r,e.g,e.b),s.setXYZ(21,e.r,e.g,e.b),s.setXYZ(22,e.r,e.g,e.b),s.setXYZ(23,e.r,e.g,e.b),s.setXYZ(24,t.r,t.g,t.b),s.setXYZ(25,t.r,t.g,t.b),s.setXYZ(26,t.r,t.g,t.b),s.setXYZ(27,t.r,t.g,t.b),s.setXYZ(28,t.r,t.g,t.b),s.setXYZ(29,t.r,t.g,t.b),s.setXYZ(30,t.r,t.g,t.b),s.setXYZ(31,t.r,t.g,t.b),s.setXYZ(32,i.r,i.g,i.b),s.setXYZ(33,i.r,i.g,i.b),s.setXYZ(34,i.r,i.g,i.b),s.setXYZ(35,i.r,i.g,i.b),s.setXYZ(36,i.r,i.g,i.b),s.setXYZ(37,i.r,i.g,i.b),s.setXYZ(38,r.r,r.g,r.b),s.setXYZ(39,r.r,r.g,r.b),s.setXYZ(40,n.r,n.g,n.b),s.setXYZ(41,n.r,n.g,n.b),s.setXYZ(42,n.r,n.g,n.b),s.setXYZ(43,n.r,n.g,n.b),s.setXYZ(44,n.r,n.g,n.b),s.setXYZ(45,n.r,n.g,n.b),s.setXYZ(46,n.r,n.g,n.b),s.setXYZ(47,n.r,n.g,n.b),s.setXYZ(48,n.r,n.g,n.b),s.setXYZ(49,n.r,n.g,n.b),s.needsUpdate=!0}update(){const e=this.geometry,t=this.pointMap;Ba.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),setPoint("c",t,e,Ba,0,0,-1),setPoint("t",t,e,Ba,0,0,1),setPoint("n1",t,e,Ba,-1,-1,-1),setPoint("n2",t,e,Ba,1,-1,-1),setPoint("n3",t,e,Ba,-1,1,-1),setPoint("n4",t,e,Ba,1,1,-1),setPoint("f1",t,e,Ba,-1,-1,1),setPoint("f2",t,e,Ba,1,-1,1),setPoint("f3",t,e,Ba,-1,1,1),setPoint("f4",t,e,Ba,1,1,1),setPoint("u1",t,e,Ba,.7,1.1,-1),setPoint("u2",t,e,Ba,-.7,1.1,-1),setPoint("u3",t,e,Ba,0,2,-1),setPoint("cf1",t,e,Ba,-1,0,1),setPoint("cf2",t,e,Ba,1,0,1),setPoint("cf3",t,e,Ba,0,-1,1),setPoint("cf4",t,e,Ba,0,1,1),setPoint("cn1",t,e,Ba,-1,0,-1),setPoint("cn2",t,e,Ba,1,0,-1),setPoint("cn3",t,e,Ba,0,-1,-1),setPoint("cn4",t,e,Ba,0,1,-1),e.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function setPoint(e,t,i,r,n,s,a){Ia.set(n,s,a).unproject(r);const o=t[e];if(void 0!==o){const e=i.getAttribute("position");for(let t=0,i=o.length;t<i;t++)e.setXYZ(o[t],Ia.x,Ia.y,Ia.z)}}const Va=new Box3;class BoxHelper extends LineSegments{constructor(e,t=16776960){const i=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),r=new Float32Array(24),n=new BufferGeometry;n.setIndex(new BufferAttribute(i,1)),n.setAttribute("position",new BufferAttribute(r,3)),super(n,new LineBasicMaterial({color:t,toneMapped:!1})),this.object=e,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(e){if(void 0!==e&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),void 0!==this.object&&Va.setFromObject(this.object),Va.isEmpty())return;const t=Va.min,i=Va.max,r=this.geometry.attributes.position,n=r.array;n[0]=i.x,n[1]=i.y,n[2]=i.z,n[3]=t.x,n[4]=i.y,n[5]=i.z,n[6]=t.x,n[7]=t.y,n[8]=i.z,n[9]=i.x,n[10]=t.y,n[11]=i.z,n[12]=i.x,n[13]=i.y,n[14]=t.z,n[15]=t.x,n[16]=i.y,n[17]=t.z,n[18]=t.x,n[19]=t.y,n[20]=t.z,n[21]=i.x,n[22]=t.y,n[23]=t.z,r.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(e){return this.object=e,this.update(),this}copy(e,t){return super.copy(e,t),this.object=e.object,this}}class Box3Helper extends LineSegments{constructor(e,t=16776960){const i=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),r=new BufferGeometry;r.setIndex(new BufferAttribute(i,1)),r.setAttribute("position",new Float32BufferAttribute([1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],3)),super(r,new LineBasicMaterial({color:t,toneMapped:!1})),this.box=e,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(e){const t=this.box;t.isEmpty()||(t.getCenter(this.position),t.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(e))}}class PlaneHelper extends Line{constructor(e,t=1,i=16776960){const r=i,n=new BufferGeometry;n.setAttribute("position",new Float32BufferAttribute([1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],3)),n.computeBoundingSphere(),super(n,new LineBasicMaterial({color:r,toneMapped:!1})),this.type="PlaneHelper",this.plane=e,this.size=t;const s=new BufferGeometry;s.setAttribute("position",new Float32BufferAttribute([1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],3)),s.computeBoundingSphere(),this.add(new Mesh(s,new MeshBasicMaterial({color:r,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(e){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),super.updateMatrixWorld(e)}}const Na=new Vector3;let Oa,za;class ArrowHelper extends Object3D{constructor(e=new Vector3(0,0,1),t=new Vector3(0,0,0),i=1,r=16776960,n=.2*i,s=.2*n){super(),this.type="ArrowHelper",void 0===Oa&&(Oa=new BufferGeometry,Oa.setAttribute("position",new Float32BufferAttribute([0,0,0,0,1,0],3)),za=new CylinderGeometry(0,.5,1,5,1),za.translate(0,-.5,0)),this.position.copy(t),this.line=new Line(Oa,new LineBasicMaterial({color:r,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new Mesh(za,new MeshBasicMaterial({color:r,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e),this.setLength(i,n,s)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{Na.set(e.z,0,-e.x).normalize();const t=Math.acos(e.y);this.quaternion.setFromAxisAngle(Na,t)}}setLength(e,t=.2*e,i=.2*t){this.line.scale.set(1,Math.max(1e-4,e-t),1),this.line.updateMatrix(),this.cone.scale.set(i,t,i),this.cone.position.y=e,this.cone.updateMatrix()}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}}class AxesHelper extends LineSegments{constructor(e=1){const t=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],i=new BufferGeometry;i.setAttribute("position",new Float32BufferAttribute(t,3)),i.setAttribute("color",new Float32BufferAttribute([1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],3));super(i,new LineBasicMaterial({vertexColors:!0,toneMapped:!1})),this.type="AxesHelper"}setColors(e,t,i){const r=new Color,n=this.geometry.attributes.color.array;return r.set(e),r.toArray(n,0),r.toArray(n,3),r.set(t),r.toArray(n,6),r.toArray(n,9),r.set(i),r.toArray(n,12),r.toArray(n,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class ShapePath{constructor(){this.type="ShapePath",this.color=new Color,this.subPaths=[],this.currentPath=null}moveTo(e,t){return this.currentPath=new Path,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,t),this}lineTo(e,t){return this.currentPath.lineTo(e,t),this}quadraticCurveTo(e,t,i,r){return this.currentPath.quadraticCurveTo(e,t,i,r),this}bezierCurveTo(e,t,i,r,n,s){return this.currentPath.bezierCurveTo(e,t,i,r,n,s),this}splineThru(e){return this.currentPath.splineThru(e),this}toShapes(e,t){function toShapesNoHoles(e){const t=[];for(let i=0,r=e.length;i<r;i++){const r=e[i],n=new Shape;n.curves=r.curves,t.push(n)}return t}function isPointInsidePolygon(e,t){const i=t.length;let r=!1;for(let n=i-1,s=0;s<i;n=s++){let i=t[n],a=t[s],o=a.x-i.x,l=a.y-i.y;if(Math.abs(l)>Number.EPSILON){if(l<0&&(i=t[s],o=-o,a=t[n],l=-l),e.y<i.y||e.y>a.y)continue;if(e.y===i.y){if(e.x===i.x)return!0}else{const t=l*(e.x-i.x)-o*(e.y-i.y);if(0===t)return!0;if(t<0)continue;r=!r}}else{if(e.y!==i.y)continue;if(a.x<=e.x&&e.x<=i.x||i.x<=e.x&&e.x<=a.x)return!0}}return r}const i=ShapeUtils.isClockWise,r=this.subPaths;if(0===r.length)return[];if(!0===t)return toShapesNoHoles(r);let n,s,a;const o=[];if(1===r.length)return s=r[0],a=new Shape,a.curves=s.curves,o.push(a),o;let l=!i(r[0].getPoints());l=e?!l:l;const c=[],h=[];let u,d,p=[],m=0;h[m]=void 0,p[m]=[];for(let f=0,g=r.length;f<g;f++)s=r[f],u=s.getPoints(),n=i(u),n=e?!n:n,n?(!l&&h[m]&&m++,h[m]={s:new Shape,p:u},h[m].s.curves=s.curves,l&&m++,p[m]=[]):p[m].push({h:s,p:u[0]});if(!h[0])return toShapesNoHoles(r);if(h.length>1){let e=!1,t=0;for(let i=0,r=h.length;i<r;i++)c[i]=[];for(let i=0,r=h.length;i<r;i++){const r=p[i];for(let n=0;n<r.length;n++){const s=r[n];let a=!0;for(let r=0;r<h.length;r++)isPointInsidePolygon(s.p,h[r].p)&&(i!==r&&t++,a?(a=!1,c[r].push(s)):e=!0);a&&c[i].push(s)}}t>0&&!1===e&&(p=c)}for(let f=0,g=h.length;f<g;f++){a=h[f].s,o.push(a),d=p[f];for(let e=0,t=d.length;e<t;e++)a.holes.push(d[e].h)}return o}}const Fa=_generateTables();function _generateTables(){const e=new ArrayBuffer(4),t=new Float32Array(e),i=new Uint32Array(e),r=new Uint32Array(512),n=new Uint32Array(512);for(let l=0;l<256;++l){const e=l-127;e<-27?(r[l]=0,r[256|l]=32768,n[l]=24,n[256|l]=24):e<-14?(r[l]=1024>>-e-14,r[256|l]=1024>>-e-14|32768,n[l]=-e-1,n[256|l]=-e-1):e<=15?(r[l]=e+15<<10,r[256|l]=e+15<<10|32768,n[l]=13,n[256|l]=13):e<128?(r[l]=31744,r[256|l]=64512,n[l]=24,n[256|l]=24):(r[l]=31744,r[256|l]=64512,n[l]=13,n[256|l]=13)}const s=new Uint32Array(2048),a=new Uint32Array(64),o=new Uint32Array(64);for(let l=1;l<1024;++l){let e=l<<13,t=0;for(;0===(8388608&e);)e<<=1,t-=8388608;e&=-8388609,t+=947912704,s[l]=e|t}for(let l=1024;l<2048;++l)s[l]=939524096+(l-1024<<13);for(let l=1;l<31;++l)a[l]=l<<23;a[31]=1199570944,a[32]=2147483648;for(let l=33;l<63;++l)a[l]=2147483648+(l-32<<23);a[63]=3347054592;for(let l=1;l<64;++l)32!==l&&(o[l]=1024);return{floatView:t,uint32View:i,baseTable:r,shiftTable:n,mantissaTable:s,exponentTable:a,offsetTable:o}}var Ga=Object.freeze({__proto__:null,toHalfFloat:function toHalfFloat(e){Math.abs(e)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),e=clamp(e,-65504,65504),Fa.floatView[0]=e;const t=Fa.uint32View[0],i=t>>23&511;return Fa.baseTable[i]+((8388607&t)>>Fa.shiftTable[i])},fromHalfFloat:function fromHalfFloat(e){const t=e>>10;return Fa.uint32View[0]=Fa.mantissaTable[Fa.offsetTable[t]+(1023&e)]+Fa.exponentTable[t],Fa.floatView[0]}});class ParametricGeometry extends BufferGeometry{constructor(){console.error("THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js"),super()}}class TextGeometry extends BufferGeometry{constructor(){console.error("THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js"),super()}}function FontLoader(){console.error("THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js")}function Font(){console.error("THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js")}function ImmediateRenderObject(){console.error("THREE.ImmediateRenderObject has been removed.")}class WebGLMultisampleRenderTarget extends WebGLRenderTarget{constructor(e,t,i){console.error('THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.'),super(e,t,i),this.samples=4}}class DataTexture2DArray extends DataArrayTexture{constructor(e,t,i,r){console.warn("THREE.DataTexture2DArray has been renamed to DataArrayTexture."),super(e,t,i,r)}}class DataTexture3D extends Data3DTexture{constructor(e,t,i,r){console.warn("THREE.DataTexture3D has been renamed to Data3DTexture."),super(e,t,i,r)}}"undefined"!==typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:i}})),"undefined"!==typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=i),window.three=t})();
/*! For license information please see buffer.js.LICENSE.txt */
(()=>{var t={9742:(t,e)=>{"use strict";e.byteLength=function byteLength(t){var e=getLens(t),r=e[0],n=e[1];return 3*(r+n)/4-n},e.toByteArray=function toByteArray(t){var e,r,i=getLens(t),o=i[0],u=i[1],s=new f(function _byteLength(t,e,r){return 3*(e+r)/4-r}(0,o,u)),h=0,a=u>0?o-4:o;for(r=0;r<a;r+=4)e=n[t.charCodeAt(r)]<<18|n[t.charCodeAt(r+1)]<<12|n[t.charCodeAt(r+2)]<<6|n[t.charCodeAt(r+3)],s[h++]=e>>16&255,s[h++]=e>>8&255,s[h++]=255&e;2===u&&(e=n[t.charCodeAt(r)]<<2|n[t.charCodeAt(r+1)]>>4,s[h++]=255&e);1===u&&(e=n[t.charCodeAt(r)]<<10|n[t.charCodeAt(r+1)]<<4|n[t.charCodeAt(r+2)]>>2,s[h++]=e>>8&255,s[h++]=255&e);return s},e.fromByteArray=function fromByteArray(t){for(var e,n=t.length,f=n%3,i=[],o=16383,u=0,s=n-f;u<s;u+=o)i.push(encodeChunk(t,u,u+o>s?s:u+o));1===f?(e=t[n-1],i.push(r[e>>2]+r[e<<4&63]+"==")):2===f&&(e=(t[n-2]<<8)+t[n-1],i.push(r[e>>10]+r[e>>4&63]+r[e<<2&63]+"="));return i.join("")};for(var r=[],n=[],f="undefined"!==typeof Uint8Array?Uint8Array:Array,i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",o=0,u=i.length;o<u;++o)r[o]=i[o],n[i.charCodeAt(o)]=o;function getLens(t){var e=t.length;if(e%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var r=t.indexOf("=");return-1===r&&(r=e),[r,r===e?0:4-r%4]}function encodeChunk(t,e,n){for(var f,i,o=[],u=e;u<n;u+=3)f=(t[u]<<16&16711680)+(t[u+1]<<8&65280)+(255&t[u+2]),o.push(r[(i=f)>>18&63]+r[i>>12&63]+r[i>>6&63]+r[63&i]);return o.join("")}n["-".charCodeAt(0)]=62,n["_".charCodeAt(0)]=63},8764:(t,e,r)=>{"use strict";const n=r(9742),f=r(645),i="function"===typeof Symbol&&"function"===typeof Symbol.for?Symbol.for("nodejs.util.inspect.custom"):null;e.Buffer=Buffer,e.SlowBuffer=function SlowBuffer(t){+t!=t&&(t=0);return Buffer.alloc(+t)},e.INSPECT_MAX_BYTES=50;const o=2147483647;function createBuffer(t){if(t>o)throw new RangeError('The value "'+t+'" is invalid for option "size"');const e=new Uint8Array(t);return Object.setPrototypeOf(e,Buffer.prototype),e}function Buffer(t,e,r){if("number"===typeof t){if("string"===typeof e)throw new TypeError('The "string" argument must be of type string. Received type number');return allocUnsafe(t)}return from(t,e,r)}function from(t,e,r){if("string"===typeof t)return function fromString(t,e){"string"===typeof e&&""!==e||(e="utf8");if(!Buffer.isEncoding(e))throw new TypeError("Unknown encoding: "+e);const r=0|byteLength(t,e);let n=createBuffer(r);const f=n.write(t,e);f!==r&&(n=n.slice(0,f));return n}(t,e);if(ArrayBuffer.isView(t))return function fromArrayView(t){if(isInstance(t,Uint8Array)){const e=new Uint8Array(t);return fromArrayBuffer(e.buffer,e.byteOffset,e.byteLength)}return fromArrayLike(t)}(t);if(null==t)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof t);if(isInstance(t,ArrayBuffer)||t&&isInstance(t.buffer,ArrayBuffer))return fromArrayBuffer(t,e,r);if("undefined"!==typeof SharedArrayBuffer&&(isInstance(t,SharedArrayBuffer)||t&&isInstance(t.buffer,SharedArrayBuffer)))return fromArrayBuffer(t,e,r);if("number"===typeof t)throw new TypeError('The "value" argument must not be of type number. Received type number');const n=t.valueOf&&t.valueOf();if(null!=n&&n!==t)return Buffer.from(n,e,r);const f=function fromObject(t){if(Buffer.isBuffer(t)){const e=0|checked(t.length),r=createBuffer(e);return 0===r.length||t.copy(r,0,0,e),r}if(void 0!==t.length)return"number"!==typeof t.length||numberIsNaN(t.length)?createBuffer(0):fromArrayLike(t);if("Buffer"===t.type&&Array.isArray(t.data))return fromArrayLike(t.data)}(t);if(f)return f;if("undefined"!==typeof Symbol&&null!=Symbol.toPrimitive&&"function"===typeof t[Symbol.toPrimitive])return Buffer.from(t[Symbol.toPrimitive]("string"),e,r);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof t)}function assertSize(t){if("number"!==typeof t)throw new TypeError('"size" argument must be of type number');if(t<0)throw new RangeError('The value "'+t+'" is invalid for option "size"')}function allocUnsafe(t){return assertSize(t),createBuffer(t<0?0:0|checked(t))}function fromArrayLike(t){const e=t.length<0?0:0|checked(t.length),r=createBuffer(e);for(let n=0;n<e;n+=1)r[n]=255&t[n];return r}function fromArrayBuffer(t,e,r){if(e<0||t.byteLength<e)throw new RangeError('"offset" is outside of buffer bounds');if(t.byteLength<e+(r||0))throw new RangeError('"length" is outside of buffer bounds');let n;return n=void 0===e&&void 0===r?new Uint8Array(t):void 0===r?new Uint8Array(t,e):new Uint8Array(t,e,r),Object.setPrototypeOf(n,Buffer.prototype),n}function checked(t){if(t>=o)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+o.toString(16)+" bytes");return 0|t}function byteLength(t,e){if(Buffer.isBuffer(t))return t.length;if(ArrayBuffer.isView(t)||isInstance(t,ArrayBuffer))return t.byteLength;if("string"!==typeof t)throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof t);const r=t.length,n=arguments.length>2&&!0===arguments[2];if(!n&&0===r)return 0;let f=!1;for(;;)switch(e){case"ascii":case"latin1":case"binary":return r;case"utf8":case"utf-8":return utf8ToBytes(t).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*r;case"hex":return r>>>1;case"base64":return base64ToBytes(t).length;default:if(f)return n?-1:utf8ToBytes(t).length;e=(""+e).toLowerCase(),f=!0}}function slowToString(t,e,r){let n=!1;if((void 0===e||e<0)&&(e=0),e>this.length)return"";if((void 0===r||r>this.length)&&(r=this.length),r<=0)return"";if((r>>>=0)<=(e>>>=0))return"";for(t||(t="utf8");;)switch(t){case"hex":return hexSlice(this,e,r);case"utf8":case"utf-8":return utf8Slice(this,e,r);case"ascii":return asciiSlice(this,e,r);case"latin1":case"binary":return latin1Slice(this,e,r);case"base64":return base64Slice(this,e,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return utf16leSlice(this,e,r);default:if(n)throw new TypeError("Unknown encoding: "+t);t=(t+"").toLowerCase(),n=!0}}function swap(t,e,r){const n=t[e];t[e]=t[r],t[r]=n}function bidirectionalIndexOf(t,e,r,n,f){if(0===t.length)return-1;if("string"===typeof r?(n=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),numberIsNaN(r=+r)&&(r=f?0:t.length-1),r<0&&(r=t.length+r),r>=t.length){if(f)return-1;r=t.length-1}else if(r<0){if(!f)return-1;r=0}if("string"===typeof e&&(e=Buffer.from(e,n)),Buffer.isBuffer(e))return 0===e.length?-1:arrayIndexOf(t,e,r,n,f);if("number"===typeof e)return e&=255,"function"===typeof Uint8Array.prototype.indexOf?f?Uint8Array.prototype.indexOf.call(t,e,r):Uint8Array.prototype.lastIndexOf.call(t,e,r):arrayIndexOf(t,[e],r,n,f);throw new TypeError("val must be string, number or Buffer")}function arrayIndexOf(t,e,r,n,f){let i,o=1,u=t.length,s=e.length;if(void 0!==n&&("ucs2"===(n=String(n).toLowerCase())||"ucs-2"===n||"utf16le"===n||"utf-16le"===n)){if(t.length<2||e.length<2)return-1;o=2,u/=2,s/=2,r/=2}function read(t,e){return 1===o?t[e]:t.readUInt16BE(e*o)}if(f){let n=-1;for(i=r;i<u;i++)if(read(t,i)===read(e,-1===n?0:i-n)){if(-1===n&&(n=i),i-n+1===s)return n*o}else-1!==n&&(i-=i-n),n=-1}else for(r+s>u&&(r=u-s),i=r;i>=0;i--){let r=!0;for(let n=0;n<s;n++)if(read(t,i+n)!==read(e,n)){r=!1;break}if(r)return i}return-1}function hexWrite(t,e,r,n){r=Number(r)||0;const f=t.length-r;n?(n=Number(n))>f&&(n=f):n=f;const i=e.length;let o;for(n>i/2&&(n=i/2),o=0;o<n;++o){const n=parseInt(e.substr(2*o,2),16);if(numberIsNaN(n))return o;t[r+o]=n}return o}function utf8Write(t,e,r,n){return blitBuffer(utf8ToBytes(e,t.length-r),t,r,n)}function asciiWrite(t,e,r,n){return blitBuffer(function asciiToBytes(t){const e=[];for(let r=0;r<t.length;++r)e.push(255&t.charCodeAt(r));return e}(e),t,r,n)}function base64Write(t,e,r,n){return blitBuffer(base64ToBytes(e),t,r,n)}function ucs2Write(t,e,r,n){return blitBuffer(function utf16leToBytes(t,e){let r,n,f;const i=[];for(let o=0;o<t.length&&!((e-=2)<0);++o)r=t.charCodeAt(o),n=r>>8,f=r%256,i.push(f),i.push(n);return i}(e,t.length-r),t,r,n)}function base64Slice(t,e,r){return 0===e&&r===t.length?n.fromByteArray(t):n.fromByteArray(t.slice(e,r))}function utf8Slice(t,e,r){r=Math.min(t.length,r);const n=[];let f=e;for(;f<r;){const e=t[f];let i=null,o=e>239?4:e>223?3:e>191?2:1;if(f+o<=r){let r,n,u,s;switch(o){case 1:e<128&&(i=e);break;case 2:r=t[f+1],128===(192&r)&&(s=(31&e)<<6|63&r,s>127&&(i=s));break;case 3:r=t[f+1],n=t[f+2],128===(192&r)&&128===(192&n)&&(s=(15&e)<<12|(63&r)<<6|63&n,s>2047&&(s<55296||s>57343)&&(i=s));break;case 4:r=t[f+1],n=t[f+2],u=t[f+3],128===(192&r)&&128===(192&n)&&128===(192&u)&&(s=(15&e)<<18|(63&r)<<12|(63&n)<<6|63&u,s>65535&&s<1114112&&(i=s))}}null===i?(i=65533,o=1):i>65535&&(i-=65536,n.push(i>>>10&1023|55296),i=56320|1023&i),n.push(i),f+=o}return function decodeCodePointsArray(t){const e=t.length;if(e<=u)return String.fromCharCode.apply(String,t);let r="",n=0;for(;n<e;)r+=String.fromCharCode.apply(String,t.slice(n,n+=u));return r}(n)}e.kMaxLength=o,Buffer.TYPED_ARRAY_SUPPORT=function typedArraySupport(){try{const t=new Uint8Array(1),e={foo:function(){return 42}};return Object.setPrototypeOf(e,Uint8Array.prototype),Object.setPrototypeOf(t,e),42===t.foo()}catch(t){return!1}}(),Buffer.TYPED_ARRAY_SUPPORT||"undefined"===typeof console||"function"!==typeof console.error||console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),Object.defineProperty(Buffer.prototype,"parent",{enumerable:!0,get:function(){if(Buffer.isBuffer(this))return this.buffer}}),Object.defineProperty(Buffer.prototype,"offset",{enumerable:!0,get:function(){if(Buffer.isBuffer(this))return this.byteOffset}}),Buffer.poolSize=8192,Buffer.from=function(t,e,r){return from(t,e,r)},Object.setPrototypeOf(Buffer.prototype,Uint8Array.prototype),Object.setPrototypeOf(Buffer,Uint8Array),Buffer.alloc=function(t,e,r){return function alloc(t,e,r){return assertSize(t),t<=0?createBuffer(t):void 0!==e?"string"===typeof r?createBuffer(t).fill(e,r):createBuffer(t).fill(e):createBuffer(t)}(t,e,r)},Buffer.allocUnsafe=function(t){return allocUnsafe(t)},Buffer.allocUnsafeSlow=function(t){return allocUnsafe(t)},Buffer.isBuffer=function isBuffer(t){return null!=t&&!0===t._isBuffer&&t!==Buffer.prototype},Buffer.compare=function compare(t,e){if(isInstance(t,Uint8Array)&&(t=Buffer.from(t,t.offset,t.byteLength)),isInstance(e,Uint8Array)&&(e=Buffer.from(e,e.offset,e.byteLength)),!Buffer.isBuffer(t)||!Buffer.isBuffer(e))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(t===e)return 0;let r=t.length,n=e.length;for(let f=0,i=Math.min(r,n);f<i;++f)if(t[f]!==e[f]){r=t[f],n=e[f];break}return r<n?-1:n<r?1:0},Buffer.isEncoding=function isEncoding(t){switch(String(t).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},Buffer.concat=function concat(t,e){if(!Array.isArray(t))throw new TypeError('"list" argument must be an Array of Buffers');if(0===t.length)return Buffer.alloc(0);let r;if(void 0===e)for(e=0,r=0;r<t.length;++r)e+=t[r].length;const n=Buffer.allocUnsafe(e);let f=0;for(r=0;r<t.length;++r){let e=t[r];if(isInstance(e,Uint8Array))f+e.length>n.length?(Buffer.isBuffer(e)||(e=Buffer.from(e)),e.copy(n,f)):Uint8Array.prototype.set.call(n,e,f);else{if(!Buffer.isBuffer(e))throw new TypeError('"list" argument must be an Array of Buffers');e.copy(n,f)}f+=e.length}return n},Buffer.byteLength=byteLength,Buffer.prototype._isBuffer=!0,Buffer.prototype.swap16=function swap16(){const t=this.length;if(t%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let e=0;e<t;e+=2)swap(this,e,e+1);return this},Buffer.prototype.swap32=function swap32(){const t=this.length;if(t%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let e=0;e<t;e+=4)swap(this,e,e+3),swap(this,e+1,e+2);return this},Buffer.prototype.swap64=function swap64(){const t=this.length;if(t%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let e=0;e<t;e+=8)swap(this,e,e+7),swap(this,e+1,e+6),swap(this,e+2,e+5),swap(this,e+3,e+4);return this},Buffer.prototype.toString=function toString(){const t=this.length;return 0===t?"":0===arguments.length?utf8Slice(this,0,t):slowToString.apply(this,arguments)},Buffer.prototype.toLocaleString=Buffer.prototype.toString,Buffer.prototype.equals=function equals(t){if(!Buffer.isBuffer(t))throw new TypeError("Argument must be a Buffer");return this===t||0===Buffer.compare(this,t)},Buffer.prototype.inspect=function inspect(){let t="";const r=e.INSPECT_MAX_BYTES;return t=this.toString("hex",0,r).replace(/(.{2})/g,"$1 ").trim(),this.length>r&&(t+=" ... "),"<Buffer "+t+">"},i&&(Buffer.prototype[i]=Buffer.prototype.inspect),Buffer.prototype.compare=function compare(t,e,r,n,f){if(isInstance(t,Uint8Array)&&(t=Buffer.from(t,t.offset,t.byteLength)),!Buffer.isBuffer(t))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof t);if(void 0===e&&(e=0),void 0===r&&(r=t?t.length:0),void 0===n&&(n=0),void 0===f&&(f=this.length),e<0||r>t.length||n<0||f>this.length)throw new RangeError("out of range index");if(n>=f&&e>=r)return 0;if(n>=f)return-1;if(e>=r)return 1;if(this===t)return 0;let i=(f>>>=0)-(n>>>=0),o=(r>>>=0)-(e>>>=0);const u=Math.min(i,o),s=this.slice(n,f),h=t.slice(e,r);for(let a=0;a<u;++a)if(s[a]!==h[a]){i=s[a],o=h[a];break}return i<o?-1:o<i?1:0},Buffer.prototype.includes=function includes(t,e,r){return-1!==this.indexOf(t,e,r)},Buffer.prototype.indexOf=function indexOf(t,e,r){return bidirectionalIndexOf(this,t,e,r,!0)},Buffer.prototype.lastIndexOf=function lastIndexOf(t,e,r){return bidirectionalIndexOf(this,t,e,r,!1)},Buffer.prototype.write=function write(t,e,r,n){if(void 0===e)n="utf8",r=this.length,e=0;else if(void 0===r&&"string"===typeof e)n=e,r=this.length,e=0;else{if(!isFinite(e))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");e>>>=0,isFinite(r)?(r>>>=0,void 0===n&&(n="utf8")):(n=r,r=void 0)}const f=this.length-e;if((void 0===r||r>f)&&(r=f),t.length>0&&(r<0||e<0)||e>this.length)throw new RangeError("Attempt to write outside buffer bounds");n||(n="utf8");let i=!1;for(;;)switch(n){case"hex":return hexWrite(this,t,e,r);case"utf8":case"utf-8":return utf8Write(this,t,e,r);case"ascii":case"latin1":case"binary":return asciiWrite(this,t,e,r);case"base64":return base64Write(this,t,e,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return ucs2Write(this,t,e,r);default:if(i)throw new TypeError("Unknown encoding: "+n);n=(""+n).toLowerCase(),i=!0}},Buffer.prototype.toJSON=function toJSON(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};const u=4096;function asciiSlice(t,e,r){let n="";r=Math.min(t.length,r);for(let f=e;f<r;++f)n+=String.fromCharCode(127&t[f]);return n}function latin1Slice(t,e,r){let n="";r=Math.min(t.length,r);for(let f=e;f<r;++f)n+=String.fromCharCode(t[f]);return n}function hexSlice(t,e,r){const n=t.length;(!e||e<0)&&(e=0),(!r||r<0||r>n)&&(r=n);let f="";for(let i=e;i<r;++i)f+=a[t[i]];return f}function utf16leSlice(t,e,r){const n=t.slice(e,r);let f="";for(let i=0;i<n.length-1;i+=2)f+=String.fromCharCode(n[i]+256*n[i+1]);return f}function checkOffset(t,e,r){if(t%1!==0||t<0)throw new RangeError("offset is not uint");if(t+e>r)throw new RangeError("Trying to access beyond buffer length")}function checkInt(t,e,r,n,f,i){if(!Buffer.isBuffer(t))throw new TypeError('"buffer" argument must be a Buffer instance');if(e>f||e<i)throw new RangeError('"value" argument is out of bounds');if(r+n>t.length)throw new RangeError("Index out of range")}function wrtBigUInt64LE(t,e,r,n,f){checkIntBI(e,n,f,t,r,7);let i=Number(e&BigInt(4294967295));t[r++]=i,i>>=8,t[r++]=i,i>>=8,t[r++]=i,i>>=8,t[r++]=i;let o=Number(e>>BigInt(32)&BigInt(4294967295));return t[r++]=o,o>>=8,t[r++]=o,o>>=8,t[r++]=o,o>>=8,t[r++]=o,r}function wrtBigUInt64BE(t,e,r,n,f){checkIntBI(e,n,f,t,r,7);let i=Number(e&BigInt(4294967295));t[r+7]=i,i>>=8,t[r+6]=i,i>>=8,t[r+5]=i,i>>=8,t[r+4]=i;let o=Number(e>>BigInt(32)&BigInt(4294967295));return t[r+3]=o,o>>=8,t[r+2]=o,o>>=8,t[r+1]=o,o>>=8,t[r]=o,r+8}function checkIEEE754(t,e,r,n,f,i){if(r+n>t.length)throw new RangeError("Index out of range");if(r<0)throw new RangeError("Index out of range")}function writeFloat(t,e,r,n,i){return e=+e,r>>>=0,i||checkIEEE754(t,0,r,4),f.write(t,e,r,n,23,4),r+4}function writeDouble(t,e,r,n,i){return e=+e,r>>>=0,i||checkIEEE754(t,0,r,8),f.write(t,e,r,n,52,8),r+8}Buffer.prototype.slice=function slice(t,e){const r=this.length;(t=~~t)<0?(t+=r)<0&&(t=0):t>r&&(t=r),(e=void 0===e?r:~~e)<0?(e+=r)<0&&(e=0):e>r&&(e=r),e<t&&(e=t);const n=this.subarray(t,e);return Object.setPrototypeOf(n,Buffer.prototype),n},Buffer.prototype.readUintLE=Buffer.prototype.readUIntLE=function readUIntLE(t,e,r){t>>>=0,e>>>=0,r||checkOffset(t,e,this.length);let n=this[t],f=1,i=0;for(;++i<e&&(f*=256);)n+=this[t+i]*f;return n},Buffer.prototype.readUintBE=Buffer.prototype.readUIntBE=function readUIntBE(t,e,r){t>>>=0,e>>>=0,r||checkOffset(t,e,this.length);let n=this[t+--e],f=1;for(;e>0&&(f*=256);)n+=this[t+--e]*f;return n},Buffer.prototype.readUint8=Buffer.prototype.readUInt8=function readUInt8(t,e){return t>>>=0,e||checkOffset(t,1,this.length),this[t]},Buffer.prototype.readUint16LE=Buffer.prototype.readUInt16LE=function readUInt16LE(t,e){return t>>>=0,e||checkOffset(t,2,this.length),this[t]|this[t+1]<<8},Buffer.prototype.readUint16BE=Buffer.prototype.readUInt16BE=function readUInt16BE(t,e){return t>>>=0,e||checkOffset(t,2,this.length),this[t]<<8|this[t+1]},Buffer.prototype.readUint32LE=Buffer.prototype.readUInt32LE=function readUInt32LE(t,e){return t>>>=0,e||checkOffset(t,4,this.length),(this[t]|this[t+1]<<8|this[t+2]<<16)+16777216*this[t+3]},Buffer.prototype.readUint32BE=Buffer.prototype.readUInt32BE=function readUInt32BE(t,e){return t>>>=0,e||checkOffset(t,4,this.length),16777216*this[t]+(this[t+1]<<16|this[t+2]<<8|this[t+3])},Buffer.prototype.readBigUInt64LE=defineBigIntMethod((function readBigUInt64LE(t){validateNumber(t>>>=0,"offset");const e=this[t],r=this[t+7];void 0!==e&&void 0!==r||boundsError(t,this.length-8);const n=e+256*this[++t]+65536*this[++t]+this[++t]*2**24,f=this[++t]+256*this[++t]+65536*this[++t]+r*2**24;return BigInt(n)+(BigInt(f)<<BigInt(32))})),Buffer.prototype.readBigUInt64BE=defineBigIntMethod((function readBigUInt64BE(t){validateNumber(t>>>=0,"offset");const e=this[t],r=this[t+7];void 0!==e&&void 0!==r||boundsError(t,this.length-8);const n=e*2**24+65536*this[++t]+256*this[++t]+this[++t],f=this[++t]*2**24+65536*this[++t]+256*this[++t]+r;return(BigInt(n)<<BigInt(32))+BigInt(f)})),Buffer.prototype.readIntLE=function readIntLE(t,e,r){t>>>=0,e>>>=0,r||checkOffset(t,e,this.length);let n=this[t],f=1,i=0;for(;++i<e&&(f*=256);)n+=this[t+i]*f;return f*=128,n>=f&&(n-=Math.pow(2,8*e)),n},Buffer.prototype.readIntBE=function readIntBE(t,e,r){t>>>=0,e>>>=0,r||checkOffset(t,e,this.length);let n=e,f=1,i=this[t+--n];for(;n>0&&(f*=256);)i+=this[t+--n]*f;return f*=128,i>=f&&(i-=Math.pow(2,8*e)),i},Buffer.prototype.readInt8=function readInt8(t,e){return t>>>=0,e||checkOffset(t,1,this.length),128&this[t]?-1*(255-this[t]+1):this[t]},Buffer.prototype.readInt16LE=function readInt16LE(t,e){t>>>=0,e||checkOffset(t,2,this.length);const r=this[t]|this[t+1]<<8;return 32768&r?4294901760|r:r},Buffer.prototype.readInt16BE=function readInt16BE(t,e){t>>>=0,e||checkOffset(t,2,this.length);const r=this[t+1]|this[t]<<8;return 32768&r?4294901760|r:r},Buffer.prototype.readInt32LE=function readInt32LE(t,e){return t>>>=0,e||checkOffset(t,4,this.length),this[t]|this[t+1]<<8|this[t+2]<<16|this[t+3]<<24},Buffer.prototype.readInt32BE=function readInt32BE(t,e){return t>>>=0,e||checkOffset(t,4,this.length),this[t]<<24|this[t+1]<<16|this[t+2]<<8|this[t+3]},Buffer.prototype.readBigInt64LE=defineBigIntMethod((function readBigInt64LE(t){validateNumber(t>>>=0,"offset");const e=this[t],r=this[t+7];void 0!==e&&void 0!==r||boundsError(t,this.length-8);const n=this[t+4]+256*this[t+5]+65536*this[t+6]+(r<<24);return(BigInt(n)<<BigInt(32))+BigInt(e+256*this[++t]+65536*this[++t]+this[++t]*2**24)})),Buffer.prototype.readBigInt64BE=defineBigIntMethod((function readBigInt64BE(t){validateNumber(t>>>=0,"offset");const e=this[t],r=this[t+7];void 0!==e&&void 0!==r||boundsError(t,this.length-8);const n=(e<<24)+65536*this[++t]+256*this[++t]+this[++t];return(BigInt(n)<<BigInt(32))+BigInt(this[++t]*2**24+65536*this[++t]+256*this[++t]+r)})),Buffer.prototype.readFloatLE=function readFloatLE(t,e){return t>>>=0,e||checkOffset(t,4,this.length),f.read(this,t,!0,23,4)},Buffer.prototype.readFloatBE=function readFloatBE(t,e){return t>>>=0,e||checkOffset(t,4,this.length),f.read(this,t,!1,23,4)},Buffer.prototype.readDoubleLE=function readDoubleLE(t,e){return t>>>=0,e||checkOffset(t,8,this.length),f.read(this,t,!0,52,8)},Buffer.prototype.readDoubleBE=function readDoubleBE(t,e){return t>>>=0,e||checkOffset(t,8,this.length),f.read(this,t,!1,52,8)},Buffer.prototype.writeUintLE=Buffer.prototype.writeUIntLE=function writeUIntLE(t,e,r,n){if(t=+t,e>>>=0,r>>>=0,!n){checkInt(this,t,e,r,Math.pow(2,8*r)-1,0)}let f=1,i=0;for(this[e]=255&t;++i<r&&(f*=256);)this[e+i]=t/f&255;return e+r},Buffer.prototype.writeUintBE=Buffer.prototype.writeUIntBE=function writeUIntBE(t,e,r,n){if(t=+t,e>>>=0,r>>>=0,!n){checkInt(this,t,e,r,Math.pow(2,8*r)-1,0)}let f=r-1,i=1;for(this[e+f]=255&t;--f>=0&&(i*=256);)this[e+f]=t/i&255;return e+r},Buffer.prototype.writeUint8=Buffer.prototype.writeUInt8=function writeUInt8(t,e,r){return t=+t,e>>>=0,r||checkInt(this,t,e,1,255,0),this[e]=255&t,e+1},Buffer.prototype.writeUint16LE=Buffer.prototype.writeUInt16LE=function writeUInt16LE(t,e,r){return t=+t,e>>>=0,r||checkInt(this,t,e,2,65535,0),this[e]=255&t,this[e+1]=t>>>8,e+2},Buffer.prototype.writeUint16BE=Buffer.prototype.writeUInt16BE=function writeUInt16BE(t,e,r){return t=+t,e>>>=0,r||checkInt(this,t,e,2,65535,0),this[e]=t>>>8,this[e+1]=255&t,e+2},Buffer.prototype.writeUint32LE=Buffer.prototype.writeUInt32LE=function writeUInt32LE(t,e,r){return t=+t,e>>>=0,r||checkInt(this,t,e,4,4294967295,0),this[e+3]=t>>>24,this[e+2]=t>>>16,this[e+1]=t>>>8,this[e]=255&t,e+4},Buffer.prototype.writeUint32BE=Buffer.prototype.writeUInt32BE=function writeUInt32BE(t,e,r){return t=+t,e>>>=0,r||checkInt(this,t,e,4,4294967295,0),this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t,e+4},Buffer.prototype.writeBigUInt64LE=defineBigIntMethod((function writeBigUInt64LE(t,e=0){return wrtBigUInt64LE(this,t,e,BigInt(0),BigInt("0xffffffffffffffff"))})),Buffer.prototype.writeBigUInt64BE=defineBigIntMethod((function writeBigUInt64BE(t,e=0){return wrtBigUInt64BE(this,t,e,BigInt(0),BigInt("0xffffffffffffffff"))})),Buffer.prototype.writeIntLE=function writeIntLE(t,e,r,n){if(t=+t,e>>>=0,!n){const n=Math.pow(2,8*r-1);checkInt(this,t,e,r,n-1,-n)}let f=0,i=1,o=0;for(this[e]=255&t;++f<r&&(i*=256);)t<0&&0===o&&0!==this[e+f-1]&&(o=1),this[e+f]=(t/i>>0)-o&255;return e+r},Buffer.prototype.writeIntBE=function writeIntBE(t,e,r,n){if(t=+t,e>>>=0,!n){const n=Math.pow(2,8*r-1);checkInt(this,t,e,r,n-1,-n)}let f=r-1,i=1,o=0;for(this[e+f]=255&t;--f>=0&&(i*=256);)t<0&&0===o&&0!==this[e+f+1]&&(o=1),this[e+f]=(t/i>>0)-o&255;return e+r},Buffer.prototype.writeInt8=function writeInt8(t,e,r){return t=+t,e>>>=0,r||checkInt(this,t,e,1,127,-128),t<0&&(t=255+t+1),this[e]=255&t,e+1},Buffer.prototype.writeInt16LE=function writeInt16LE(t,e,r){return t=+t,e>>>=0,r||checkInt(this,t,e,2,32767,-32768),this[e]=255&t,this[e+1]=t>>>8,e+2},Buffer.prototype.writeInt16BE=function writeInt16BE(t,e,r){return t=+t,e>>>=0,r||checkInt(this,t,e,2,32767,-32768),this[e]=t>>>8,this[e+1]=255&t,e+2},Buffer.prototype.writeInt32LE=function writeInt32LE(t,e,r){return t=+t,e>>>=0,r||checkInt(this,t,e,4,2147483647,-2147483648),this[e]=255&t,this[e+1]=t>>>8,this[e+2]=t>>>16,this[e+3]=t>>>24,e+4},Buffer.prototype.writeInt32BE=function writeInt32BE(t,e,r){return t=+t,e>>>=0,r||checkInt(this,t,e,4,2147483647,-2147483648),t<0&&(t=4294967295+t+1),this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t,e+4},Buffer.prototype.writeBigInt64LE=defineBigIntMethod((function writeBigInt64LE(t,e=0){return wrtBigUInt64LE(this,t,e,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))})),Buffer.prototype.writeBigInt64BE=defineBigIntMethod((function writeBigInt64BE(t,e=0){return wrtBigUInt64BE(this,t,e,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))})),Buffer.prototype.writeFloatLE=function writeFloatLE(t,e,r){return writeFloat(this,t,e,!0,r)},Buffer.prototype.writeFloatBE=function writeFloatBE(t,e,r){return writeFloat(this,t,e,!1,r)},Buffer.prototype.writeDoubleLE=function writeDoubleLE(t,e,r){return writeDouble(this,t,e,!0,r)},Buffer.prototype.writeDoubleBE=function writeDoubleBE(t,e,r){return writeDouble(this,t,e,!1,r)},Buffer.prototype.copy=function copy(t,e,r,n){if(!Buffer.isBuffer(t))throw new TypeError("argument should be a Buffer");if(r||(r=0),n||0===n||(n=this.length),e>=t.length&&(e=t.length),e||(e=0),n>0&&n<r&&(n=r),n===r)return 0;if(0===t.length||0===this.length)return 0;if(e<0)throw new RangeError("targetStart out of bounds");if(r<0||r>=this.length)throw new RangeError("Index out of range");if(n<0)throw new RangeError("sourceEnd out of bounds");n>this.length&&(n=this.length),t.length-e<n-r&&(n=t.length-e+r);const f=n-r;return this===t&&"function"===typeof Uint8Array.prototype.copyWithin?this.copyWithin(e,r,n):Uint8Array.prototype.set.call(t,this.subarray(r,n),e),f},Buffer.prototype.fill=function fill(t,e,r,n){if("string"===typeof t){if("string"===typeof e?(n=e,e=0,r=this.length):"string"===typeof r&&(n=r,r=this.length),void 0!==n&&"string"!==typeof n)throw new TypeError("encoding must be a string");if("string"===typeof n&&!Buffer.isEncoding(n))throw new TypeError("Unknown encoding: "+n);if(1===t.length){const e=t.charCodeAt(0);("utf8"===n&&e<128||"latin1"===n)&&(t=e)}}else"number"===typeof t?t&=255:"boolean"===typeof t&&(t=Number(t));if(e<0||this.length<e||this.length<r)throw new RangeError("Out of range index");if(r<=e)return this;let f;if(e>>>=0,r=void 0===r?this.length:r>>>0,t||(t=0),"number"===typeof t)for(f=e;f<r;++f)this[f]=t;else{const i=Buffer.isBuffer(t)?t:Buffer.from(t,n),o=i.length;if(0===o)throw new TypeError('The value "'+t+'" is invalid for argument "value"');for(f=0;f<r-e;++f)this[f+e]=i[f%o]}return this};const s={};function E(t,e,r){s[t]=class NodeError extends r{constructor(){super(),Object.defineProperty(this,"message",{value:e.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${t}]`,this.stack,delete this.name}get code(){return t}set code(t){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:t,writable:!0})}toString(){return`${this.name} [${t}]: ${this.message}`}}}function addNumericalSeparator(t){let e="",r=t.length;const n="-"===t[0]?1:0;for(;r>=n+4;r-=3)e=`_${t.slice(r-3,r)}${e}`;return`${t.slice(0,r)}${e}`}function checkIntBI(t,e,r,n,f,i){if(t>r||t<e){const n="bigint"===typeof e?"n":"";let f;throw f=i>3?0===e||e===BigInt(0)?`>= 0${n} and < 2${n} ** ${8*(i+1)}${n}`:`>= -(2${n} ** ${8*(i+1)-1}${n}) and < 2 ** ${8*(i+1)-1}${n}`:`>= ${e}${n} and <= ${r}${n}`,new s.ERR_OUT_OF_RANGE("value",f,t)}!function checkBounds(t,e,r){validateNumber(e,"offset"),void 0!==t[e]&&void 0!==t[e+r]||boundsError(e,t.length-(r+1))}(n,f,i)}function validateNumber(t,e){if("number"!==typeof t)throw new s.ERR_INVALID_ARG_TYPE(e,"number",t)}function boundsError(t,e,r){if(Math.floor(t)!==t)throw validateNumber(t,r),new s.ERR_OUT_OF_RANGE(r||"offset","an integer",t);if(e<0)throw new s.ERR_BUFFER_OUT_OF_BOUNDS;throw new s.ERR_OUT_OF_RANGE(r||"offset",`>= ${r?1:0} and <= ${e}`,t)}E("ERR_BUFFER_OUT_OF_BOUNDS",(function(t){return t?`${t} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"}),RangeError),E("ERR_INVALID_ARG_TYPE",(function(t,e){return`The "${t}" argument must be of type number. Received type ${typeof e}`}),TypeError),E("ERR_OUT_OF_RANGE",(function(t,e,r){let n=`The value of "${t}" is out of range.`,f=r;return Number.isInteger(r)&&Math.abs(r)>2**32?f=addNumericalSeparator(String(r)):"bigint"===typeof r&&(f=String(r),(r>BigInt(2)**BigInt(32)||r<-(BigInt(2)**BigInt(32)))&&(f=addNumericalSeparator(f)),f+="n"),n+=` It must be ${e}. Received ${f}`,n}),RangeError);const h=/[^+/0-9A-Za-z-_]/g;function utf8ToBytes(t,e){let r;e=e||1/0;const n=t.length;let f=null;const i=[];for(let o=0;o<n;++o){if(r=t.charCodeAt(o),r>55295&&r<57344){if(!f){if(r>56319){(e-=3)>-1&&i.push(239,191,189);continue}if(o+1===n){(e-=3)>-1&&i.push(239,191,189);continue}f=r;continue}if(r<56320){(e-=3)>-1&&i.push(239,191,189),f=r;continue}r=65536+(f-55296<<10|r-56320)}else f&&(e-=3)>-1&&i.push(239,191,189);if(f=null,r<128){if((e-=1)<0)break;i.push(r)}else if(r<2048){if((e-=2)<0)break;i.push(r>>6|192,63&r|128)}else if(r<65536){if((e-=3)<0)break;i.push(r>>12|224,r>>6&63|128,63&r|128)}else{if(!(r<1114112))throw new Error("Invalid code point");if((e-=4)<0)break;i.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128)}}return i}function base64ToBytes(t){return n.toByteArray(function base64clean(t){if((t=(t=t.split("=")[0]).trim().replace(h,"")).length<2)return"";for(;t.length%4!==0;)t+="=";return t}(t))}function blitBuffer(t,e,r,n){let f;for(f=0;f<n&&!(f+r>=e.length||f>=t.length);++f)e[f+r]=t[f];return f}function isInstance(t,e){return t instanceof e||null!=t&&null!=t.constructor&&null!=t.constructor.name&&t.constructor.name===e.name}function numberIsNaN(t){return t!==t}const a=function(){const t="0123456789abcdef",e=new Array(256);for(let r=0;r<16;++r){const n=16*r;for(let f=0;f<16;++f)e[n+f]=t[r]+t[f]}return e}();function defineBigIntMethod(t){return"undefined"===typeof BigInt?BufferBigIntNotDefined:t}function BufferBigIntNotDefined(){throw new Error("BigInt not supported")}},645:(t,e)=>{e.read=function(t,e,r,n,f){var i,o,u=8*f-n-1,s=(1<<u)-1,h=s>>1,a=-7,c=r?f-1:0,l=r?-1:1,p=t[e+c];for(c+=l,i=p&(1<<-a)-1,p>>=-a,a+=u;a>0;i=256*i+t[e+c],c+=l,a-=8);for(o=i&(1<<-a)-1,i>>=-a,a+=n;a>0;o=256*o+t[e+c],c+=l,a-=8);if(0===i)i=1-h;else{if(i===s)return o?NaN:1/0*(p?-1:1);o+=Math.pow(2,n),i-=h}return(p?-1:1)*o*Math.pow(2,i-n)},e.write=function(t,e,r,n,f,i){var o,u,s,h=8*i-f-1,a=(1<<h)-1,c=a>>1,l=23===f?Math.pow(2,-24)-Math.pow(2,-77):0,p=n?0:i-1,B=n?1:-1,g=e<0||0===e&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(u=isNaN(e)?1:0,o=a):(o=Math.floor(Math.log(e)/Math.LN2),e*(s=Math.pow(2,-o))<1&&(o--,s*=2),(e+=o+c>=1?l/s:l*Math.pow(2,1-c))*s>=2&&(o++,s/=2),o+c>=a?(u=0,o=a):o+c>=1?(u=(e*s-1)*Math.pow(2,f),o+=c):(u=e*Math.pow(2,c-1)*Math.pow(2,f),o=0));f>=8;t[r+p]=255&u,p+=B,u/=256,f-=8);for(o=o<<f|u,h+=f;h>0;t[r+p]=255&o,p+=B,o/=256,h-=8);t[r+p-B]|=128*g}}},e={};var r=function __webpack_require__(r){var n=e[r];if(void 0!==n)return n.exports;var f=e[r]={exports:{}};return t[r](f,f.exports,__webpack_require__),f.exports}(8764);window.buffer=r})();
/*! For license information please see rogue-engine.js.LICENSE.txt */
(()=>{var e={7187:e=>{"use strict";var t,i="object"===typeof Reflect?Reflect:null,n=i&&"function"===typeof i.apply?i.apply:function ReflectApply(e,t,i){return Function.prototype.apply.call(e,t,i)};t=i&&"function"===typeof i.ownKeys?i.ownKeys:Object.getOwnPropertySymbols?function ReflectOwnKeys(e){return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}:function ReflectOwnKeys(e){return Object.getOwnPropertyNames(e)};var s=Number.isNaN||function NumberIsNaN(e){return e!==e};function EventEmitter(){EventEmitter.init.call(this)}e.exports=EventEmitter,e.exports.once=function once(e,t){return new Promise((function(i,n){function errorListener(i){e.removeListener(t,resolver),n(i)}function resolver(){"function"===typeof e.removeListener&&e.removeListener("error",errorListener),i([].slice.call(arguments))}eventTargetAgnosticAddListener(e,t,resolver,{once:!0}),"error"!==t&&function addErrorHandlerIfEventEmitter(e,t,i){"function"===typeof e.on&&eventTargetAgnosticAddListener(e,"error",t,i)}(e,errorListener,{once:!0})}))},EventEmitter.EventEmitter=EventEmitter,EventEmitter.prototype._events=void 0,EventEmitter.prototype._eventsCount=0,EventEmitter.prototype._maxListeners=void 0;var o=10;function checkListener(e){if("function"!==typeof e)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof e)}function _getMaxListeners(e){return void 0===e._maxListeners?EventEmitter.defaultMaxListeners:e._maxListeners}function _addListener(e,t,i,n){var s,o,r;if(checkListener(i),void 0===(o=e._events)?(o=e._events=Object.create(null),e._eventsCount=0):(void 0!==o.newListener&&(e.emit("newListener",t,i.listener?i.listener:i),o=e._events),r=o[t]),void 0===r)r=o[t]=i,++e._eventsCount;else if("function"===typeof r?r=o[t]=n?[i,r]:[r,i]:n?r.unshift(i):r.push(i),(s=_getMaxListeners(e))>0&&r.length>s&&!r.warned){r.warned=!0;var a=new Error("Possible EventEmitter memory leak detected. "+r.length+" "+String(t)+" listeners added. Use emitter.setMaxListeners() to increase limit");a.name="MaxListenersExceededWarning",a.emitter=e,a.type=t,a.count=r.length,function ProcessEmitWarning(e){console&&console.warn&&console.warn(e)}(a)}return e}function onceWrapper(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,0===arguments.length?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function _onceWrap(e,t,i){var n={fired:!1,wrapFn:void 0,target:e,type:t,listener:i},s=onceWrapper.bind(n);return s.listener=i,n.wrapFn=s,s}function _listeners(e,t,i){var n=e._events;if(void 0===n)return[];var s=n[t];return void 0===s?[]:"function"===typeof s?i?[s.listener||s]:[s]:i?function unwrapListeners(e){for(var t=new Array(e.length),i=0;i<t.length;++i)t[i]=e[i].listener||e[i];return t}(s):arrayClone(s,s.length)}function listenerCount(e){var t=this._events;if(void 0!==t){var i=t[e];if("function"===typeof i)return 1;if(void 0!==i)return i.length}return 0}function arrayClone(e,t){for(var i=new Array(t),n=0;n<t;++n)i[n]=e[n];return i}function eventTargetAgnosticAddListener(e,t,i,n){if("function"===typeof e.on)n.once?e.once(t,i):e.on(t,i);else{if("function"!==typeof e.addEventListener)throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof e);e.addEventListener(t,(function wrapListener(s){n.once&&e.removeEventListener(t,wrapListener),i(s)}))}}Object.defineProperty(EventEmitter,"defaultMaxListeners",{enumerable:!0,get:function(){return o},set:function(e){if("number"!==typeof e||e<0||s(e))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+e+".");o=e}}),EventEmitter.init=function(){void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},EventEmitter.prototype.setMaxListeners=function setMaxListeners(e){if("number"!==typeof e||e<0||s(e))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+e+".");return this._maxListeners=e,this},EventEmitter.prototype.getMaxListeners=function getMaxListeners(){return _getMaxListeners(this)},EventEmitter.prototype.emit=function emit(e){for(var t=[],i=1;i<arguments.length;i++)t.push(arguments[i]);var s="error"===e,o=this._events;if(void 0!==o)s=s&&void 0===o.error;else if(!s)return!1;if(s){var r;if(t.length>0&&(r=t[0]),r instanceof Error)throw r;var a=new Error("Unhandled error."+(r?" ("+r.message+")":""));throw a.context=r,a}var u=o[e];if(void 0===u)return!1;if("function"===typeof u)n(u,this,t);else{var c=u.length,h=arrayClone(u,c);for(i=0;i<c;++i)n(h[i],this,t)}return!0},EventEmitter.prototype.addListener=function addListener(e,t){return _addListener(this,e,t,!1)},EventEmitter.prototype.on=EventEmitter.prototype.addListener,EventEmitter.prototype.prependListener=function prependListener(e,t){return _addListener(this,e,t,!0)},EventEmitter.prototype.once=function once(e,t){return checkListener(t),this.on(e,_onceWrap(this,e,t)),this},EventEmitter.prototype.prependOnceListener=function prependOnceListener(e,t){return checkListener(t),this.prependListener(e,_onceWrap(this,e,t)),this},EventEmitter.prototype.removeListener=function removeListener(e,t){var i,n,s,o,r;if(checkListener(t),void 0===(n=this._events))return this;if(void 0===(i=n[e]))return this;if(i===t||i.listener===t)0===--this._eventsCount?this._events=Object.create(null):(delete n[e],n.removeListener&&this.emit("removeListener",e,i.listener||t));else if("function"!==typeof i){for(s=-1,o=i.length-1;o>=0;o--)if(i[o]===t||i[o].listener===t){r=i[o].listener,s=o;break}if(s<0)return this;0===s?i.shift():function spliceOne(e,t){for(;t+1<e.length;t++)e[t]=e[t+1];e.pop()}(i,s),1===i.length&&(n[e]=i[0]),void 0!==n.removeListener&&this.emit("removeListener",e,r||t)}return this},EventEmitter.prototype.off=EventEmitter.prototype.removeListener,EventEmitter.prototype.removeAllListeners=function removeAllListeners(e){var t,i,n;if(void 0===(i=this._events))return this;if(void 0===i.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==i[e]&&(0===--this._eventsCount?this._events=Object.create(null):delete i[e]),this;if(0===arguments.length){var s,o=Object.keys(i);for(n=0;n<o.length;++n)"removeListener"!==(s=o[n])&&this.removeAllListeners(s);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if("function"===typeof(t=i[e]))this.removeListener(e,t);else if(void 0!==t)for(n=t.length-1;n>=0;n--)this.removeListener(e,t[n]);return this},EventEmitter.prototype.listeners=function listeners(e){return _listeners(this,e,!0)},EventEmitter.prototype.rawListeners=function rawListeners(e){return _listeners(this,e,!1)},EventEmitter.listenerCount=function(e,t){return"function"===typeof e.listenerCount?e.listenerCount(t):listenerCount.call(e,t)},EventEmitter.prototype.listenerCount=listenerCount,EventEmitter.prototype.eventNames=function eventNames(){return this._eventsCount>0?t(this._events):[]}},2705:(e,t,i)=>{var n=i(5639).Symbol;e.exports=n},4239:(e,t,i)=>{var n=i(2705),s=i(9607),o=i(2333),r="[object Null]",a="[object Undefined]",u=n?n.toStringTag:void 0;e.exports=function baseGetTag(e){return null==e?void 0===e?a:r:u&&u in Object(e)?s(e):o(e)}},7561:(e,t,i)=>{var n=i(7990),s=/^\s+/;e.exports=function baseTrim(e){return e?e.slice(0,n(e)+1).replace(s,""):e}},1957:(e,t,i)=>{var n="object"==typeof i.g&&i.g&&i.g.Object===Object&&i.g;e.exports=n},9607:(e,t,i)=>{var n=i(2705),s=Object.prototype,o=s.hasOwnProperty,r=s.toString,a=n?n.toStringTag:void 0;e.exports=function getRawTag(e){var t=o.call(e,a),i=e[a];try{e[a]=void 0;var n=!0}catch(u){}var s=r.call(e);return n&&(t?e[a]=i:delete e[a]),s}},2333:e=>{var t=Object.prototype.toString;e.exports=function objectToString(e){return t.call(e)}},5639:(e,t,i)=>{var n=i(1957),s="object"==typeof self&&self&&self.Object===Object&&self,o=n||s||Function("return this")();e.exports=o},7990:e=>{var t=/\s/;e.exports=function trimmedEndIndex(e){for(var i=e.length;i--&&t.test(e.charAt(i)););return i}},3279:(e,t,i)=>{var n=i(3218),s=i(7771),o=i(4841),r="Expected a function",a=Math.max,u=Math.min;e.exports=function debounce(e,t,i){var c,h,d,l,p,f,m=0,g=!1,_=!1,b=!0;if("function"!=typeof e)throw new TypeError(r);function invokeFunc(t){var i=c,n=h;return c=h=void 0,m=t,l=e.apply(n,i)}function shouldInvoke(e){var i=e-f;return void 0===f||i>=t||i<0||_&&e-m>=d}function timerExpired(){var e=s();if(shouldInvoke(e))return trailingEdge(e);p=setTimeout(timerExpired,function remainingWait(e){var i=t-(e-f);return _?u(i,d-(e-m)):i}(e))}function trailingEdge(e){return p=void 0,b&&c?invokeFunc(e):(c=h=void 0,l)}function debounced(){var e=s(),i=shouldInvoke(e);if(c=arguments,h=this,f=e,i){if(void 0===p)return function leadingEdge(e){return m=e,p=setTimeout(timerExpired,t),g?invokeFunc(e):l}(f);if(_)return clearTimeout(p),p=setTimeout(timerExpired,t),invokeFunc(f)}return void 0===p&&(p=setTimeout(timerExpired,t)),l}return t=o(t)||0,n(i)&&(g=!!i.leading,d=(_="maxWait"in i)?a(o(i.maxWait)||0,t):d,b="trailing"in i?!!i.trailing:b),debounced.cancel=function cancel(){void 0!==p&&clearTimeout(p),m=0,c=f=h=p=void 0},debounced.flush=function flush(){return void 0===p?l:trailingEdge(s())},debounced}},3218:e=>{e.exports=function isObject(e){var t=typeof e;return null!=e&&("object"==t||"function"==t)}},7005:e=>{e.exports=function isObjectLike(e){return null!=e&&"object"==typeof e}},3448:(e,t,i)=>{var n=i(4239),s=i(7005),o="[object Symbol]";e.exports=function isSymbol(e){return"symbol"==typeof e||s(e)&&n(e)==o}},7771:(e,t,i)=>{var n=i(5639);e.exports=function(){return n.Date.now()}},3493:(e,t,i)=>{var n=i(3279),s=i(3218),o="Expected a function";e.exports=function throttle(e,t,i){var r=!0,a=!0;if("function"!=typeof e)throw new TypeError(o);return s(i)&&(r="leading"in i?!!i.leading:r,a="trailing"in i?!!i.trailing:a),n(e,t,{leading:r,maxWait:t,trailing:a})}},4841:(e,t,i)=>{var n=i(7561),s=i(3218),o=i(3448),r=NaN,a=/^[-+]0x[0-9a-f]+$/i,u=/^0b[01]+$/i,c=/^0o[0-7]+$/i,h=parseInt;e.exports=function toNumber(e){if("number"==typeof e)return e;if(o(e))return r;if(s(e)){var t="function"==typeof e.valueOf?e.valueOf():e;e=s(t)?t+"":t}if("string"!=typeof e)return 0===e?e:+e;e=n(e);var i=u.test(e);return i||c.test(e)?h(e.slice(2),i?2:8):a.test(e)?r:+e}},5327:e=>{for(var t=[],i=0;i<256;++i)t[i]=(i+256).toString(16).substr(1);e.exports=function bytesToUuid(e,i){var n=i||0,s=t;return[s[e[n++]],s[e[n++]],s[e[n++]],s[e[n++]],"-",s[e[n++]],s[e[n++]],"-",s[e[n++]],s[e[n++]],"-",s[e[n++]],s[e[n++]],"-",s[e[n++]],s[e[n++]],s[e[n++]],s[e[n++]],s[e[n++]],s[e[n++]]].join("")}},5217:e=>{var t="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof window.msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto);if(t){var i=new Uint8Array(16);e.exports=function whatwgRNG(){return t(i),i}}else{var n=new Array(16);e.exports=function mathRNG(){for(var e,t=0;t<16;t++)0===(3&t)&&(e=4294967296*Math.random()),n[t]=e>>>((3&t)<<3)&255;return n}}},1171:(e,t,i)=>{var n=i(5217),s=i(5327);e.exports=function v4(e,t,i){var o=t&&i||0;"string"==typeof e&&(t="binary"===e?new Array(16):null,e=null);var r=(e=e||{}).random||(e.rng||n)();if(r[6]=15&r[6]|64,r[8]=63&r[8]|128,t)for(var a=0;a<16;++a)t[o+a]=r[a];return t||s(r)}}},t={};function __webpack_require__(i){var n=t[i];if(void 0!==n)return n.exports;var s=t[i]={exports:{}};return e[i](s,s.exports,__webpack_require__),s.exports}__webpack_require__.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(t,{a:t}),t},__webpack_require__.d=(e,t)=>{for(var i in t)__webpack_require__.o(t,i)&&!__webpack_require__.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:t[i]})},__webpack_require__.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"===typeof window)return window}}(),__webpack_require__.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),__webpack_require__.r=e=>{"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var i={};(()=>{"use strict";__webpack_require__.r(i),__webpack_require__.d(i,{App:()=>App,AssetManager:()=>j,AudioAsset:()=>AudioAsset,Component:()=>Component,Debug:()=>Debug,Error:()=>Debug_Error,Input:()=>Input,Log:()=>Log,Prefab:()=>Prefab,Prop:()=>Prop,PropList:()=>PropList,Runtime:()=>m,RuntimeController:()=>RuntimeController,SceneController:()=>SceneController,Skybox:()=>g,Tags:()=>Tags,Warning:()=>Warning,addComponent:()=>addComponent,clearComponents:()=>clearComponents,components:()=>C,copyObjectComponents:()=>copyObjectComponents,dispose:()=>dispose,editorComponents:()=>w,getComponent:()=>getComponent,getComponentByName:()=>getComponentByName,getComponentPrototypes:()=>getComponentPrototypes,getComponents:()=>getComponents,getObjectComponents:()=>getObjectComponents,getStaticPath:()=>getStaticPath,initComponents:()=>initComponents,initEditorComponents:()=>initEditorComponents,isActive:()=>isActive,isDev:()=>isDev,isEnabled:()=>isEnabled,loadComponents:()=>loadComponents,onAfterUpdate:()=>onAfterUpdate,onBeforeUpdate:()=>onBeforeUpdate,onComponentAdded:()=>onComponentAdded,onComponentLoaded:()=>onComponentLoaded,onComponentRemoved:()=>onComponentRemoved,onNextFrame:()=>onNextFrame,onObjectAdded:()=>onObjectAdded,onObjectRemoved:()=>onObjectRemoved,onUpdate:()=>onUpdate,props:()=>I,registerComponent:()=>registerComponent,removeComponent:()=>removeComponent,removeComponents:()=>removeComponents,serializeComponents:()=>serializeComponents,setEnabled:()=>setEnabled,traverseComponents:()=>traverseComponents});const e=window.three;function __awaiter(e,t,i,n){return new(i||(i=Promise))((function(s,o){function fulfilled(e){try{step(n.next(e))}catch(t){o(t)}}function rejected(e){try{step(n.throw(e))}catch(t){o(t)}}function step(e){e.done?s(e.value):function adopt(e){return e instanceof i?e:new i((function(t){t(e)}))}(e.value).then(fulfilled,rejected)}step((n=n.apply(e,t||[])).next())}))}class Lifecycle{}class Debug{static clear(){this.logs.splice(0,this.logs.length),this.flushOnClearLogsCallbacks()}static log(e){let t=new Log(e);this.addLog(t),this.flushOnAddLogCallbacks(t),console.log(e)}static logError(e){let t=new Debug_Error(e);this.addLog(t),this.flushOnAddLogCallbacks(t),console.error(e)}static logWarning(e){let t=new Warning(e);this.addLog(t),this.flushOnAddLogCallbacks(t),console.warn(e)}static addLog(e){this.logs.length>=this.maxLogs&&this.logs.shift(),this.logs.push(e)}static onAddLog(e){return this._onAddLogCallbacks.push(e),{stop:()=>{this._onAddLogCallbacks.splice(this._onAddLogCallbacks.indexOf(e),1)}}}static onClearLogs(e){return this._onClearLogsCallbacks.push(e),{stop:()=>{this._onClearLogsCallbacks.splice(this._onClearLogsCallbacks.indexOf(e),1)}}}static flushOnAddLogCallbacks(e){for(let t in this._onAddLogCallbacks)this._onAddLogCallbacks[t](e)}static flushOnClearLogsCallbacks(){for(let e in this._onClearLogsCallbacks)this._onClearLogsCallbacks[e]()}}Debug.maxLogs=50,Debug.logs=[],Debug._onAddLogCallbacks=[],Debug._onClearLogsCallbacks=[];class Log{get type(){return this._type}constructor(e){this.message=e,this._type="Log"}}class Debug_Error extends Log{constructor(e){super(e),this._type="Error"}}class Warning extends Log{constructor(e){super(e),this._type="Warning"}}var t=__webpack_require__(3493),n=__webpack_require__.n(t),s=__webpack_require__(7187);let o=new(__webpack_require__.n(s)());const r=[],a=[],objectEvensHandler=(e,t,i)=>{if(0===i.length)return;const n=[];for(let s=0;s<i.length;s++)n.push(i[s]);for(let s=0;s<n.length;s++)n[s](e,t)};function onObjectAdded(e){return r.push(e),{stop:()=>{let t=r.indexOf(e);t<0||r.splice(t,1)}}}function onObjectRemoved(e){return a.push(e),{stop:()=>{let t=a.indexOf(e);t<0||a.splice(t,1)}}}function objectAdded(e,t){objectEvensHandler(e,t,r)}const u=[],c=[],h=[],componentEvensHandler=(e,t,i)=>{if(0===i.length)return;const n=[];for(let s=0;s<i.length;s++)n.push(i[s]);for(let s=0;s<n.length;s++)n[s](e,t)};function onComponentAdded(e){return u.push(e),{stop:()=>{let t=u.indexOf(e);t<0||u.splice(t,1)}}}function onComponentLoaded(e){return c.push(e),{stop:()=>{let t=c.indexOf(e);t<0||c.splice(t,1)}}}function onComponentRemoved(e){return h.push(e),{stop:()=>{let t=h.indexOf(e);t<0||h.splice(t,1)}}}function componentRemoved(e,t){componentEvensHandler(e,t,h)}const d=[],l=[],p=[],f=[],updateEvensHandler=(e,t)=>{if(0===t.length)return;const i=[];for(let n=0;n<t.length;n++)i.push(t[n]);for(let n=0;n<i.length;n++)i[n](e)};function onBeforeUpdate(e){return d.push(e),{stop:()=>{let t=d.indexOf(e);t<0||d.splice(t,1)}}}function onUpdate(e){return l.push(e),{stop:()=>{let t=l.indexOf(e);t<0||l.splice(t,1)}}}function onAfterUpdate(e){return p.push(e),{stop:()=>{let t=p.indexOf(e);t<0||p.splice(t,1)}}}function onNextFrame(e){const callbackWrapper=t=>{e(t);let i=f.indexOf(callbackWrapper);i<0||f.splice(i,1)};f.push(callbackWrapper)}function isDev(){return window.ROGUE_ISDEV||!1}function getStaticPath(e){if(isDev()){const t=window.ROGUE_INEDITOR?"localhost":App.lanIP||"localhost";return`${window.RE_Protocol||window.location.protocol}//${t}:3110/Static/${e}`}{const t=window.re_prefix;return t?t+"/Static/"+e:"./Static/"+e}}function loadComponentsRecursive(e){const t=e.userData&&e.userData.components;(()=>{__awaiter(this,void 0,void 0,(function*(){t&&loadComponents(e,t),e.userData&&delete e.userData.components}))})();for(let i in e.children)loadComponentsRecursive(e.children[i])}function disposeMaterial(t){if(t instanceof e.Material){const e=j.getAssetConfig(t.uuid);if(e&&e.keepLoaded)return;for(let i in t){disposeTexture(t[i])}t.dispose&&t.dispose()}else Array.isArray(t)&&t.forEach((e=>{disposeMaterial(e)}))}function disposeTexture(t){if(t instanceof e.Texture){const e=j.getAssetConfig(t.uuid);if(e&&e.keepLoaded)return;t.dispose&&t.dispose()}}function dispose(t){t&&t.traverse((t=>{var i,n;if(t instanceof e.Mesh&&(t.geometry.dispose&&t.geometry.dispose(),disposeMaterial(t.material)),t instanceof e.SkinnedMesh&&t.skeleton&&(t.skeleton.dispose&&t.skeleton.dispose(),(null===(i=t.skeleton.boneTexture)||void 0===i?void 0:i.dispose)&&(null===(n=t.skeleton.boneTexture)||void 0===n||n.dispose())),t.parent){const e=t.parent.children.indexOf(t);e>=0&&(t.parent.children[e]=null),t.parent=null}}))}function isEnabled(e){return!!e&&!1!==e.userData.rogueEnabled}function isActive(e){return!!e&&(!!isEnabled(e)&&!1!==e.userData.rogueParentsEnabled)}function setEnabled(e,t){e&&(t&&!isEnabled(e)?function enable(e){if(!e)return;e.userData.rogueEnabled=!0,awakeObjectComponents(e),activateChildren(e)}(e):!t&&isEnabled(e)&&function disable(e){if(!e)return;e.userData.rogueEnabled=!1,disableObjectComponents(e),e.traverse((t=>{t!==e&&(t.userData.rogueParentsEnabled=!1,disableObjectComponents(t))}))}(e))}function awakeObjectComponents(e){if(!m.isRunning)return;if(!e)return;getObjectComponents(e).forEach((e=>{e.awake(),e.__STARTED__=!1}))}function disableObjectComponents(e){if(!m.isRunning)return;if(!e)return;getObjectComponents(e).forEach((e=>{e.onDisabled()}))}function activateChildren(e){if(e)for(let t of e.children)t.userData.rogueParentsEnabled=!0,awakeObjectComponents(t),isEnabled(t)&&activateChildren(t)}class SceneController extends Lifecycle{constructor(){super(),this.renderFunc=()=>this.defaultRenderFunc(),this._clock=new e.Clock,this._onPlayCallbacks=[],this._onStopCallbacks=[],this._throttledAdjustCameraAndRenderer=n()((()=>this.adjustCameraAndRenderer()),1e3,{}),this._containerId="rogue-app",this._isOffscreen=!1,this._stop=()=>{},this._deltaTime=0,this._pageVisibilityHandler=()=>{this._clock.running&&this._clock.stop(),!this._clock.running&&this._clock.start()},this.doOnResize=e=>{this.adjustCameraAndRenderer(!0),this.onResize()},this.onResize=()=>{},this.resizeObserver=new window.ResizeObserver(this.doOnResize),document.removeEventListener("visibilitychange",this._pageVisibilityHandler),document.addEventListener("visibilitychange",this._pageVisibilityHandler)}get defaultRenderFunc(){return()=>this._renderer.render(this._scene,this._camera||new e.OrthographicCamera(0,0,0,0,0,0))}get deltaTime(){return this._deltaTime||0}get height(){return this._height}get width(){return this._width}get containerId(){return this._containerId}get camera(){return this._camera}set camera(e){this._camera=e}get scene(){return this._scene}get renderer(){return this._renderer}get isRunning(){return this._isRunning}get isPaused(){return this._isPaused}get rogueDOMContainer(){return this._rogueDOMContainer}get clock(){return this._clock}onPlay(e){return this._onPlayCallbacks.push(e),{stop:()=>{let t=this._onPlayCallbacks.indexOf(e);t<0||this._onPlayCallbacks.splice(t,1)}}}onStop(e){this._onStopCallbacks.push(e);return{stop:()=>{let t=this._onStopCallbacks.indexOf(e);t<0||this._onStopCallbacks.splice(t,1)}}}loadMaterials(){const t={};App.currentScene.traverse((i=>{if(i.material instanceof e.Material){if(!j.getAssetPath(i.material.uuid))return;const e=j.getAsset(i.material.uuid);if(e)return void(i.material=e);t[i.material.uuid]?t[i.material.uuid].push(i):t[i.material.uuid]=[i]}}));for(const e in t)j.loadAsset(e).then((i=>{for(const n of t[e])n.material=i||n.material}))}play(t,i,n){this.isPaused?this._isPaused=!1:(this.renderFunc=()=>this.defaultRenderFunc(),this._scene=t,this._isRunning=!0,this.updateEventsHandler(this._onPlayCallbacks),this.loadMaterials(),this.startRenderer(i),this.resizeObserver.observe(this._rogueDOMContainer),this._renderer.setAnimationLoop(this.beginUpdateCycle.bind(this)),App.currentScene.traverse((t=>{if(t instanceof e.Mesh&&t.material instanceof e.Material)for(let i in t.material)t.material[i]instanceof e.Texture&&this.renderer.initTexture(t.material[i])})),initComponents(App.currentScene,n),this.awake(),this.start(),this._clock.start())}stop(){this._isRunning&&(this._clock.stop(),this.updateEventsHandler(this._onStopCallbacks),this._isRunning=!1,this._stop(),this._renderer.setAnimationLoop(null),this.resizeObserver.unobserve(this._rogueDOMContainer))}updateEventsHandler(e){if(0===e.length)return;const t=[];for(let i=0;i<e.length;i++)t.push(e[i]);for(let i=0;i<t.length;i++)t[i]()}pause(){this.isRunning&&!this.isPaused&&(this._isPaused=!0,this._stop())}resume(){this.isRunning&&this.isPaused&&this.play(this._scene)}togglePause(){this.isRunning&&(this.isPaused?this.resume():this.pause())}traverseObject3d(e,t){for(let i in e.children){let n=e.children[i];t(n),this.traverseObject3d(n,t)}}awake(){this.traverseSceneComponents((e=>{try{isActive(e.object3d)&&e.awake()}catch(t){Debug.logError(`${t.name} in ${e.name}: ${t.stack}`)}}))}start(){this.traverseSceneComponents((e=>{try{e.isReady&&isActive(e.object3d)&&(e.start(),e.__STARTED__=!0)}catch(t){Debug.logError(`${t.name} in ${e.name}: ${t.stack}`)}}))}beforeUpdate(){this.traverseSceneComponents((e=>{if(this.isRunning&&isActive(e.object3d))try{e.isReady&&!e.__STARTED__&&(e.start(),e.__STARTED__=!0),e.isReady&&e.__STARTED__&&e.beforeUpdate()}catch(t){Debug.logError(`${t.name} in ${e.name}: ${t.stack}`)}})),function runBeforeUpdate(e){updateEvensHandler(e,d)}(this)}update(){this.traverseSceneComponents((e=>{if(isActive(e.object3d))try{this.isRunning&&e.isReady&&e.__STARTED__&&e.update()}catch(t){Debug.logError(`${t.name} in ${e.name}: ${t.stack}`)}})),function runUpdate(e){updateEvensHandler(e,l)}(this)}afterUpdate(){this.traverseSceneComponents((e=>{if(isActive(e.object3d))try{this.isRunning&&e.isReady&&e.__STARTED__&&e.afterUpdate()}catch(t){Debug.logError(`${t.name} in ${e.name}: ${t.stack}`)}})),function runAfterUpdate(e){updateEvensHandler(e,p)}(this)}startRenderer(t){this._rogueDOMContainer=document.getElementById("rogue-app");if(!document.getElementById("rogue-canvas")){const e=document.createElement("canvas");e.id="rogue-canvas",this._rogueDOMContainer.appendChild(e)}const i=document.getElementById("rogue-canvas");i.style.display="block",this._isOffscreen=!1,this._renderer||(this._renderer=new e.WebGLRenderer({canvas:i,powerPreference:"high-performance",antialias:!0,alpha:!0})),this._renderer.shadowMap.enabled=!0,this.renderer.setPixelRatio(window.devicePixelRatio),this.setSceneDimensions(this._rogueDOMContainer.clientWidth/window.devicePixelRatio,this._rogueDOMContainer.clientHeight/window.devicePixelRatio),this._width=0,this._height=0}setSceneDimensions(e,t){this._renderer.setSize(e,t),this.setCameraDimensions(e,t)}setCameraDimensions(t,i){if(this.camera instanceof e.PerspectiveCamera)this.camera.aspect=t/i,this.camera.updateProjectionMatrix();else if(this.camera instanceof e.OrthographicCamera){let e=i/t;this.camera.left=-5,this.camera.right=5,this.camera.top=10*e/2,this.camera.bottom=-10*e/2,this.camera.updateProjectionMatrix()}}adjustCameraAndRenderer(e){let{width:t,height:i}=this._rogueDOMContainer.getBoundingClientRect();t=this._isOffscreen?t/window.devicePixelRatio:t,i=this._isOffscreen?i/window.devicePixelRatio:i;(this.camera&&(t!==this._width||i!==this._height)||e)&&(this._width=t,this._height=i,this.renderer.setSize(this._width,this._height),this.setCameraDimensions(this._width,this._height))}beginUpdateCycle(){this.isRunning&&this._rogueDOMContainer&&(this._isPaused?this._deltaTime=this.clock.getDelta():(this._deltaTime=this.clock.getDelta(),function runNextFrame(e){updateEvensHandler(e,f)}(this),this.beforeUpdate(),this.update(),this.isRunning&&(this.renderFunc(),this.afterUpdate())))}}class RuntimeController extends SceneController{constructor(){super(...arguments),this.onPlayCbsFlaggedForRemoval=[],this.onStopCbsFlaggedForRemoval=[]}play(e,t,i){this.isPaused||(o.emit("play"),this.createUIContainer()),j.sceneController=this;let n=App.currentScene.getObjectByProperty("uuid",App.activeCamera);n||(n=App.currentScene.getObjectByProperty("type","PerspectiveCamera")),n||(n=App.currentScene.getObjectByProperty("type","OrthographicCamera")),n||Debug.logWarning("Couldn't find an active camera for this scene"),n&&(App.activeCamera=n.uuid,this.camera=n),super.play(e,t,i)}onPlay(e){const t=super.onPlay(e);return this.isRunning&&this.onPlayCbsFlaggedForRemoval.push(t),t}onStop(e){const t=super.onStop(e);return this.isRunning&&this.onStopCbsFlaggedForRemoval.push(t),t}stop(){this.traverseSceneComponents((t=>{for(let i in t.interface)t[i]instanceof e.Audio&&t[i].source&&t[i].stop()})),o.emit("stop"),this.isRunning&&this.removeUIContainer(),super.stop();const t=document.getElementById("rogue-canvas");t&&(t.style.display="none"),this.onPlayCbsFlaggedForRemoval.forEach((e=>{e.stop()})),this.onStopCbsFlaggedForRemoval.forEach((e=>{e.stop()})),this.onPlayCbsFlaggedForRemoval=[],this.onStopCbsFlaggedForRemoval=[]}createUIContainer(){if(!document.getElementById("rogue-ui")){const e=document.getElementById("rogue-app"),t=document.createElement("div");t.id="rogue-ui",t.style.position="absolute",t.style.width="100%",t.style.height="100%",t.style.overflow="hidden",e.insertBefore(t,e.firstChild),this.uiContainer=t}}removeUIContainer(){const e=document.getElementById("rogue-ui");e&&e.remove()}afterUpdate(){super.afterUpdate()}traverseSceneComponents(e){for(let t in C){const i=C[t];for(let t in i){const n=i[t];n.enabled&&e(n)}}}beginUpdateCycle(){this.isRunning&&this._rogueDOMContainer&&(this.camera&&App.activeCamera===this.camera.uuid||(this.camera=App.currentScene.getObjectByProperty("uuid",App.activeCamera),this.adjustCameraAndRenderer(!0)),super.beginUpdateCycle())}}const m=new RuntimeController;class Sky extends e.Mesh{constructor(){const t=Sky.SkyShader,i=new e.ShaderMaterial({name:"SkyShader",fragmentShader:t.fragmentShader,vertexShader:t.vertexShader,uniforms:e.UniformsUtils.clone(t.uniforms),side:e.BackSide,depthWrite:!1});super(new e.BoxGeometry(1,1,1),i),this.isSky=!0}}Sky.SkyShader={uniforms:{luminance:{value:1},turbidity:{value:2},rayleigh:{value:1},mieCoefficient:{value:.005},mieDirectionalG:{value:.8},sunPosition:{value:new e.Vector3},up:{value:new e.Vector3(0,1,0)}},vertexShader:["uniform vec3 sunPosition;","uniform float rayleigh;","uniform float turbidity;","uniform float mieCoefficient;","uniform vec3 up;","varying vec3 vWorldPosition;","varying vec3 vSunDirection;","varying float vSunfade;","varying vec3 vBetaR;","varying vec3 vBetaM;","varying float vSunE;","const float e = 2.71828182845904523536028747135266249775724709369995957;","const float pi = 3.141592653589793238462643383279502884197169;","const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );","const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );","const float v = 4.0;","const vec3 K = vec3( 0.686, 0.678, 0.666 );","const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );","const float cutoffAngle = 1.6110731556870734;","const float steepness = 1.5;","const float EE = 1000.0;","float sunIntensity( float zenithAngleCos ) {","\tzenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );","\treturn EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );","}","vec3 totalMie( float T ) {","\tfloat c = ( 0.2 * T ) * 10E-18;","\treturn 0.434 * c * MieConst;","}","void main() {","\tvec4 worldPosition = vec4( position, 1.0 );","\tvWorldPosition = worldPosition.xyz;","\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );"," gl_Position.z = gl_Position.w;","\tvSunDirection = normalize( sunPosition );","\tvSunE = sunIntensity( dot( vSunDirection, up ) );","\tvSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );","\tfloat rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );","\tvBetaR = totalRayleigh * rayleighCoefficient;","\tvBetaM = totalMie( turbidity ) * mieCoefficient;","}"].join("\n"),fragmentShader:["varying vec3 vWorldPosition;","varying vec3 vSunDirection;","varying float vSunfade;","varying vec3 vBetaR;","varying vec3 vBetaM;","varying float vSunE;","uniform float luminance;","uniform float mieDirectionalG;","uniform vec3 up;","const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );","const float pi = 3.141592653589793238462643383279502884197169;","const float n = 1.0003;","const float N = 2.545E25;","const float rayleighZenithLength = 8.4E3;","const float mieZenithLength = 1.25E3;","const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;","const float THREE_OVER_SIXTEENPI = 0.05968310365946075;","const float ONE_OVER_FOURPI = 0.07957747154594767;","float rayleighPhase( float cosTheta ) {","\treturn THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );","}","float hgPhase( float cosTheta, float g ) {","\tfloat g2 = pow( g, 2.0 );","\tfloat inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );","\treturn ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );","}","const float A = 0.15;","const float B = 0.50;","const float C = 0.10;","const float D = 0.20;","const float E = 0.02;","const float F = 0.30;","const float whiteScale = 1.0748724675633854;","vec3 Uncharted2Tonemap( vec3 x ) {","\treturn ( ( x * ( A * x + C * B ) + D * E ) / ( x * ( A * x + B ) + D * F ) ) - E / F;","}","void main() {"," vec3 direction = normalize( vWorldPosition - cameraPos );","\tfloat zenithAngle = acos( max( 0.0, dot( up, direction ) ) );","\tfloat inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );","\tfloat sR = rayleighZenithLength * inverse;","\tfloat sM = mieZenithLength * inverse;","\tvec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );","\tfloat cosTheta = dot( direction, vSunDirection );","\tfloat rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );","\tvec3 betaRTheta = vBetaR * rPhase;","\tfloat mPhase = hgPhase( cosTheta, mieDirectionalG );","\tvec3 betaMTheta = vBetaM * mPhase;","\tvec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );","\tLin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );","\tfloat theta = acos( direction.y ); // elevation --\x3e y-axis, [-pi/2, pi/2]","\tfloat phi = atan( direction.z, direction.x ); // azimuth --\x3e x-axis [-pi/2, pi/2]","\tvec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );","\tvec3 L0 = vec3( 0.1 ) * Fex;","\tfloat sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );","\tL0 += ( vSunE * 19000.0 * Fex ) * sundisk;","\tvec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );","\tvec3 curr = Uncharted2Tonemap( ( log2( 2.0 / pow( luminance, 4.0 ) ) ) * texColor );","\tvec3 color = curr * whiteScale;","\tvec3 retColor = pow( color, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );","\tgl_FragColor = vec4( retColor, 1.0 );","}"].join("\n")};let g=new class SkyboxClass{constructor(){this._enabled=!0,this._mode="procedural",this._showSun=!1,this._inclination=.464,this._azimuth=.25,this._layers=1,this.sunSpeed=0}get layers(){return this._layers}set layers(e){this._layers=e,this._sky&&(this._sky.layers.mask=e),this._cubemapSky&&(this._cubemapSky.layers.mask=e)}get sky(){return this._sky}get cubemapSky(){return this._cubemapSky}get enabled(){return this._enabled}set enabled(e){this._enabled=e,this.init(this.toJSON())}get mode(){return this._mode}set mode(e){this._mode=e,this.init(this.toJSON())}get cubemapTop(){return this._cubemapTop}set cubemapTop(e){this._cubemapTop=e,"cubemap"===this.mode&&this.init(this.toJSON())}get cubemapBottom(){return this._cubemapBottom}set cubemapBottom(e){this._cubemapBottom=e,"cubemap"===this.mode&&this.init(this.toJSON())}get cubemapFront(){return this._cubemapFront}set cubemapFront(e){this._cubemapFront=e,"cubemap"===this.mode&&this.init(this.toJSON())}get cubemapBack(){return this._cubemapBack}set cubemapBack(e){this._cubemapBack=e,"cubemap"===this.mode&&this.init(this.toJSON())}get cubemapRight(){return this._cubemapRight}set cubemapRight(e){this._cubemapRight=e,"cubemap"===this.mode&&this.init(this.toJSON())}get cubemapLeft(){return this._cubemapLeft}set cubemapLeft(e){this._cubemapLeft=e,"cubemap"===this.mode&&this.init(this.toJSON())}get mieDirectionalG(){return"procedural"===this.mode&&this._sky?this._sky.material.uniforms.mieDirectionalG.value:0}set mieDirectionalG(e){this._sky&&"procedural"===this.mode&&(this._sky.material.uniforms.mieDirectionalG.value=e)}get mieCoefficient(){return"procedural"===this.mode&&this._sky?this._sky.material.uniforms.mieCoefficient.value:0}set mieCoefficient(e){this._sky&&"procedural"===this.mode&&(this._sky.material.uniforms.mieCoefficient.value=e)}get turbidity(){return"procedural"===this.mode&&this._sky?this._sky.material.uniforms.turbidity.value:0}set turbidity(e){this._sky&&"procedural"===this.mode&&(this._sky.material.uniforms.turbidity.value=e)}get rayleigh(){return"procedural"===this.mode&&this._sky?this._sky.material.uniforms.rayleigh.value:0}set rayleigh(e){this._sky&&"procedural"===this.mode&&(this._sky.material.uniforms.rayleigh.value=e)}get luminance(){return"procedural"===this.mode&&this._sky?this._sky.material.uniforms.luminance.value:0}set luminance(e){this._sky&&"procedural"===this.mode&&(this._sky.material.uniforms.luminance.value=e)}get inclination(){return this._inclination}set inclination(e){this._inclination=e,"procedural"===this.mode&&this.setSunPosition()}get azimuth(){return this._azimuth}set azimuth(e){this._azimuth=e,"procedural"===this.mode&&this.setSunPosition()}get showSun(){return this._showSun}set showSun(e){this._showSun=e,"procedural"===this.mode&&this._sunSphere&&(this._sunSphere.visible=e)}init(e){if(this._onPlay&&this._onPlay.stop(),this._onStop&&this._onStop.stop(),this._onUpdate&&this._onUpdate.stop(),e&&(this._enabled=e._enabled),this._sky&&this._sky.parent&&this._sky.parent.remove(this._sky),this._cubemapSky&&this._cubemapSky.parent&&this._cubemapSky.parent.remove(this._cubemapSky),!this.enabled||e&&!e._enabled)return;let t=e&&Object.keys(e).length>=1?e._mode:this.mode;"procedural"===t&&this.initProceduralSkybox(e),"cubemap"===t&&this.initCubemapSkybox(e)}initProceduralSkybox(t){this._sky=new Sky,this._sky.name="ROGUE_INTERNAL_SKYBOX",this._sky.scale.setScalar(100),this._sky.renderOrder=-999,this._sky.userData.isEditorObject=!0,this._sunSphere=new e.Mesh(new e.SphereBufferGeometry(3,20,8),new e.MeshStandardMaterial({color:"#000",emissive:"#fff",depthTest:!1,depthWrite:!1})),this._sunSphere.renderOrder=-100,this._sunSphere.position.y=-100,this._sunSphere.visible=this.showSun,this._sunSphere.name="Sun",this._sky.add(this._sunSphere),t&&Object.keys(t).length>=1?this.fromJSON(t):this.fromJSON(this.getDefaultJSON()),App.currentScene.add(this._sky),window.ROGUE_ISDEV&&(this._onPlay=m.onPlay((()=>{this._directionalLight=void 0})),this._onStop=m.onStop((()=>{this._directionalLight=void 0}))),this._onUpdate=onBeforeUpdate((e=>{this._enabled&&(e.renderer.xr.enabled?e.renderer.xr.getCamera().getWorldPosition(this._sky.position):e.camera.getWorldPosition(this._sky.position),this._directionalLight||this.setSunPosition(),App.sceneController instanceof RuntimeController&&(this.inclination<=-1&&(this.inclination=1),this.inclination>1&&(this.inclination=-1),this.inclination-=this.sunSpeed))}))}initCubemapSkybox(t){t&&Object.keys(t).length>=1?this.fromJSON(t):this.fromJSON(this.getDefaultJSON());let i=new e.MeshLambertMaterial({emissive:this.cubemapRight?"#fff":"#000",color:"#000",emissiveMap:this.cubemapRight}),n=new e.MeshLambertMaterial({emissive:this.cubemapLeft?"#fff":"#000",color:"#000",emissiveMap:this.cubemapLeft}),s=new e.MeshLambertMaterial({emissive:this.cubemapTop?"#fff":"#000",color:"#000",emissiveMap:this.cubemapTop}),o=new e.MeshLambertMaterial({emissive:this.cubemapBottom?"#fff":"#000",color:"#000",emissiveMap:this.cubemapBottom}),r=new e.MeshLambertMaterial({emissive:this.cubemapFront?"#fff":"#000",color:"#000",emissiveMap:this.cubemapFront}),a=new e.MeshLambertMaterial({emissive:this.cubemapBack?"#fff":"#000",color:"#000",emissiveMap:this.cubemapBack});i.side=e.BackSide,i.depthWrite=!1,i.depthTest=!1,n.side=e.BackSide,n.depthWrite=!1,n.depthTest=!1,s.side=e.BackSide,s.depthWrite=!1,s.depthTest=!1,o.side=e.BackSide,o.depthWrite=!1,o.depthTest=!1,r.side=e.BackSide,r.depthWrite=!1,r.depthTest=!1,a.side=e.BackSide,a.depthWrite=!1,a.depthTest=!1,this._cubemapSky=new e.Mesh(new e.BoxBufferGeometry(100,100,100),[i,n,s,o,r,a]),this._cubemapSky.renderOrder=-999,this._cubemapSky.name="ROGUE_INTERNAL_SKYBOX",this._cubemapSky.userData.isEditorObject=!0,App.currentScene.add(this._cubemapSky),window.ROGUE_ISDEV&&(this._onPlay=m.onPlay((()=>{})),this._onStop=m.onStop((()=>{}))),this._onUpdate=onBeforeUpdate((e=>{this._enabled&&(e.renderer.xr.enabled?e.renderer.xr.getCamera().getWorldPosition(this._cubemapSky.position):e.camera.getWorldPosition(this._cubemapSky.position))}))}toJSON(){return{_enabled:this._enabled,_mode:this._mode,layers:this._layers,_showSun:this._showSun,inclination:this._inclination,azimuth:this._azimuth,mieDirectionalG:this.mieDirectionalG,mieCoefficient:this.mieCoefficient,turbidity:this.turbidity,rayleigh:this.rayleigh,luminance:this.luminance,_sunSpeed:this.sunSpeed,_cubemapTop:this.cubemapTop instanceof e.Texture&&this.cubemapTop.toJSON(),_cubemapBottom:this.cubemapBottom instanceof e.Texture&&this.cubemapBottom.toJSON(),_cubemapFront:this.cubemapFront instanceof e.Texture&&this.cubemapFront.toJSON(),_cubemapBack:this.cubemapBack instanceof e.Texture&&this.cubemapBack.toJSON(),_cubemapRight:this.cubemapRight instanceof e.Texture&&this.cubemapRight.toJSON(),_cubemapLeft:this.cubemapLeft instanceof e.Texture&&this.cubemapLeft.toJSON()}}fromJSON(e){void 0===e._enabled&&(e._enabled=!0);for(let t in e){let i=e[t];if("object"===typeof i){const n=j.getAsset(i.uuid);n?this[t]=n:j.loadAsset(i.uuid).then((i=>{this[t]=i,"cubemap"===this.mode&&this.init(e)}))}else this[t]=e[t]}}initWithDefaultValues(){this._mode="procedural",this.inclination=.464,this.azimuth=.25,this.mieDirectionalG=.998,this.mieCoefficient=.004,this.turbidity=10,this.rayleigh=1.423,this.luminance=1,this._showSun=!1}getDefaultJSON(){return{_enabled:!0,_mode:"procedural",layers:1,_showSun:!1,inclination:.464,azimuth:.25,mieDirectionalG:.998,mieCoefficient:.004,turbidity:10,rayleigh:1.423,luminance:1,_sunSpeed:0,_cubemapTop:void 0,_cubemapBottom:void 0,_cubemapFront:void 0,_cubemapBack:void 0,_cubemapRight:void 0,_cubemapLeft:void 0}}setSunPosition(){var e=Math.PI*(this.inclination-.5),t=2*Math.PI*(this.azimuth-.5);this._sunSphere&&(this._sunSphere.position.x=90*Math.cos(t),this._sunSphere.position.y=90*Math.sin(t)*Math.sin(e),this._sunSphere.position.z=90*Math.sin(t)*Math.cos(e),this._sky.material.uniforms.sunPosition.value.copy(this._sunSphere.position),this._directionalLight?this._directionalLight.position.set(this._sunSphere.position.x,this._sunSphere.position.y,this._sunSphere.position.z):(this._directionalLight=App.currentScene.getObjectByName("SUNLIGHT"),this._directionalLight&&this._directionalLight.position.set(this._sunSphere.position.x,this._sunSphere.position.y,this._sunSphere.position.z)))}};class GamepadController{get gamepad(){return this._gamepad}constructor(e){this._upButtons={},this._downButtons={},this._pressedButtons={},this.deadZone=.1,this._gamepad=e,this.update()}update(){onNextFrame((()=>{this._gamepad.buttons[0].pressed,this._gamepad.buttons.forEach(((e,t)=>{e.pressed&&!this._pressedButtons[t]&&(this._downButtons[t]=!0,this._pressedButtons[t]=!0,onNextFrame((()=>this._downButtons[t]=!1))),!e.pressed&&this._pressedButtons[t]&&(this._pressedButtons[t]=!1,this._upButtons[t]=!0,onNextFrame((()=>this._upButtons[t]=!1)))})),this.update()}))}getAxis(e){const t=this._gamepad.axes[e];if(this.deadZone>0&&Math.abs(t)>0){const i=this._gamepad.axes[e%2===0?e+1:e-1];return Math.abs(i)>this.deadZone||Math.abs(t)>this.deadZone?t:0}return t}getButton(e){var t;return(null===(t=this._gamepad.buttons[e])||void 0===t?void 0:t.value)||0}getButtonDown(e){return this._downButtons[e]||!1}getButtonUp(e){return this._upButtons[e]||!1}}window.addEventListener("gamepadconnected",(e=>{const t=new GamepadController(e.gamepad);Input.gamepads.push(t)})),window.addEventListener("gamepaddisconnected",(e=>{Input.gamepads.splice(e.gamepad.index,1)})),onUpdate((e=>{if(!(e instanceof RuntimeController))return;const t=navigator.getGamepads?navigator.getGamepads():[];if(t)for(let i=0;i<t.length;i++){const e=t[i];if(!e)return;const n=Input.gamepads[i];if(!n)return;n._gamepad=e}}));class Input{static get mouse(){return this._mouse}static get keyboard(){return this._keyboard}static get touch(){return this._touch}static get gamepads(){return this._gamepads}}Input._mouse=new class Mouse{constructor(){this._x=0,this._y=0,this._movementX=0,this._movementY=0,this._isMoving=!1,this._isLeftButtonDown=!1,this._isLeftButtonPressed=!1,this._isLeftButtonUp=!1,this._isRightButtonDown=!1,this._isRightButtonPressed=!1,this._isRightButtonUp=!1,this._isMidButtonDown=!1,this._isMidButtonPressed=!1,this._isMidButtonUp=!1,this._wheelY=0,this._wheelX=0,this._enabled=!0,this.unlockFunction=e=>{"Escape"===e.code&&this.unlock()}}get pointerLock(){return this._pointerLock}get x(){return this._x}get y(){return this._y}get movementX(){return this._movementX}get movementY(){return this._movementY}get isMoving(){return this._isMoving}get isLeftButtonDown(){return this._isLeftButtonDown}get isLeftButtonPressed(){return this._isLeftButtonPressed}get isLeftButtonUp(){return this._isLeftButtonUp}get isRightButtonDown(){return this._isRightButtonDown}get isRightButtonPressed(){return this._isRightButtonPressed}get isRightButtonUp(){return this._isRightButtonUp}get isMidButtonDown(){return this._isMidButtonDown}get isMidButtonPressed(){return this._isMidButtonPressed}get isMidButtonUp(){return this._isMidButtonUp}get buttonDown(){return this._buttonDown}get buttonPressed(){return this._buttonPressed}get buttonUp(){return this._buttonUp}get wheelY(){return this._wheelY}get wheelX(){return this._wheelX}get enabled(){return this._enabled}set enabled(e){this._enabled=e}init(){document.addEventListener("mousemove",this.onMouseMove.bind(this),!1);const e=document.getElementById("rogue-app");e&&(e.addEventListener("mousedown",this.onMouseDown.bind(this)),e.addEventListener("mouseup",this.onMouseUp.bind(this)),e.addEventListener("wheel",this.onWheelMove.bind(this)))}getButtonDown(e){return this._buttonDown===e}getButtonPressed(e){return this._buttonPressed===e}getButtonUp(e){return this._buttonUp===e}lock(){const e=document.getElementById("rogue-app");e&&(e&&e.requestPointerLock(),document.removeEventListener("keyup",this.unlockFunction),document.addEventListener("keyup",this.unlockFunction))}unlock(){document.exitPointerLock()}onMouseMove(e){onNextFrame(this.setMouseMovement.bind(this,e))}setMouseMovement(e){this._x=e.clientX,this._y=e.clientY,this._movementX=e.movementX,this._movementY=e.movementY,this._isMoving=!0,onNextFrame(this.resetMouseMovement.bind(this))}resetMouseMovement(){this._movementX=0,this._movementY=0,this._isMoving=!1}onMouseDown(e){!1!==this._enabled&&onNextFrame((()=>{0===e.button?(this._isLeftButtonDown=!0,this._isLeftButtonPressed=!0):2===e.button?(this._isRightButtonDown=!0,this._isRightButtonPressed=!0):1===e.button&&(this._isMidButtonDown=!0,this._isMidButtonPressed=!0),this._buttonDown=e.button,this._buttonPressed=e.button,onNextFrame((()=>{0===e.button?this._isLeftButtonDown=!1:2===e.button?this._isRightButtonDown=!1:1===e.button&&(this._isMidButtonDown=!1),this._buttonDown=void 0}))}))}onMouseUp(e){!1!==this._enabled&&onNextFrame((()=>{0===e.button?(this._isLeftButtonUp=!0,this._isLeftButtonPressed=!1):2===e.button?(this._isRightButtonUp=!0,this._isRightButtonPressed=!1):1===e.button&&(this._isMidButtonUp=!0,this._isMidButtonPressed=!1),this.getButtonPressed(e.button)&&(this._buttonUp=e.button,this._buttonPressed=void 0),onNextFrame((()=>{0===e.button?this._isLeftButtonUp=!1:2===e.button?this._isRightButtonUp=!1:1===e.button&&(this._isMidButtonUp=!1),this._buttonUp=void 0}).bind(this))}).bind(this))}onWheelMove(e){!1!==this._enabled&&(e.preventDefault(),clearTimeout(this._wheelTimeout),this._wheelY=e.deltaY,this._wheelX=e.deltaX,this._wheelTimeout=setTimeout((()=>{this._wheelY=0,this._wheelX=0}),250))}},Input._keyboard=new class Keyboard{constructor(){this._upKeys={},this._downKeys={},this._pressedKeys={}}init(){document.addEventListener("keydown",(e=>{this._pressedKeys[e.code]||onNextFrame((()=>{this._downKeys[e.code]=!0,this._pressedKeys[e.code]=!0,onNextFrame((()=>{this._downKeys[e.code]=!1}))}))})),document.addEventListener("keyup",(e=>{onNextFrame((()=>{this._upKeys[e.code]=!0,this._pressedKeys[e.code]=!1,onNextFrame((()=>{this._upKeys[e.code]=!1}))}))}))}getKeyDown(e){return this._downKeys[e]}getKeyPressed(e){return this._pressedKeys[e]}getKeyUp(e){return this._upKeys[e]}},Input._touch=new class TouchController{constructor(){this._startTouches=[],this._endTouches=[],this._touches=[],this._enabled=!0}get startTouches(){return this._startTouches}get endTouches(){return this._endTouches}get touches(){return this._touches}get enabled(){return this._enabled}set enabled(e){this._enabled=e}init(){this._touches.splice(0),this._endTouches.splice(0),this._startTouches.splice(0),this._enabled=!0;const e=document.getElementById("rogue-app");e&&(e.ontouchmove=this.onTouchMove.bind(this),e.ontouchstart=this.onTouchStart.bind(this),e.ontouchend=this.onTouchEnd.bind(this))}onTouchStart(e){e.preventDefault(),onNextFrame((()=>{for(let t=0;t<e.changedTouches.length;t++){const i=e.changedTouches[t],n=this.setTouchValues({},i);this._touches.push(Object.assign({},n)),this._startTouches.push(Object.assign({},n))}onNextFrame((()=>{for(let t=0;t<e.changedTouches.length;t++){const i=e.changedTouches[t],n=this.getCurrentTouchIndexById(i.identifier,this._startTouches);this._startTouches.splice(n,1)}}))}))}onTouchEnd(e){e.preventDefault(),onNextFrame((()=>{for(let t=0;t<e.changedTouches.length;t++){const i=e.changedTouches[t],n=this.getCurrentTouchIndexById(i.identifier,this._touches),s=this._touches[n];this._endTouches.push(Object.assign({},s)),this._touches.splice(n,1)}onNextFrame((()=>{for(let t=0;t<e.changedTouches.length;t++){const i=e.changedTouches[t],n=this.getCurrentTouchIndexById(i.identifier,this._endTouches);this._endTouches.splice(n,1)}}))}))}onTouchMove(e){e.preventDefault(),onNextFrame((()=>{for(let t=0;t<e.changedTouches.length;t++){const i=e.changedTouches[t],n=this.getCurrentTouchIndexById(i.identifier,this._touches);n>=0&&this.setTouchValues(this._touches[n],i)}onNextFrame((()=>{for(const e of this._touches)e.deltaX=0,e.deltaY=0}))}))}getCurrentTouchIndexById(e,t){for(let i=0;i<t.length;i++){if(t[i].id==e)return i}return-1}setTouchValues(e,t){const i=void 0!==e.x?e.x:0,n=void 0!==e.y?e.y:0;return e.id=void 0!==e.id?e.id:t.identifier,e.deltaX=void 0!==e.x?t.clientX-i:0,e.deltaY=void 0!==e.x?t.clientY-n:0,e.x=t.clientX,e.y=t.clientY,e.touch=t,e}},Input._gamepads=[];class App{constructor(){}static get activeCamera(){return this._activeCamera}static set activeCamera(e){this._activeCamera=e}static get settings(){return this._settings}static get title(){return this._title}static set title(e){this._title=e}static get currentScene(){return this._currentScene}static set currentScene(e){this._currentScene=e}static get scenes(){return this._scenes}static get sceneController(){return this._sceneController}static set sceneController(e){this._sceneController=e}static get lanIP(){return this._lanIP}static toJSON(e){return{title:this._title,scenes:this._scenes,lanIP:this.lanIP,assetPaths:Object.assign({},e)}}static fromJSON(e){this._title=e.title,this._scenes=e.scenes,e.lanIP&&(this._lanIP=e.lanIP)}static play(e){this._title=e.title,this._scenes=e.scenes,j.setAssetPaths(e.assetPaths),Input.mouse.init(),Input.keyboard.init(),Input.touch.init(),this.loadScene(this._scenes[0].name)}static loadScene(e){return m.stop(),dispose(this._currentScene),new Promise((t=>{this.loadSceneFunc(e).then((()=>{t()}))}))}static loadSceneFunc(t){return __awaiter(this,void 0,void 0,(function*(){let i;if("string"===typeof t?i=this._scenes.find((e=>e.name===t)):"number"===typeof t&&(i=this._scenes[t]),!i)return;let n=window.re_prefix;const s="AppData/"+i.uuid+".rogueScene",o=n?n+s:s;let r=yield fetch(window.ROGUE_ISDEV?j.getAssetPath(i.uuid):o),a=yield r.json();m.startRenderer(),App.sceneController=m,j.sceneController=m,App.activeCamera=a.initialCameraId,j.loadAssetConfigs(a.assetConfigs),yield j.preloadAssets(),this._currentScene=(new e.ObjectLoader).parse(a.scene),this.loadAudioListeners(this._currentScene),a.skybox&&g.init(a.skybox),m.play(this._currentScene,m.renderer,a.components)}))}static clone(t,i){if(!t)throw new Error("App.clone(...) => The object you are trying to clone does not seem to exist.");if(!(t instanceof e.Object3D))throw new Error("App.clone(...) => The object you are trying to clone is unavailable, try fetching the asset first. object.uuid: "+t.uuid);const n=t.animations;let s=t.clone();s.animations=n,i?(i.attach(s),s.position.set(0,0,0)):this.currentScene.add(s),this.loadAudioListeners(s),this.loadComponentsRecursive(s);let o=getObjectComponents(s);return m.isRunning&&o.forEach((e=>{e.awake()})),m.isRunning&&s.traverse((e=>{getObjectComponents(e).forEach((e=>{e.awake()}))})),s}static loadComponentsRecursive(e){const t=e.userData&&e.userData.components;(()=>{__awaiter(this,void 0,void 0,(function*(){t&&loadComponents(e,t),e.userData&&delete e.userData.components}))})();for(let i in e.children)this.loadComponentsRecursive(e.children[i])}static loadAudioListeners(t){const i=[];t.traverse((t=>{t instanceof e.AudioListener||!t.userData.__AUDIOLISTENER__||i.push(t)})),i.forEach((t=>{const i=new e.AudioListener;i.name=t.name,i.userData.__AUDIOLISTENER__=!0,i.position.copy(t.position),i.rotation.copy(t.rotation);const n=t.uuid;t.parent&&t.parent.add(i),t.parent&&t.parent.remove(t),i.uuid=n}))}}App._title="Project",App._scenes=[],App._sceneController=m,App._lanIP="localhost";window.buffer;var _=__webpack_require__(1171),b=__webpack_require__.n(_);class AudioAsset{constructor(t){this._uuid=t.uuid;const i=e.AudioContext.getContext().createBuffer(1,1,8e3);this._buffer=t.buffer||i,this.userData={__ASSET__:this._uuid}}get uuid(){return this._uuid}get path(){return j.getAssetPath(this._uuid)||""}get name(){return this.path.substring(this.path.lastIndexOf("/")+1,this.path.lastIndexOf("."))}getAudio(){const t=App.currentScene.getObjectByProperty("type","AudioListener")||new e.AudioListener,i=new e.Audio(t);return i.setBuffer(this._buffer),i.name=this.name,i.userData.__ASSET__=this.uuid,i}getPositionalAudio(){const t=App.currentScene.getObjectByProperty("type","AudioListener")||new e.AudioListener,i=new e.PositionalAudio(t);return i.setBuffer(this._buffer),i.name=this.name,i.userData.__ASSET__=this.uuid,i}static fromFile(t,i=(()=>{}),n=(()=>{})){return __awaiter(this,void 0,void 0,(function*(){let s=yield fetch(t+".meta"),o=yield s.json();return new Promise((s=>{let r=new e.AudioLoader;r.setCrossOrigin("anonymous"),r.load(t,(e=>{const t=new AudioAsset({uuid:o.uuid,buffer:e});s(t)}),i,n)}))}))}}class Prefab{constructor(e){this._uuid=e}get uuid(){return this._uuid}get path(){return j.getAssetPath(this._uuid)||""}get name(){return this.path.substring(this.path.lastIndexOf("/")+1,this.path.lastIndexOf("."))}instantiate(t){let i=j.getAsset(this._uuid).clone();t?(t.attach(i),i.position.set(0,0,0)):App.currentScene.attach(i),i.traverse((e=>{let t=e.userData.__NESTED__;onNextFrame((()=>{t&&t.forEach((t=>{t.uuid!==i.userData.__ASSET__&&onNextFrame((()=>__awaiter(this,void 0,void 0,(function*(){if(!(yield j.loadAsset(t.uuid)))return;const i=t.parent===e.userData.__REF__?e:e.getObjectByProperty("uuid",t.parent),n=new Prefab(t.uuid).instantiate(i);t.position&&n.position.fromArray(t.position),t.rotation&&n.rotation.fromArray(t.rotation),t.scale&&n.scale.fromArray(t.scale)}))))}))})),t&&(e.userData.__NESTED__=void 0)})),function loadAudioListeners(t){const i=[];t.traverse((t=>{t instanceof e.AudioListener||!t.userData.__AUDIOLISTENER__||i.push(t)})),i.forEach((t=>{const i=new e.AudioListener;i.name=t.name,i.userData.__AUDIOLISTENER__=!0,i.position.copy(t.position),i.rotation.copy(t.rotation);const n=t.uuid;t.parent&&t.parent.add(i),t.parent&&t.parent.remove(t),i.uuid=n}))}(i),loadComponentsRecursive(i);let n=getObjectComponents(i);return m.isRunning&&n.forEach((e=>{e.awake()})),m.isRunning&&i.traverse((e=>{getObjectComponents(e).forEach((e=>{e.awake()}))})),i}}function getParentPrefab(e){return e.userData.__ASSET__?e:e.parent?getParentPrefab(e.parent):void 0}const v=new e.AnimationClip("",0,[]);class Component extends Lifecycle{constructor(e,t){super(),this._name="component",this._isReady=!0,this._enabled=!0,this.interface={},this.uuid=b()(),this._object3d=t,this._name=e}get name(){return this._name}set name(e){this._name=e}get object3d(){return this._object3d}get isReady(){return this._isReady}get enabled(){return this._enabled}set enabled(e){this._enabled=e,e?(isActive(this.object3d)&&this.awake(),this.__STARTED__=!1):isActive(this.object3d)&&this.onDisabled()}toJSON(){return{uuid:this.uuid,name:this.name,componentPrototypeName:this.constructor.name,interface:this.constructor.interface||{},interfaceRefs:this.serializeInterfaceRefs(),enabled:this._enabled}}fromJSON(e){this._isReady=!1,this.uuid=e.uuid||this.uuid,this.name=e.name,this.interface=e.interface||{},this.loadInterfaceRefs(e.interfaceRefs),this._enabled="boolean"!==typeof e.enabled||e.enabled}serializePropRef(t,i,n,s){switch(s){case"Data":case"String":case"Number":case"Boolean":case"Select":case"Code":t[i]=n[i];break;case"Color":if(n[i]instanceof e.Color){const e=n[i];t[i]=e.getHex()}break;case"Vector2":if(n[i]instanceof e.Vector2){const e=n[i];t[i]=e.toArray()}break;case"Vector3":if(n[i]instanceof e.Vector3){const e=n[i];t[i]=e.toArray()}break;case"Texture":if(n[i]instanceof e.Texture){const e=n[i];t[i]=e.uuid}break;case"Material":if(n[i]instanceof e.Material){const e=n[i];t[i]=e.uuid}break;case"Object3D":if(n[i]instanceof e.Object3D){const e=n[i];t[i]=e.uuid}break;case"Prefab":if(n[i]instanceof Prefab){const e=n[i];t[i]=e.uuid}break;case"AnimationClip":if(n[i]instanceof e.AnimationClip){const e=n[i];t[i]=e.uuid}break;case"PositionalAudio":case"Audio":if(n[i]instanceof AudioAsset){const e=n[i].userData.__ASSET__;t[i]=e}}}serializeInterfaceRefs(){if(!this.constructor.interface)return{};let e={};for(let t in this.constructor.interface){let i=this.constructor.interface[t];if(Array.isArray(i)){const n=this[t];Array.isArray(n)||(this[t]=[]);const s=[],o=i[0];let r="string"===typeof o?o:o.type;if("Button"===r)continue;n.forEach(((e,t)=>{this.serializePropRef(s,t,n,r)})),e[t]=s}else{let n="string"===typeof i?i:i.type;if("Button"===n)continue;this.serializePropRef(e,t,this,n)}}return e}loadInterfaceRefs(e){if(!e||0===Object.keys(e).length)return void(this._isReady=!0);const t={},subscribeProp=i=>{const n=e[i];Array.isArray(n)?(t[i]=[],n.forEach(((e,n)=>{t[i][n]=!1}))):t[i]=!1};for(let i in this.interface)subscribeProp(i);0===Object.keys(this.interface).length&&(this._isReady=!0);for(let i in this.interface){const n=this.interface[i];if(Array.isArray(n)){this[i]=[];const s=n[0];let o="string"===typeof s?s:s.type;Array.isArray(e[i])||(e[i]=[]);const r=e[i];r.forEach(((e,n)=>{this.loadPropRef(r,n,this[i],t,o,i)})),0===r.length&&this.readyNotifier(t,i)}else{let s="string"===typeof n?n:n.type;this.loadPropRef(e,i,this,t,s)}}}readyNotifier(e,t,i){i?e[i][t]=!0:e[t]=!0;for(const n in e){const t=e[n];if(!1===t)return!1;if(Array.isArray(t))for(let e=0;e<t.length;e++)if(!1===t[e])return!1}return this._isReady=!0,!0}loadPropRef(t,i,n,s,o,r){switch(o){case"Button":this.readyNotifier(s,i,r);break;case"Data":case"String":case"Number":case"Boolean":case"Select":case"Code":n[i]=t[i],this.readyNotifier(s,i,r);break;case"Color":n[i]=new e.Color(t[i]),this.readyNotifier(s,i,r);break;case"Vector2":if(!t[i]){this.readyNotifier(s,i,r);break}n[i]=new e.Vector2(...t[i]),this.readyNotifier(s,i,r);break;case"Vector3":if(!t[i]){this.readyNotifier(s,i,r);break}n[i]=new e.Vector3(...t[i]),this.readyNotifier(s,i,r);break;case"Object3D":if(!t[i]){this.readyNotifier(s,i,r);break}const a=getParentPrefab(this.object3d);let u;a&&a.traverse((e=>{e.userData.__REF__===t[i]&&(u=e)})),u||(u=App.currentScene.getObjectByProperty("uuid",t[i])),n[i]=u,this.readyNotifier(s,i,r);break;case"Prefab":if(!t[i]){this.readyNotifier(s,i,r);break}let c="",h=!1;if(t[i]&&(c=t[i],n[i]=App.currentScene.getObjectByProperty("uuid",t[i])),t[i]&&!n[i]){c=t[i];let e=j.getAsset(c);n[i]=new Prefab(c),!e&&m.isRunning?(h=!0,j.loadAsset(c).then((e=>{this.readyNotifier(s,i,r)}))):this.readyNotifier(s,i,r)}n[i]||!t[i]||h||Debug.logError("Component => object reference could not be found for "+this.constructor.name+"."+i+" in Object3D with uuid: "+c);break;case"AnimationClip":if(!t[i]){this.readyNotifier(s,i,r);break}let d=!1;if(t[i]&&!n[i]){const e=t[i],o=j.getAsset(e);n[i]=v,o?(n[i]=o,this.readyNotifier(s,i,r)):(d=!0,j.loadAsset(e).then((e=>{n[i]=e,this.readyNotifier(s,i,r)})))}break;case"Audio":case"PositionalAudio":if(!t[i]){this.readyNotifier(s,i,r);break}let l="";const setAudio=e=>{const t="Audio"===o?e.getAudio():e.getPositionalAudio();n[i]=t,this.object3d.add(t)};if(t[i]&&!n[i]){l=t[i];let e=j.getAsset(l);if(!m.isRunning){n[i]=new AudioAsset({uuid:l});break}if(!e){j.loadAsset(l).then((e=>{setAudio(e),this.readyNotifier(s,i,r)}));break}e instanceof AudioAsset&&(setAudio(e),this.readyNotifier(s,i,r))}break;case"Texture":if(!t[i]){this.readyNotifier(s,i,r);break}let p=!1;if(t[i]&&!n[i]){const e=t[i],o=j.getAsset(e);o?(n[i]=o,this.readyNotifier(s,i,r)):(p=!0,j.loadAsset(e).then((e=>{n[i]=e,this.readyNotifier(s,i,r)})))}break;case"Material":if(!t[i]){this.readyNotifier(s,i,r);break}let f=!1;if(t[i]&&!n[i]){const e=t[i],o=j.getAsset(e);o?(n[i]=o,this.readyNotifier(s,i,r)):(f=!0,j.loadAsset(e).then((e=>{n[i]=e,this.readyNotifier(s,i,r)})))}}}awake(){}start(){}beforeUpdate(){}update(){}afterUpdate(){}onBeforeRemoved(){}onRemoved(){}onBeforeObjectRemoved(){}onObjectRemoved(){}onDisabled(){}}class Tags{static getTags(){return Object.keys(this.tagsMap)}static getObjects(e){return this.tagsMap[e]||[]}static getWithAll(...e){const t=[];for(let i in this.objectTagsMap){const n=this.objectTagsMap[i];let s,o=!0;for(let t of e){const e=void 0!==n[t];e&&!s&&(s=this.tagsMap[t].find((e=>e.uuid===i))),e||(o=!1)}o&&s&&t.push(s)}return t}static getWithAny(...e){const t=[];for(let i in this.objectTagsMap){const n=this.objectTagsMap[i];let s;for(let t of e){if(void 0!==n[t]&&!s){s=this.tagsMap[t].find((e=>e.uuid===i));break}}s&&t.push(s)}return t}static hasAny(e,...t){const i=this.objectTagsMap[e.uuid]||{};for(let n of t)if(void 0!==i[n])return!0;return!1}static hasAll(e,...t){const i=this.objectTagsMap[e.uuid]||{};for(let n of t)if(void 0===i[n])return!1;return!0}static hasNone(e,...t){const i=this.objectTagsMap[e.uuid]||{};for(let n of t)if(void 0!==i[n])return!1;return!0}static isMissingAll(e,...t){const i=this.objectTagsMap[e.uuid]||{};for(let n of t)if(void 0===i[n])return!0;return!1}static get(e){const t=this.objectTagsMap[e.uuid]||{};return Object.keys(t)}static set(e,...t){t.forEach((t=>{this.tagsMap[t]||this.create(t),this.tagsMap[t].indexOf(e)<0&&this.tagsMap[t].push(e),this.objectTagsMap[e.uuid]||(this.objectTagsMap[e.uuid]={}),this.objectTagsMap[e.uuid][t]=t,Array.isArray(e.userData.rogueTags)||(e.userData.rogueTags=[]),e.userData.rogueTags.indexOf(t)<0&&e.userData.rogueTags.push(t)}))}static remove(e,...t){t.forEach((t=>{const i=this.tagsMap[t],n=i.indexOf(e);if(n>=0&&i.splice(n,1),this.objectTagsMap[e.uuid]&&this.objectTagsMap[e.uuid][t]&&delete this.objectTagsMap[e.uuid][t],Array.isArray(e.userData.rogueTags)){const i=e.userData.rogueTags.indexOf(t);i>=0&&e.userData.rogueTags.splice(i,1)}}))}static create(...e){e.forEach((e=>{Array.isArray(this.tagsMap[e])||(this.tagsMap[e]=[])}))}static delete(...e){e.forEach((e=>{this.tagsMap[e].forEach((t=>{if(delete this.objectTagsMap[t.uuid][e],Array.isArray(t.userData.rogueTags)){const i=t.userData.rogueTags.indexOf(e);i>=0&&t.userData.rogueTags.splice(i,1)}})),delete this.tagsMap[e]}))}static clear(){const e=Object.keys(this.tagsMap);for(let i in e)delete this.tagsMap[i];const t=Object.keys(this.objectTagsMap);for(let i in t)delete this.objectTagsMap[i]}}Tags.tagsMap={},Tags.objectTagsMap={};let y={},A={},C={},w={},E={};class MissingComponent extends Component{constructor(e,t){super(e.name,t),this.missingComponentData=e}toJSON(){return this.missingComponentData}}function getComponentPrototypes(){return y}function clearComponents(){y={};for(let e in E)y[e]=E[e]}function registerComponent(e){if(e.prototype instanceof Component){const t=e.isInternalComponent,i=e.isEditorComponent;if(i||t||(y[e.name]=e),i){const i="Editor_"+e.name,n=getComponentByName(i);window["rogue-editor"].editorRuntime.editorObjectsContainer&&(n&&removeEditorComponent(n),t?(E[e.name]=e,y[e.name]=e):y[e.name]=e,addComponent(new e(i,window["rogue-editor"].editorRuntime.editorObjectsContainer)))}}else Debug.logWarning(e+" is not a Component")}MissingComponent.isMissingComponent=!0;const initComponents=(e,t)=>{C={},t&&(A=t);for(let i in A){const t=A[i];C[i]=[];let n=e.getObjectByProperty("uuid",i);t.forEach(((e,t)=>{e?y[e.componentPrototypeName]?(C[i][t]=new y[e.componentPrototypeName](e.name,n),C[i][t].fromJSON(e)):(C[i][t]=new MissingComponent(e,n),Debug.logError("Component "+e.componentPrototypeName+" does not exist")):Debug.logError("Component does not exist")}))}},initEditorComponents=e=>{if(!App.sceneController.editorObjectsContainer)return;const t={};for(let i in w){const e=w[i];t[i]=[],e.forEach(((e,n)=>{e&&e.onRemoved(),e&&t[i].push(e.toJSON())}))}for(let i in t){const e=t[i];w[i]=[];let n=App.sceneController.editorObjectsContainer.getObjectByProperty("uuid",i);e.forEach(((e,t)=>{e?y[e.componentPrototypeName]?(w[i][t]=new y[e.componentPrototypeName](e.name,n),w[i][t].fromJSON(e)):(w[i][t]=new MissingComponent(e,n),Debug.logError("Component "+e.componentPrototypeName+" does not exist")):Debug.logError("Component does not exist")}))}};function traverseComponents(e){for(let t in C){C[t].forEach(((i,n)=>{e(i,t,n)}))}}const loadComponents=(e,t)=>{let i=e.uuid;C[e.uuid]=[],t.forEach(((t,n)=>{t?y[t.componentPrototypeName]?(C[i][n]=new y[t.componentPrototypeName](t.name,e),C[i][n].fromJSON(t),function componentLoaded(e,t){componentEvensHandler(e,t,c)}(C[i][n],e)):(C[i][n]=new MissingComponent(t,e),Debug.logError("Component "+t.componentPrototypeName+" does not exist")):Debug.logError("Component does not exist")}))},serializeComponents=()=>{A={};for(let e in C){const t=C[e];A[e]=[],t.forEach(((t,i)=>{t&&A[e].push(t.toJSON())}))}return A},addComponent=e=>{var t,i;if(!e.object3d)return;if(e.constructor.isEditorComponent&&(null===(i=null===(t=window["rogue-editor"])||void 0===t?void 0:t.editorRuntime)||void 0===i?void 0:i.editorObjectsContainer)!==e.object3d)throw`Failed adding component ${e.constructor.name}. Editor Components cannot be added to scene objects`;const n=e.object3d;if(n.userData.isEditorObject||e.constructor.isEditorComponent)return w[n.uuid]||(w[n.uuid]=[]),void w[n.uuid].push(e);C[n.uuid]||(C[n.uuid]=[]),C[n.uuid].push(e),function componentAdded(e,t){componentEvensHandler(e,t,u)}(e,n),m.isRunning&&e.awake()};function copyObjectComponents(e,t){const i=getObjectComponents(e);let n=[];i.forEach((e=>{const t=e.toJSON();delete t.uuid,n.push(t)})),n.forEach((e=>{if(e)if(y[e.componentPrototypeName]){const i=new y[e.componentPrototypeName](e.name,t);i.fromJSON(e),addComponent(i)}else Debug.logError("Component "+e.componentPrototypeName+" does not exist");else Debug.logError("Component does not exist")}))}const removeEditorComponent=e=>{const t=e.object3d;return!!t&&(w[t.uuid]?(!m.isRunning&&e.onBeforeRemoved(),w[t.uuid].splice(w[t.uuid].indexOf(e),1),!m.isRunning&&e.onRemoved(),componentRemoved(e,t),!0):void 0)},removeComponent=e=>{const t=e.object3d;return!!t&&(C[t.uuid]?(m.isRunning&&e.onBeforeRemoved(),C[t.uuid].splice(C[t.uuid].indexOf(e),1),m.isRunning&&e.onRemoved(),componentRemoved(e,t),!0):void 0)},removeComponents=(e,t)=>{for(let i in C[e.uuid])removeComponent(C[e.uuid][i]);if(delete C[e.uuid],t)for(let i in e.children){let t=e.children[i];removeComponents(t,!0)}};function getObjectComponentByName(e,t){return C[t]?C[t].find(((t,i,n)=>t.name===e)):w[t]?w[t].find(((t,i,n)=>t.name===e)):void 0}function getComponentByName(e,t){if(t)return getObjectComponentByName(e,t.uuid);for(let i in C){const t=getObjectComponentByName(e,i);if(t)return t}for(let i in w){const t=getObjectComponentByName(e,i);if(t)return t}}const getComponent=(e,t)=>{if(t&&C[t.uuid])return C[t.uuid].find(((t,i,n)=>t instanceof e));if(t&&w[t.uuid])return w[t.uuid].find(((t,i,n)=>t instanceof e));if(!t)for(let i in C){const t=C[i];for(let i=0;i<t.length;i++)if(t[i]instanceof e)return t[i]}},getComponents=e=>{const t=[];for(let i in C){C[i].forEach((i=>{i instanceof e&&t.push(i)}))}return t},getObjectComponents=e=>C[e.uuid]||[],S=e.Object3D.prototype.add,x=e.Object3D.prototype.attach,O=e.Object3D.prototype.remove,k=e.Object3D.prototype.clone;let P=!1;function addObject(t){if(Array.isArray(t.userData.rogueTags)&&Tags.set(t,...t.userData.rogueTags),t.material instanceof e.Material){let i=j.getAsset(t.material.uuid);const n=t.userData.__MATERIAL__;!i&&n&&(i=j.getAsset(n),i instanceof e.Material?t.material=i:!i&&n&&j.loadAsset(n).then((e=>{e?t.material=e:Debug.logWarning(`Material not found. uuid: ${n}`)})))}Array.isArray(t.userData.__MATERIAL__)&&t.userData.__MATERIAL__.forEach(((i,n)=>{if(!i)return;let s=j.getAsset(i);s instanceof e.Material?t.material[n]=s:!s&&i&&j.loadAsset(i).then((e=>{e?t.material[n]=e:Debug.logWarning(`Material not found. uuid: ${i}`)}))}))}e.Object3D.prototype.clone=function(e){P=!0;const t=k.bind(this)(e);return P=!1,t},e.Object3D.prototype.add=function(...e){!this.userData.isEditorObject&&e.forEach((e=>{addObject(e),e.userData.__IS_ADDING__=!0}));const t=S.bind(this)(...e);return!this.userData.isEditorObject&&e.forEach((e=>{e.userData.__IS_ADDING__=!1,P||objectAdded(e,this)})),t},e.Object3D.prototype.attach=function(e){!this.userData.isEditorObject&&addObject(e),e.userData.__IS_ADDING__=!0;const t=x.bind(this)(e);return e.userData.__IS_ADDING__=!1,!this.userData.isEditorObject&&!P&&objectAdded(e,this),t};let removeObjectComponents=(e,t)=>{if(function objectRemoved(e,t){objectEvensHandler(e,t,a)}(e,t),C[e.uuid]){const t=C[e.uuid].slice(0);for(let e in t)removeComponent(t[e]);delete C[e.uuid]}for(let i in e.children){let t=e.children[i];removeObjectComponents(t,e)}};e.Object3D.prototype.remove=function(e){const t=this===e.parent,i=C[e.uuid];t&&!e.userData.__IS_ADDING__&&i&&m.isRunning&&!this.userData.isEditorObject&&i.forEach((e=>{e.onBeforeObjectRemoved()}));const n=O.bind(this)(e);return!t||e.userData.__IS_ADDING__||this.userData.isEditorObject||(m.isRunning&&i&&i.forEach((e=>{e.onObjectRemoved()})),removeObjectComponents(e,this)),n};const L=e.Object3D.prototype.toJSON;e.Object3D.prototype.toJSON=function(e){const t=this.children.filter((e=>e.userData.isEditorObject));t.forEach((e=>{this.remove(e)}));const i=L.bind(this)(e);if(t.forEach((e=>{this.attach(e)})),window.__IS_LOADING_MODEL__)return i;if(i.object.userData&&i.object.userData.__IS_MATERIAL__){i.images=[];for(let e in i.textures){const t=i.textures[e];i.textures[e]=t.uuid}}else{const e=[],t=[];i.textures&&i.textures.forEach((i=>{j.getAssetPath(i.uuid)&&(t.push(i),e.push(i.image))})),e.forEach((e=>{const t=i.images.find((t=>t.uuid===e));i.images.splice(i.images.indexOf(t),1)})),t.forEach((e=>{i.textures.splice(i.textures.indexOf(e),1)}));const n=[];i.materials&&i.materials.forEach((e=>{j.getAssetPath(e.uuid)&&n.push(e)})),n.forEach((e=>{i.materials.splice(i.materials.indexOf(e),1)}))}return i};const D=["Prefab","Material","Aduio","PositionalAudio","AnimationClip"],R=["png","PNG","jpg","JPG","jpeg","JPEG","gif","GIF","webp","WEBP","tga","TGA","tif","tiff","TIF","TIFF"],T=["mp3","MP3","ogg","OGG","mkv","MKV","wav","WAV"];let j=new class AssetManagerClass{constructor(){this._assets={},this._assetConfigs={},this._assetPaths={},this._loadingAssets={},this._objectLoader=new e.ObjectLoader,this.textureLoader=new e.TextureLoader}get assets(){return this._assets}get assetConfigs(){return this._assetConfigs}get assetPaths(){return this._assetPaths}get totalLoadingAssets(){return Object.keys(this._loadingAssets).length}onRegisterAsset(e){return o.on("onRegisterAsset",e),{stop:()=>{o.removeListener("onRegisterAsset",e)}}}onRemoveAsset(e){return o.on("onRemoveAsset",e),{stop:()=>{o.removeListener("onRemoveAsset",e)}}}onClearAssets(e){return o.on("onClearAssets",e),{stop:()=>{o.removeListener("onClearAssets",e)}}}onSetAssetConfig(e){return o.on("onSetAssetConfig",e),{stop:()=>{o.removeListener("onSetAssetConfig",e)}}}onRemoveAssetConfig(e){return o.on("onRemoveAssetConfig",e),{stop:()=>{o.removeListener("onRemoveAssetConfig",e)}}}onLoadAssetConfigs(e){return o.on("onLoadAssetConfigs",e),{stop:()=>{o.removeListener("onLoadAssetConfigs",e)}}}onSetAssetPath(e){return o.on("onSetAssetPath",e),{stop:()=>{o.removeListener("onSetAssetPath",e)}}}onSetAssetPaths(e){return o.on("onSetAssetPaths",e),{stop:()=>{o.removeListener("onSetAssetPaths",e)}}}onRemoveAssetPath(e){return o.on("onRemoveAssetPath",e),{stop:()=>{o.removeListener("onRemoveAssetPath",e)}}}setAssetConfig(e,t){this._assetConfigs[e]=t,t.preload||t.keepLoaded||t.override||delete this._assetConfigs[e],o.emit("onSetAssetConfig",e,t)}getAssetConfig(e){return this._assetConfigs[e]}removeAssetConfig(e){const t=this._assetConfigs[e];delete this._assetConfigs[e],o.emit("onRemoveAssetConfig",e,t)}setAssetPath(e,t){this._assetPaths[e]=t,o.emit("onSetAssetPath",e,t)}removeAssetPath(e){const t=this._assetPaths[e];delete this._assetPaths[e],o.emit("onRemoveAssetPath",e,t)}setAssetPaths(e){this._assetPaths=Object.assign({},e),o.emit("onSetAssetPaths",e)}getAssetPath(e){let t,i=window.re_prefix;return this._assetPaths[e]&&(t=this._assetPaths[e]),i?i+t:t}registerAsset(e){this._assets[e.uuid]=e,o.emit("onRegisterAsset",e)}loadAsset(e){return __awaiter(this,void 0,void 0,(function*(){const t=this.getAsset(e);if(t)return t;const i=this.getAssetPath(e);if(!i)return;const n=this.getExtension(i);return"roguePrefab"===n?yield this.loadObject(i):"rogueAnimation"===n?yield this.loadAnimation(i):T.indexOf(n)>=0?yield this.loadAudio(i):"rogueMaterial"===n?yield this.loadMaterial(i):R.indexOf(n)>=0?yield this.loadTexture(i):void 0}))}getExtension(e){return e.substr(e.lastIndexOf(".")+1)}getAsset(e){return this._assets[e]}loadObject(e){if(this._loadingAssets[e])return this._loadingAssets[e];const t=this.loadObjectFunction(e);return this.addLoadingAsset(e,t),t}loadObjectFunction(e){return __awaiter(this,void 0,void 0,(function*(){let t=yield fetch(e),i=yield t.json();const n=this._objectLoader.parse(i);return n.uuid=i.object.uuid,this.registerAsset(n),yield this.loadNestedPrefabs(n),this.removeLoadingAsset(e),n}))}loadNestedPrefabs(e){return __awaiter(this,void 0,void 0,(function*(){const t=e.userData.__NESTED__;if(t)for(let e=0;e<t.length;e++)yield this.loadAsset(t[e].uuid);for(let i=0;i<e.children.length;i++)yield this.loadNestedPrefabs(e.children[i])}))}loadAudio(e){if(this._loadingAssets[e])return this._loadingAssets[e];const t=this.loadAudioFunction(e);return this.addLoadingAsset(e,t),t}loadAudioFunction(e){return __awaiter(this,void 0,void 0,(function*(){const t=yield AudioAsset.fromFile(e);return this.registerAsset(t),this.removeLoadingAsset(e),t}))}loadAnimation(e){if(this._loadingAssets[e])return this._loadingAssets[e];const t=this.loadAnimationFunction(e);return this.addLoadingAsset(e,t),t}loadAnimationFunction(t){return __awaiter(this,void 0,void 0,(function*(){let i=yield fetch(t),n=yield i.json();const s=e.AnimationClip.parse(n);return this.registerAsset(s),this.removeLoadingAsset(t),s}))}loadMaterial(e){if(this._loadingAssets[e])return this._loadingAssets[e];const t=this.loadMaterialFunction(e);return this.addLoadingAsset(e,t),t}loadMaterialFunction(e){return __awaiter(this,void 0,void 0,(function*(){const t=yield fetch(e),i=yield t.json(),n=[];for(let e in i.textures){const t=i.textures[e],s="string"===typeof t?t:t.uuid,o=this.getAssetPath(s);!this.getAsset(s)&&o&&(yield this.loadTexture(o)),o&&n.push(s)}const s={};for(let e in i.materials[0]){const t=i.materials[0];n.forEach((i=>{i===t[e]&&(s[e]=i)}))}const o=i.textures;i.textures=[];const r=this._objectLoader.parse(i).material;i.textures=o;for(let e in s){const t=s[e];r[e]=this.getAsset(t)}return this.registerAsset(r),this.removeLoadingAsset(e),r}))}loadTexture(e){if(this._loadingAssets[e])return this._loadingAssets[e];const t=this.loadTextureFunction(e);return this.addLoadingAsset(e,t),t}loadTextureFunction(e){return __awaiter(this,void 0,void 0,(function*(){let t=yield fetch(e+".meta"),i=yield t.json();const n=yield this.loadTextureFile(e,i);return this.registerAsset(n),this.removeLoadingAsset(e),n}))}loadTextureFile(e,t){return new Promise((i=>{this.textureLoader.load(e,(e=>{Object.keys(t.object).forEach((i=>{"repeat"===i||"center"===i||"offset"===i?(e[i].x=t.object[i][0],e[i].y=t.object[i][1]):"wrap"===i?(e.wrapS=t.object[i][0],e.wrapT=t.object[i][1]):"image"===i||(e[i]=t.object[i])})),this.sceneController&&this.sceneController.renderer.initTexture(e),i(e)}))}))}addLoadingAsset(e,t){this._loadingAssets[e]=t}removeLoadingAsset(e){delete this._loadingAssets[e]}removeAsset(e){const t=this._assets[e];delete this._assets[e],o.emit("onRemoveAsset",e,t)}clear(){for(const e in this._assets)delete this._assets[e];o.emit("onClearAssets")}assetIsOrphan(t){const i=this.getAsset(t);if(!i)return!1;let n=!0;return traverseComponents((e=>{for(const t in e.interface)D.indexOf(t)>=0&&e[t]===i&&(n=!1)})),i instanceof e.Material&&App.currentScene.traverse((e=>{e&&e.material===i&&(n=!1)})),i instanceof e.Texture&&App.currentScene.traverse((t=>{if(t&&t.material instanceof e.Material)for(let s in t.material)t.material[s]instanceof e.Texture&&t.material[s]===i&&(n=!1)})),n}loadAssetConfigs(e={}){const t=this._assetConfigs,i=Object.keys(this._assets);for(const n in t){const i=e[n]&&e[n].override;t[n].override&&!i&&(e[n]=t[n])}i.forEach((i=>{const n=!!t[i]&&t[i].keepLoaded,s=!!e[i]&&e[i].preload;n||s||this.removeAsset(i)})),this._assetConfigs=e,o.emit("onLoadAssetConfigs")}preloadAssets(){return __awaiter(this,void 0,void 0,(function*(){for(let e in this._assetConfigs){!this._assets[e]&&this._assetConfigs[e].preload&&(yield this.loadAsset(e))}}))}};function Prop(e){return function(t,i){t.constructor.interface||(t.constructor.interface={}),t.constructor.interface[i]=e}}function PropList(e){return function(t,i){t.constructor.interface||(t.constructor.interface={}),t.constructor.interface[i]=[e]}}let M,B="",N=!1,F={};function decoratorFunc(e,t){if("button"===B&&"function"!==typeof e[t])return Decorators_reset();e.constructor.interface||(e.constructor.interface={}),e.constructor.interface=Object.assign({},e.constructor.interface);const i={type:B,group:M,options:F};e.constructor.interface[t]=N?[i]:i,Decorators_reset()}function Decorators_reset(){N=!1,M=void 0,F={}}class Decorators{num(e,t){return B="Number",F.min=e,F.max=t,decoratorFunc}checkbox(){return B="Boolean",decoratorFunc}text(e){return B="String",F.isTextArea=e,decoratorFunc}code(e){return B="Code","json"===e?F.lang="application/json":"html"===e?F.lang="text/html":"glsl"===e&&(F.lang=e),decoratorFunc}select(){return B="Select",decoratorFunc}vector2(){return B="Vector2",decoratorFunc}vector3(){return B="Vector3",decoratorFunc}prefab(){return B="Prefab",decoratorFunc}material(){return B="Material",decoratorFunc}texture(){return B="Texture",decoratorFunc}object3d(){return B="Object3D",decoratorFunc}audio(e){return B=e?"PositionalAudio":"Audio",decoratorFunc}color(){return B="Color",decoratorFunc}animation(){return B="AnimationClip",decoratorFunc}button(){return B="Button",decoratorFunc}}class ListProp extends Decorators{}const I=new class Props extends Decorators{constructor(){super(...arguments),this._list=new ListProp}get list(){return N=!0,this._list}data(){return B="Data",decoratorFunc}};function parallelTraverse(e,t,i){i(e,t);for(var n=0;n<e.children.length;n++)parallelTraverse(e.children[n],t.children[n],i)}function resetClonedSkinnedMeshes(e,t){const i=[],n={},s={};parallelTraverse(e,t,(function(e,t){e.isSkinnedMesh&&(n[t.uuid]=e,i.push(t)),e.isBone&&(s[e.uuid]=t)}));for(let o=0,r=i.length;o<r;o++){const e=i[o],t=n[e.uuid],r=t.skeleton.bones;e.skeleton=t.skeleton.clone(),e.bindMatrix.copy(t.bindMatrix),e.skeleton.bones=r.map((function(e){return s[e.uuid]})),e.bind(e.skeleton,e.bindMatrix)}}const U=e.Object3D.prototype.clone;e.Object3D.prototype.clone=function(e){const t=U.bind(this)(e);return resetClonedSkinnedMeshes(this,t),t}})(),window["rogue-engine"]=i})();
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("rogue-engine"), require("three"));
	else if(typeof define === 'function' && define.amd)
		define(["rogue-engine", "three"], factory);
	else if(typeof exports === 'object')
		exports["rogue-engine-user-scripts"] = factory(require("rogue-engine"), require("three"));
	else
		root["rogue-engine-user-scripts"] = factory(root["rogue-engine"], root["three"]);
})(self, function(__WEBPACK_EXTERNAL_MODULE_rogue_engine__, __WEBPACK_EXTERNAL_MODULE_three__) {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/cannon-es/dist/cannon-es.js":
/*!**************************************************!*\
  !*** ./node_modules/cannon-es/dist/cannon-es.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AABB": () => (/* binding */ AABB),
/* harmony export */   "ArrayCollisionMatrix": () => (/* binding */ ArrayCollisionMatrix),
/* harmony export */   "BODY_SLEEP_STATES": () => (/* binding */ BODY_SLEEP_STATES),
/* harmony export */   "BODY_TYPES": () => (/* binding */ BODY_TYPES),
/* harmony export */   "Body": () => (/* binding */ Body),
/* harmony export */   "Box": () => (/* binding */ Box),
/* harmony export */   "Broadphase": () => (/* binding */ Broadphase),
/* harmony export */   "COLLISION_TYPES": () => (/* binding */ COLLISION_TYPES),
/* harmony export */   "ConeTwistConstraint": () => (/* binding */ ConeTwistConstraint),
/* harmony export */   "Constraint": () => (/* binding */ Constraint),
/* harmony export */   "ContactEquation": () => (/* binding */ ContactEquation),
/* harmony export */   "ContactMaterial": () => (/* binding */ ContactMaterial),
/* harmony export */   "ConvexPolyhedron": () => (/* binding */ ConvexPolyhedron),
/* harmony export */   "Cylinder": () => (/* binding */ Cylinder),
/* harmony export */   "DistanceConstraint": () => (/* binding */ DistanceConstraint),
/* harmony export */   "Equation": () => (/* binding */ Equation),
/* harmony export */   "EventTarget": () => (/* binding */ EventTarget),
/* harmony export */   "FrictionEquation": () => (/* binding */ FrictionEquation),
/* harmony export */   "GSSolver": () => (/* binding */ GSSolver),
/* harmony export */   "GridBroadphase": () => (/* binding */ GridBroadphase),
/* harmony export */   "Heightfield": () => (/* binding */ Heightfield),
/* harmony export */   "HingeConstraint": () => (/* binding */ HingeConstraint),
/* harmony export */   "JacobianElement": () => (/* binding */ JacobianElement),
/* harmony export */   "LockConstraint": () => (/* binding */ LockConstraint),
/* harmony export */   "Mat3": () => (/* binding */ Mat3),
/* harmony export */   "Material": () => (/* binding */ Material),
/* harmony export */   "NaiveBroadphase": () => (/* binding */ NaiveBroadphase),
/* harmony export */   "Narrowphase": () => (/* binding */ Narrowphase),
/* harmony export */   "ObjectCollisionMatrix": () => (/* binding */ ObjectCollisionMatrix),
/* harmony export */   "Particle": () => (/* binding */ Particle),
/* harmony export */   "Plane": () => (/* binding */ Plane),
/* harmony export */   "PointToPointConstraint": () => (/* binding */ PointToPointConstraint),
/* harmony export */   "Pool": () => (/* binding */ Pool),
/* harmony export */   "Quaternion": () => (/* binding */ Quaternion),
/* harmony export */   "RAY_MODES": () => (/* binding */ RAY_MODES),
/* harmony export */   "Ray": () => (/* binding */ Ray),
/* harmony export */   "RaycastResult": () => (/* binding */ RaycastResult),
/* harmony export */   "RaycastVehicle": () => (/* binding */ RaycastVehicle),
/* harmony export */   "RigidVehicle": () => (/* binding */ RigidVehicle),
/* harmony export */   "RotationalEquation": () => (/* binding */ RotationalEquation),
/* harmony export */   "RotationalMotorEquation": () => (/* binding */ RotationalMotorEquation),
/* harmony export */   "SAPBroadphase": () => (/* binding */ SAPBroadphase),
/* harmony export */   "SHAPE_TYPES": () => (/* binding */ SHAPE_TYPES),
/* harmony export */   "SPHSystem": () => (/* binding */ SPHSystem),
/* harmony export */   "Shape": () => (/* binding */ Shape),
/* harmony export */   "Solver": () => (/* binding */ Solver),
/* harmony export */   "Sphere": () => (/* binding */ Sphere),
/* harmony export */   "SplitSolver": () => (/* binding */ SplitSolver),
/* harmony export */   "Spring": () => (/* binding */ Spring),
/* harmony export */   "Transform": () => (/* binding */ Transform),
/* harmony export */   "Trimesh": () => (/* binding */ Trimesh),
/* harmony export */   "Vec3": () => (/* binding */ Vec3),
/* harmony export */   "Vec3Pool": () => (/* binding */ Vec3Pool),
/* harmony export */   "WheelInfo": () => (/* binding */ WheelInfo),
/* harmony export */   "World": () => (/* binding */ World)
/* harmony export */ });
/**
 * Records what objects are colliding with each other
 */
class ObjectCollisionMatrix {
  /**
   * The matrix storage.
   */

  /**
   * @todo Remove useless constructor
   */
  constructor() {
    this.matrix = void 0;
    this.matrix = {};
  }
  /**
   * get
   */


  get(bi, bj) {
    let {
      id: i
    } = bi;
    let {
      id: j
    } = bj;

    if (j > i) {
      const temp = j;
      j = i;
      i = temp;
    }

    return i + "-" + j in this.matrix;
  }
  /**
   * set
   */


  set(bi, bj, value) {
    let {
      id: i
    } = bi;
    let {
      id: j
    } = bj;

    if (j > i) {
      const temp = j;
      j = i;
      i = temp;
    }

    if (value) {
      this.matrix[i + "-" + j] = true;
    } else {
      delete this.matrix[i + "-" + j];
    }
  }
  /**
   * Empty the matrix
   */


  reset() {
    this.matrix = {};
  }
  /**
   * Set max number of objects
   */


  setNumObjects(n) {}

}

/**
 * A 3x3 matrix.
 * Authored by {@link http://github.com/schteppe/ schteppe}
 */
class Mat3 {
  /**
   * A vector of length 9, containing all matrix elements.
   */

  /**
   * @param elements A vector of length 9, containing all matrix elements.
   */
  constructor(elements = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {
    this.elements = void 0;
    this.elements = elements;
  }
  /**
   * Sets the matrix to identity
   * @todo Should perhaps be renamed to `setIdentity()` to be more clear.
   * @todo Create another function that immediately creates an identity matrix eg. `eye()`
   */


  identity() {
    const e = this.elements;
    e[0] = 1;
    e[1] = 0;
    e[2] = 0;
    e[3] = 0;
    e[4] = 1;
    e[5] = 0;
    e[6] = 0;
    e[7] = 0;
    e[8] = 1;
  }
  /**
   * Set all elements to zero
   */


  setZero() {
    const e = this.elements;
    e[0] = 0;
    e[1] = 0;
    e[2] = 0;
    e[3] = 0;
    e[4] = 0;
    e[5] = 0;
    e[6] = 0;
    e[7] = 0;
    e[8] = 0;
  }
  /**
   * Sets the matrix diagonal elements from a Vec3
   */


  setTrace(vector) {
    const e = this.elements;
    e[0] = vector.x;
    e[4] = vector.y;
    e[8] = vector.z;
  }
  /**
   * Gets the matrix diagonal elements
   */


  getTrace(target = new Vec3()) {
    const e = this.elements;
    target.x = e[0];
    target.y = e[4];
    target.z = e[8];
    return target;
  }
  /**
   * Matrix-Vector multiplication
   * @param v The vector to multiply with
   * @param target Optional, target to save the result in.
   */


  vmult(v, target = new Vec3()) {
    const e = this.elements;
    const x = v.x;
    const y = v.y;
    const z = v.z;
    target.x = e[0] * x + e[1] * y + e[2] * z;
    target.y = e[3] * x + e[4] * y + e[5] * z;
    target.z = e[6] * x + e[7] * y + e[8] * z;
    return target;
  }
  /**
   * Matrix-scalar multiplication
   */


  smult(s) {
    for (let i = 0; i < this.elements.length; i++) {
      this.elements[i] *= s;
    }
  }
  /**
   * Matrix multiplication
   * @param matrix Matrix to multiply with from left side.
   */


  mmult(matrix, target = new Mat3()) {
    const A = this.elements;
    const B = matrix.elements;
    const T = target.elements;
    const a11 = A[0],
          a12 = A[1],
          a13 = A[2],
          a21 = A[3],
          a22 = A[4],
          a23 = A[5],
          a31 = A[6],
          a32 = A[7],
          a33 = A[8];
    const b11 = B[0],
          b12 = B[1],
          b13 = B[2],
          b21 = B[3],
          b22 = B[4],
          b23 = B[5],
          b31 = B[6],
          b32 = B[7],
          b33 = B[8];
    T[0] = a11 * b11 + a12 * b21 + a13 * b31;
    T[1] = a11 * b12 + a12 * b22 + a13 * b32;
    T[2] = a11 * b13 + a12 * b23 + a13 * b33;
    T[3] = a21 * b11 + a22 * b21 + a23 * b31;
    T[4] = a21 * b12 + a22 * b22 + a23 * b32;
    T[5] = a21 * b13 + a22 * b23 + a23 * b33;
    T[6] = a31 * b11 + a32 * b21 + a33 * b31;
    T[7] = a31 * b12 + a32 * b22 + a33 * b32;
    T[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return target;
  }
  /**
   * Scale each column of the matrix
   */


  scale(vector, target = new Mat3()) {
    const e = this.elements;
    const t = target.elements;

    for (let i = 0; i !== 3; i++) {
      t[3 * i + 0] = vector.x * e[3 * i + 0];
      t[3 * i + 1] = vector.y * e[3 * i + 1];
      t[3 * i + 2] = vector.z * e[3 * i + 2];
    }

    return target;
  }
  /**
   * Solve Ax=b
   * @param b The right hand side
   * @param target Optional. Target vector to save in.
   * @return The solution x
   * @todo should reuse arrays
   */


  solve(b, target = new Vec3()) {
    // Construct equations
    const nr = 3; // num rows

    const nc = 4; // num cols

    const eqns = [];
    let i;
    let j;

    for (i = 0; i < nr * nc; i++) {
      eqns.push(0);
    }

    for (i = 0; i < 3; i++) {
      for (j = 0; j < 3; j++) {
        eqns[i + nc * j] = this.elements[i + 3 * j];
      }
    }

    eqns[3 + 4 * 0] = b.x;
    eqns[3 + 4 * 1] = b.y;
    eqns[3 + 4 * 2] = b.z; // Compute right upper triangular version of the matrix - Gauss elimination

    let n = 3;
    const k = n;
    let np;
    const kp = 4; // num rows

    let p;

    do {
      i = k - n;

      if (eqns[i + nc * i] === 0) {
        // the pivot is null, swap lines
        for (j = i + 1; j < k; j++) {
          if (eqns[i + nc * j] !== 0) {
            np = kp;

            do {
              // do ligne( i ) = ligne( i ) + ligne( k )
              p = kp - np;
              eqns[p + nc * i] += eqns[p + nc * j];
            } while (--np);

            break;
          }
        }
      }

      if (eqns[i + nc * i] !== 0) {
        for (j = i + 1; j < k; j++) {
          const multiplier = eqns[i + nc * j] / eqns[i + nc * i];
          np = kp;

          do {
            // do ligne( k ) = ligne( k ) - multiplier * ligne( i )
            p = kp - np;
            eqns[p + nc * j] = p <= i ? 0 : eqns[p + nc * j] - eqns[p + nc * i] * multiplier;
          } while (--np);
        }
      }
    } while (--n); // Get the solution


    target.z = eqns[2 * nc + 3] / eqns[2 * nc + 2];
    target.y = (eqns[1 * nc + 3] - eqns[1 * nc + 2] * target.z) / eqns[1 * nc + 1];
    target.x = (eqns[0 * nc + 3] - eqns[0 * nc + 2] * target.z - eqns[0 * nc + 1] * target.y) / eqns[0 * nc + 0];

    if (isNaN(target.x) || isNaN(target.y) || isNaN(target.z) || target.x === Infinity || target.y === Infinity || target.z === Infinity) {
      throw "Could not solve equation! Got x=[" + target.toString() + "], b=[" + b.toString() + "], A=[" + this.toString() + "]";
    }

    return target;
  }
  /**
   * Get an element in the matrix by index. Index starts at 0, not 1!!!
   * @param value If provided, the matrix element will be set to this value.
   */


  e(row, column, value) {
    if (value === undefined) {
      return this.elements[column + 3 * row];
    } else {
      // Set value
      this.elements[column + 3 * row] = value;
    }
  }
  /**
   * Copy another matrix into this matrix object.
   */


  copy(matrix) {
    for (let i = 0; i < matrix.elements.length; i++) {
      this.elements[i] = matrix.elements[i];
    }

    return this;
  }
  /**
   * Returns a string representation of the matrix.
   */


  toString() {
    let r = '';
    const sep = ',';

    for (let i = 0; i < 9; i++) {
      r += this.elements[i] + sep;
    }

    return r;
  }
  /**
   * reverse the matrix
   * @param target Target matrix to save in.
   * @return The solution x
   */


  reverse(target = new Mat3()) {
    // Construct equations
    const nr = 3; // num rows

    const nc = 6; // num cols

    const eqns = reverse_eqns;
    let i;
    let j;

    for (i = 0; i < 3; i++) {
      for (j = 0; j < 3; j++) {
        eqns[i + nc * j] = this.elements[i + 3 * j];
      }
    }

    eqns[3 + 6 * 0] = 1;
    eqns[3 + 6 * 1] = 0;
    eqns[3 + 6 * 2] = 0;
    eqns[4 + 6 * 0] = 0;
    eqns[4 + 6 * 1] = 1;
    eqns[4 + 6 * 2] = 0;
    eqns[5 + 6 * 0] = 0;
    eqns[5 + 6 * 1] = 0;
    eqns[5 + 6 * 2] = 1; // Compute right upper triangular version of the matrix - Gauss elimination

    let n = 3;
    const k = n;
    let np;
    const kp = nc; // num rows

    let p;

    do {
      i = k - n;

      if (eqns[i + nc * i] === 0) {
        // the pivot is null, swap lines
        for (j = i + 1; j < k; j++) {
          if (eqns[i + nc * j] !== 0) {
            np = kp;

            do {
              // do line( i ) = line( i ) + line( k )
              p = kp - np;
              eqns[p + nc * i] += eqns[p + nc * j];
            } while (--np);

            break;
          }
        }
      }

      if (eqns[i + nc * i] !== 0) {
        for (j = i + 1; j < k; j++) {
          const multiplier = eqns[i + nc * j] / eqns[i + nc * i];
          np = kp;

          do {
            // do line( k ) = line( k ) - multiplier * line( i )
            p = kp - np;
            eqns[p + nc * j] = p <= i ? 0 : eqns[p + nc * j] - eqns[p + nc * i] * multiplier;
          } while (--np);
        }
      }
    } while (--n); // eliminate the upper left triangle of the matrix


    i = 2;

    do {
      j = i - 1;

      do {
        const multiplier = eqns[i + nc * j] / eqns[i + nc * i];
        np = nc;

        do {
          p = nc - np;
          eqns[p + nc * j] = eqns[p + nc * j] - eqns[p + nc * i] * multiplier;
        } while (--np);
      } while (j--);
    } while (--i); // operations on the diagonal


    i = 2;

    do {
      const multiplier = 1 / eqns[i + nc * i];
      np = nc;

      do {
        p = nc - np;
        eqns[p + nc * i] = eqns[p + nc * i] * multiplier;
      } while (--np);
    } while (i--);

    i = 2;

    do {
      j = 2;

      do {
        p = eqns[nr + j + nc * i];

        if (isNaN(p) || p === Infinity) {
          throw "Could not reverse! A=[" + this.toString() + "]";
        }

        target.e(i, j, p);
      } while (j--);
    } while (i--);

    return target;
  }
  /**
   * Set the matrix from a quaterion
   */


  setRotationFromQuaternion(q) {
    const x = q.x;
    const y = q.y;
    const z = q.z;
    const w = q.w;
    const x2 = x + x;
    const y2 = y + y;
    const z2 = z + z;
    const xx = x * x2;
    const xy = x * y2;
    const xz = x * z2;
    const yy = y * y2;
    const yz = y * z2;
    const zz = z * z2;
    const wx = w * x2;
    const wy = w * y2;
    const wz = w * z2;
    const e = this.elements;
    e[3 * 0 + 0] = 1 - (yy + zz);
    e[3 * 0 + 1] = xy - wz;
    e[3 * 0 + 2] = xz + wy;
    e[3 * 1 + 0] = xy + wz;
    e[3 * 1 + 1] = 1 - (xx + zz);
    e[3 * 1 + 2] = yz - wx;
    e[3 * 2 + 0] = xz - wy;
    e[3 * 2 + 1] = yz + wx;
    e[3 * 2 + 2] = 1 - (xx + yy);
    return this;
  }
  /**
   * Transpose the matrix
   * @param target Optional. Where to store the result.
   * @return The target Mat3, or a new Mat3 if target was omitted.
   */


  transpose(target = new Mat3()) {
    const M = this.elements;
    const T = target.elements;
    let tmp; //Set diagonals

    T[0] = M[0];
    T[4] = M[4];
    T[8] = M[8];
    tmp = M[1];
    T[1] = M[3];
    T[3] = tmp;
    tmp = M[2];
    T[2] = M[6];
    T[6] = tmp;
    tmp = M[5];
    T[5] = M[7];
    T[7] = tmp;
    return target;
  }

}
const reverse_eqns = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

/**
 * 3-dimensional vector
 * @example
 *     const v = new Vec3(1, 2, 3)
 *     console.log('x=' + v.x) // x=1
 */

class Vec3 {
  constructor(x = 0.0, y = 0.0, z = 0.0) {
    this.x = void 0;
    this.y = void 0;
    this.z = void 0;
    this.x = x;
    this.y = y;
    this.z = z;
  }
  /**
   * Vector cross product
   * @param target Optional target to save in.
   */


  cross(vector, target = new Vec3()) {
    const vx = vector.x;
    const vy = vector.y;
    const vz = vector.z;
    const x = this.x;
    const y = this.y;
    const z = this.z;
    target.x = y * vz - z * vy;
    target.y = z * vx - x * vz;
    target.z = x * vy - y * vx;
    return target;
  }
  /**
   * Set the vectors' 3 elements
   */


  set(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }
  /**
   * Set all components of the vector to zero.
   */


  setZero() {
    this.x = this.y = this.z = 0;
  }
  /**
   * Vector addition
   */


  vadd(vector, target) {
    if (target) {
      target.x = vector.x + this.x;
      target.y = vector.y + this.y;
      target.z = vector.z + this.z;
    } else {
      return new Vec3(this.x + vector.x, this.y + vector.y, this.z + vector.z);
    }
  }
  /**
   * Vector subtraction
   * @param target Optional target to save in.
   */


  vsub(vector, target) {
    if (target) {
      target.x = this.x - vector.x;
      target.y = this.y - vector.y;
      target.z = this.z - vector.z;
    } else {
      return new Vec3(this.x - vector.x, this.y - vector.y, this.z - vector.z);
    }
  }
  /**
   * Get the cross product matrix a_cross from a vector, such that a x b = a_cross * b = c
   *
   * See {@link https://www8.cs.umu.se/kurser/TDBD24/VT06/lectures/Lecture6.pdf Ume University Lecture}
   */


  crossmat() {
    return new Mat3([0, -this.z, this.y, this.z, 0, -this.x, -this.y, this.x, 0]);
  }
  /**
   * Normalize the vector. Note that this changes the values in the vector.
    * @return Returns the norm of the vector
   */


  normalize() {
    const x = this.x;
    const y = this.y;
    const z = this.z;
    const n = Math.sqrt(x * x + y * y + z * z);

    if (n > 0.0) {
      const invN = 1 / n;
      this.x *= invN;
      this.y *= invN;
      this.z *= invN;
    } else {
      // Make something up
      this.x = 0;
      this.y = 0;
      this.z = 0;
    }

    return n;
  }
  /**
   * Get the version of this vector that is of length 1.
   * @param target Optional target to save in
   * @return Returns the unit vector
   */


  unit(target = new Vec3()) {
    const x = this.x;
    const y = this.y;
    const z = this.z;
    let ninv = Math.sqrt(x * x + y * y + z * z);

    if (ninv > 0.0) {
      ninv = 1.0 / ninv;
      target.x = x * ninv;
      target.y = y * ninv;
      target.z = z * ninv;
    } else {
      target.x = 1;
      target.y = 0;
      target.z = 0;
    }

    return target;
  }
  /**
   * Get the length of the vector
   */


  length() {
    const x = this.x;
    const y = this.y;
    const z = this.z;
    return Math.sqrt(x * x + y * y + z * z);
  }
  /**
   * Get the squared length of the vector.
   */


  lengthSquared() {
    return this.dot(this);
  }
  /**
   * Get distance from this point to another point
   */


  distanceTo(p) {
    const x = this.x;
    const y = this.y;
    const z = this.z;
    const px = p.x;
    const py = p.y;
    const pz = p.z;
    return Math.sqrt((px - x) * (px - x) + (py - y) * (py - y) + (pz - z) * (pz - z));
  }
  /**
   * Get squared distance from this point to another point
   */


  distanceSquared(p) {
    const x = this.x;
    const y = this.y;
    const z = this.z;
    const px = p.x;
    const py = p.y;
    const pz = p.z;
    return (px - x) * (px - x) + (py - y) * (py - y) + (pz - z) * (pz - z);
  }
  /**
   * Multiply all the components of the vector with a scalar.
   * @param target The vector to save the result in.
   */


  scale(scalar, target = new Vec3()) {
    const x = this.x;
    const y = this.y;
    const z = this.z;
    target.x = scalar * x;
    target.y = scalar * y;
    target.z = scalar * z;
    return target;
  }
  /**
   * Multiply the vector with an other vector, component-wise.
   * @param target The vector to save the result in.
   */


  vmul(vector, target = new Vec3()) {
    target.x = vector.x * this.x;
    target.y = vector.y * this.y;
    target.z = vector.z * this.z;
    return target;
  }
  /**
   * Scale a vector and add it to this vector. Save the result in "target". (target = this + vector * scalar)
   * @param target The vector to save the result in.
   */


  addScaledVector(scalar, vector, target = new Vec3()) {
    target.x = this.x + scalar * vector.x;
    target.y = this.y + scalar * vector.y;
    target.z = this.z + scalar * vector.z;
    return target;
  }
  /**
   * Calculate dot product
   * @param vector
   */


  dot(vector) {
    return this.x * vector.x + this.y * vector.y + this.z * vector.z;
  }

  isZero() {
    return this.x === 0 && this.y === 0 && this.z === 0;
  }
  /**
   * Make the vector point in the opposite direction.
   * @param target Optional target to save in
   */


  negate(target = new Vec3()) {
    target.x = -this.x;
    target.y = -this.y;
    target.z = -this.z;
    return target;
  }
  /**
   * Compute two artificial tangents to the vector
   * @param t1 Vector object to save the first tangent in
   * @param t2 Vector object to save the second tangent in
   */


  tangents(t1, t2) {
    const norm = this.length();

    if (norm > 0.0) {
      const n = Vec3_tangents_n;
      const inorm = 1 / norm;
      n.set(this.x * inorm, this.y * inorm, this.z * inorm);
      const randVec = Vec3_tangents_randVec;

      if (Math.abs(n.x) < 0.9) {
        randVec.set(1, 0, 0);
        n.cross(randVec, t1);
      } else {
        randVec.set(0, 1, 0);
        n.cross(randVec, t1);
      }

      n.cross(t1, t2);
    } else {
      // The normal length is zero, make something up
      t1.set(1, 0, 0);
      t2.set(0, 1, 0);
    }
  }
  /**
   * Converts to a more readable format
   */


  toString() {
    return this.x + "," + this.y + "," + this.z;
  }
  /**
   * Converts to an array
   */


  toArray() {
    return [this.x, this.y, this.z];
  }
  /**
   * Copies value of source to this vector.
   */


  copy(vector) {
    this.x = vector.x;
    this.y = vector.y;
    this.z = vector.z;
    return this;
  }
  /**
   * Do a linear interpolation between two vectors
   * @param t A number between 0 and 1. 0 will make this function return u, and 1 will make it return v. Numbers in between will generate a vector in between them.
   */


  lerp(vector, t, target) {
    const x = this.x;
    const y = this.y;
    const z = this.z;
    target.x = x + (vector.x - x) * t;
    target.y = y + (vector.y - y) * t;
    target.z = z + (vector.z - z) * t;
  }
  /**
   * Check if a vector equals is almost equal to another one.
   */


  almostEquals(vector, precision = 1e-6) {
    if (Math.abs(this.x - vector.x) > precision || Math.abs(this.y - vector.y) > precision || Math.abs(this.z - vector.z) > precision) {
      return false;
    }

    return true;
  }
  /**
   * Check if a vector is almost zero
   */


  almostZero(precision = 1e-6) {
    if (Math.abs(this.x) > precision || Math.abs(this.y) > precision || Math.abs(this.z) > precision) {
      return false;
    }

    return true;
  }
  /**
   * Check if the vector is anti-parallel to another vector.
   * @param precision Set to zero for exact comparisons
   */


  isAntiparallelTo(vector, precision) {
    this.negate(antip_neg);
    return antip_neg.almostEquals(vector, precision);
  }
  /**
   * Clone the vector
   */


  clone() {
    return new Vec3(this.x, this.y, this.z);
  }

}
Vec3.ZERO = void 0;
Vec3.UNIT_X = void 0;
Vec3.UNIT_Y = void 0;
Vec3.UNIT_Z = void 0;
Vec3.ZERO = new Vec3(0, 0, 0);
Vec3.UNIT_X = new Vec3(1, 0, 0);
Vec3.UNIT_Y = new Vec3(0, 1, 0);
Vec3.UNIT_Z = new Vec3(0, 0, 1);
const Vec3_tangents_n = new Vec3();
const Vec3_tangents_randVec = new Vec3();
const antip_neg = new Vec3();

/**
 * Axis aligned bounding box class.
 */
class AABB {
  /**
   * The lower bound of the bounding box
   */

  /**
   * The upper bound of the bounding box
   */
  constructor(options = {}) {
    this.lowerBound = void 0;
    this.upperBound = void 0;
    this.lowerBound = new Vec3();
    this.upperBound = new Vec3();

    if (options.lowerBound) {
      this.lowerBound.copy(options.lowerBound);
    }

    if (options.upperBound) {
      this.upperBound.copy(options.upperBound);
    }
  }
  /**
   * Set the AABB bounds from a set of points.
   * @param points An array of Vec3's.
   * @return The self object
   */


  setFromPoints(points, position, quaternion, skinSize) {
    const l = this.lowerBound;
    const u = this.upperBound;
    const q = quaternion; // Set to the first point

    l.copy(points[0]);

    if (q) {
      q.vmult(l, l);
    }

    u.copy(l);

    for (let i = 1; i < points.length; i++) {
      let p = points[i];

      if (q) {
        q.vmult(p, tmp$1);
        p = tmp$1;
      }

      if (p.x > u.x) {
        u.x = p.x;
      }

      if (p.x < l.x) {
        l.x = p.x;
      }

      if (p.y > u.y) {
        u.y = p.y;
      }

      if (p.y < l.y) {
        l.y = p.y;
      }

      if (p.z > u.z) {
        u.z = p.z;
      }

      if (p.z < l.z) {
        l.z = p.z;
      }
    } // Add offset


    if (position) {
      position.vadd(l, l);
      position.vadd(u, u);
    }

    if (skinSize) {
      l.x -= skinSize;
      l.y -= skinSize;
      l.z -= skinSize;
      u.x += skinSize;
      u.y += skinSize;
      u.z += skinSize;
    }

    return this;
  }
  /**
   * Copy bounds from an AABB to this AABB
   * @param aabb Source to copy from
   * @return The this object, for chainability
   */


  copy(aabb) {
    this.lowerBound.copy(aabb.lowerBound);
    this.upperBound.copy(aabb.upperBound);
    return this;
  }
  /**
   * Clone an AABB
   */


  clone() {
    return new AABB().copy(this);
  }
  /**
   * Extend this AABB so that it covers the given AABB too.
   */


  extend(aabb) {
    this.lowerBound.x = Math.min(this.lowerBound.x, aabb.lowerBound.x);
    this.upperBound.x = Math.max(this.upperBound.x, aabb.upperBound.x);
    this.lowerBound.y = Math.min(this.lowerBound.y, aabb.lowerBound.y);
    this.upperBound.y = Math.max(this.upperBound.y, aabb.upperBound.y);
    this.lowerBound.z = Math.min(this.lowerBound.z, aabb.lowerBound.z);
    this.upperBound.z = Math.max(this.upperBound.z, aabb.upperBound.z);
  }
  /**
   * Returns true if the given AABB overlaps this AABB.
   */


  overlaps(aabb) {
    const l1 = this.lowerBound;
    const u1 = this.upperBound;
    const l2 = aabb.lowerBound;
    const u2 = aabb.upperBound; //      l2        u2
    //      |---------|
    // |--------|
    // l1       u1

    const overlapsX = l2.x <= u1.x && u1.x <= u2.x || l1.x <= u2.x && u2.x <= u1.x;
    const overlapsY = l2.y <= u1.y && u1.y <= u2.y || l1.y <= u2.y && u2.y <= u1.y;
    const overlapsZ = l2.z <= u1.z && u1.z <= u2.z || l1.z <= u2.z && u2.z <= u1.z;
    return overlapsX && overlapsY && overlapsZ;
  } // Mostly for debugging


  volume() {
    const l = this.lowerBound;
    const u = this.upperBound;
    return (u.x - l.x) * (u.y - l.y) * (u.z - l.z);
  }
  /**
   * Returns true if the given AABB is fully contained in this AABB.
   */


  contains(aabb) {
    const l1 = this.lowerBound;
    const u1 = this.upperBound;
    const l2 = aabb.lowerBound;
    const u2 = aabb.upperBound; //      l2        u2
    //      |---------|
    // |---------------|
    // l1              u1

    return l1.x <= l2.x && u1.x >= u2.x && l1.y <= l2.y && u1.y >= u2.y && l1.z <= l2.z && u1.z >= u2.z;
  }

  getCorners(a, b, c, d, e, f, g, h) {
    const l = this.lowerBound;
    const u = this.upperBound;
    a.copy(l);
    b.set(u.x, l.y, l.z);
    c.set(u.x, u.y, l.z);
    d.set(l.x, u.y, u.z);
    e.set(u.x, l.y, u.z);
    f.set(l.x, u.y, l.z);
    g.set(l.x, l.y, u.z);
    h.copy(u);
  }
  /**
   * Get the representation of an AABB in another frame.
   * @return The "target" AABB object.
   */


  toLocalFrame(frame, target) {
    const corners = transformIntoFrame_corners;
    const a = corners[0];
    const b = corners[1];
    const c = corners[2];
    const d = corners[3];
    const e = corners[4];
    const f = corners[5];
    const g = corners[6];
    const h = corners[7]; // Get corners in current frame

    this.getCorners(a, b, c, d, e, f, g, h); // Transform them to new local frame

    for (let i = 0; i !== 8; i++) {
      const corner = corners[i];
      frame.pointToLocal(corner, corner);
    }

    return target.setFromPoints(corners);
  }
  /**
   * Get the representation of an AABB in the global frame.
   * @return The "target" AABB object.
   */


  toWorldFrame(frame, target) {
    const corners = transformIntoFrame_corners;
    const a = corners[0];
    const b = corners[1];
    const c = corners[2];
    const d = corners[3];
    const e = corners[4];
    const f = corners[5];
    const g = corners[6];
    const h = corners[7]; // Get corners in current frame

    this.getCorners(a, b, c, d, e, f, g, h); // Transform them to new local frame

    for (let i = 0; i !== 8; i++) {
      const corner = corners[i];
      frame.pointToWorld(corner, corner);
    }

    return target.setFromPoints(corners);
  }
  /**
   * Check if the AABB is hit by a ray.
   */


  overlapsRay(ray) {
    const {
      direction,
      from
    } = ray; // const t = 0
    // ray.direction is unit direction vector of ray

    const dirFracX = 1 / direction.x;
    const dirFracY = 1 / direction.y;
    const dirFracZ = 1 / direction.z; // this.lowerBound is the corner of AABB with minimal coordinates - left bottom, rt is maximal corner

    const t1 = (this.lowerBound.x - from.x) * dirFracX;
    const t2 = (this.upperBound.x - from.x) * dirFracX;
    const t3 = (this.lowerBound.y - from.y) * dirFracY;
    const t4 = (this.upperBound.y - from.y) * dirFracY;
    const t5 = (this.lowerBound.z - from.z) * dirFracZ;
    const t6 = (this.upperBound.z - from.z) * dirFracZ; // const tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)));
    // const tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)));

    const tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
    const tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6)); // if tmax < 0, ray (line) is intersecting AABB, but whole AABB is behing us

    if (tmax < 0) {
      //t = tmax;
      return false;
    } // if tmin > tmax, ray doesn't intersect AABB


    if (tmin > tmax) {
      //t = tmax;
      return false;
    }

    return true;
  }

}
const tmp$1 = new Vec3();
const transformIntoFrame_corners = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];

/**
 * Collision "matrix".
 * It's actually a triangular-shaped array of whether two bodies are touching this step, for reference next step
 */
class ArrayCollisionMatrix {
  /**
   * The matrix storage.
   */
  constructor() {
    this.matrix = void 0;
    this.matrix = [];
  }
  /**
   * Get an element
   */


  get(bi, bj) {
    let {
      index: i
    } = bi;
    let {
      index: j
    } = bj;

    if (j > i) {
      const temp = j;
      j = i;
      i = temp;
    }

    return this.matrix[(i * (i + 1) >> 1) + j - 1];
  }
  /**
   * Set an element
   */


  set(bi, bj, value) {
    let {
      index: i
    } = bi;
    let {
      index: j
    } = bj;

    if (j > i) {
      const temp = j;
      j = i;
      i = temp;
    }

    this.matrix[(i * (i + 1) >> 1) + j - 1] = value ? 1 : 0;
  }
  /**
   * Sets all elements to zero
   */


  reset() {
    for (let i = 0, l = this.matrix.length; i !== l; i++) {
      this.matrix[i] = 0;
    }
  }
  /**
   * Sets the max number of objects
   */


  setNumObjects(n) {
    this.matrix.length = n * (n - 1) >> 1;
  }

}

/**
 * Base class for objects that dispatches events.
 */
class EventTarget {
  constructor() {
    this._listeners = void 0;
  }

  /**
   * Add an event listener
   * @return The self object, for chainability.
   */
  addEventListener(type, listener) {
    if (this._listeners === undefined) {
      this._listeners = {};
    }

    const listeners = this._listeners;

    if (listeners[type] === undefined) {
      listeners[type] = [];
    }

    if (!listeners[type].includes(listener)) {
      listeners[type].push(listener);
    }

    return this;
  }
  /**
   * Check if an event listener is added
   */


  hasEventListener(type, listener) {
    if (this._listeners === undefined) {
      return false;
    }

    const listeners = this._listeners;

    if (listeners[type] !== undefined && listeners[type].includes(listener)) {
      return true;
    }

    return false;
  }
  /**
   * Check if any event listener of the given type is added
   */


  hasAnyEventListener(type) {
    if (this._listeners === undefined) {
      return false;
    }

    const listeners = this._listeners;
    return listeners[type] !== undefined;
  }
  /**
   * Remove an event listener
   * @return The self object, for chainability.
   */


  removeEventListener(type, listener) {
    if (this._listeners === undefined) {
      return this;
    }

    const listeners = this._listeners;

    if (listeners[type] === undefined) {
      return this;
    }

    const index = listeners[type].indexOf(listener);

    if (index !== -1) {
      listeners[type].splice(index, 1);
    }

    return this;
  }
  /**
   * Emit an event.
   * @return The self object, for chainability.
   */


  dispatchEvent(event) {
    if (this._listeners === undefined) {
      return this;
    }

    const listeners = this._listeners;
    const listenerArray = listeners[event.type];

    if (listenerArray !== undefined) {
      event.target = this;

      for (let i = 0, l = listenerArray.length; i < l; i++) {
        listenerArray[i].call(this, event);
      }
    }

    return this;
  }

}

/**
 * A Quaternion describes a rotation in 3D space. The Quaternion is mathematically defined as Q = x*i + y*j + z*k + w, where (i,j,k) are imaginary basis vectors. (x,y,z) can be seen as a vector related to the axis of rotation, while the real multiplier, w, is related to the amount of rotation.
 * @param x Multiplier of the imaginary basis vector i.
 * @param y Multiplier of the imaginary basis vector j.
 * @param z Multiplier of the imaginary basis vector k.
 * @param w Multiplier of the real part.
 * @see http://en.wikipedia.org/wiki/Quaternion
 */

class Quaternion {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this.x = void 0;
    this.y = void 0;
    this.z = void 0;
    this.w = void 0;
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  /**
   * Set the value of the quaternion.
   */


  set(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  }
  /**
   * Convert to a readable format
   * @return "x,y,z,w"
   */


  toString() {
    return this.x + "," + this.y + "," + this.z + "," + this.w;
  }
  /**
   * Convert to an Array
   * @return [x, y, z, w]
   */


  toArray() {
    return [this.x, this.y, this.z, this.w];
  }
  /**
   * Set the quaternion components given an axis and an angle in radians.
   */


  setFromAxisAngle(vector, angle) {
    const s = Math.sin(angle * 0.5);
    this.x = vector.x * s;
    this.y = vector.y * s;
    this.z = vector.z * s;
    this.w = Math.cos(angle * 0.5);
    return this;
  }
  /**
   * Converts the quaternion to [ axis, angle ] representation.
   * @param targetAxis A vector object to reuse for storing the axis.
   * @return An array, first element is the axis and the second is the angle in radians.
   */


  toAxisAngle(targetAxis = new Vec3()) {
    this.normalize(); // if w>1 acos and sqrt will produce errors, this cant happen if quaternion is normalised

    const angle = 2 * Math.acos(this.w);
    const s = Math.sqrt(1 - this.w * this.w); // assuming quaternion normalised then w is less than 1, so term always positive.

    if (s < 0.001) {
      // test to avoid divide by zero, s is always positive due to sqrt
      // if s close to zero then direction of axis not important
      targetAxis.x = this.x; // if it is important that axis is normalised then replace with x=1; y=z=0;

      targetAxis.y = this.y;
      targetAxis.z = this.z;
    } else {
      targetAxis.x = this.x / s; // normalise axis

      targetAxis.y = this.y / s;
      targetAxis.z = this.z / s;
    }

    return [targetAxis, angle];
  }
  /**
   * Set the quaternion value given two vectors. The resulting rotation will be the needed rotation to rotate u to v.
   */


  setFromVectors(u, v) {
    if (u.isAntiparallelTo(v)) {
      const t1 = sfv_t1;
      const t2 = sfv_t2;
      u.tangents(t1, t2);
      this.setFromAxisAngle(t1, Math.PI);
    } else {
      const a = u.cross(v);
      this.x = a.x;
      this.y = a.y;
      this.z = a.z;
      this.w = Math.sqrt(u.length() ** 2 * v.length() ** 2) + u.dot(v);
      this.normalize();
    }

    return this;
  }
  /**
   * Multiply the quaternion with an other quaternion.
   */


  mult(quat, target = new Quaternion()) {
    const ax = this.x;
    const ay = this.y;
    const az = this.z;
    const aw = this.w;
    const bx = quat.x;
    const by = quat.y;
    const bz = quat.z;
    const bw = quat.w;
    target.x = ax * bw + aw * bx + ay * bz - az * by;
    target.y = ay * bw + aw * by + az * bx - ax * bz;
    target.z = az * bw + aw * bz + ax * by - ay * bx;
    target.w = aw * bw - ax * bx - ay * by - az * bz;
    return target;
  }
  /**
   * Get the inverse quaternion rotation.
   */


  inverse(target = new Quaternion()) {
    const x = this.x;
    const y = this.y;
    const z = this.z;
    const w = this.w;
    this.conjugate(target);
    const inorm2 = 1 / (x * x + y * y + z * z + w * w);
    target.x *= inorm2;
    target.y *= inorm2;
    target.z *= inorm2;
    target.w *= inorm2;
    return target;
  }
  /**
   * Get the quaternion conjugate
   */


  conjugate(target = new Quaternion()) {
    target.x = -this.x;
    target.y = -this.y;
    target.z = -this.z;
    target.w = this.w;
    return target;
  }
  /**
   * Normalize the quaternion. Note that this changes the values of the quaternion.
   */


  normalize() {
    let l = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);

    if (l === 0) {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.w = 0;
    } else {
      l = 1 / l;
      this.x *= l;
      this.y *= l;
      this.z *= l;
      this.w *= l;
    }

    return this;
  }
  /**
   * Approximation of quaternion normalization. Works best when quat is already almost-normalized.
   * @author unphased, https://github.com/unphased
   */


  normalizeFast() {
    const f = (3.0 - (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)) / 2.0;

    if (f === 0) {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.w = 0;
    } else {
      this.x *= f;
      this.y *= f;
      this.z *= f;
      this.w *= f;
    }

    return this;
  }
  /**
   * Multiply the quaternion by a vector
   */


  vmult(v, target = new Vec3()) {
    const x = v.x;
    const y = v.y;
    const z = v.z;
    const qx = this.x;
    const qy = this.y;
    const qz = this.z;
    const qw = this.w; // q*v

    const ix = qw * x + qy * z - qz * y;
    const iy = qw * y + qz * x - qx * z;
    const iz = qw * z + qx * y - qy * x;
    const iw = -qx * x - qy * y - qz * z;
    target.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    target.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    target.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return target;
  }
  /**
   * Copies value of source to this quaternion.
   * @return this
   */


  copy(quat) {
    this.x = quat.x;
    this.y = quat.y;
    this.z = quat.z;
    this.w = quat.w;
    return this;
  }
  /**
   * Convert the quaternion to euler angle representation. Order: YZX, as this page describes: https://www.euclideanspace.com/maths/standards/index.htm
   * @param order Three-character string, defaults to "YZX"
   */


  toEuler(target, order = 'YZX') {
    let heading;
    let attitude;
    let bank;
    const x = this.x;
    const y = this.y;
    const z = this.z;
    const w = this.w;

    switch (order) {
      case 'YZX':
        const test = x * y + z * w;

        if (test > 0.499) {
          // singularity at north pole
          heading = 2 * Math.atan2(x, w);
          attitude = Math.PI / 2;
          bank = 0;
        }

        if (test < -0.499) {
          // singularity at south pole
          heading = -2 * Math.atan2(x, w);
          attitude = -Math.PI / 2;
          bank = 0;
        }

        if (heading === undefined) {
          const sqx = x * x;
          const sqy = y * y;
          const sqz = z * z;
          heading = Math.atan2(2 * y * w - 2 * x * z, 1 - 2 * sqy - 2 * sqz); // Heading

          attitude = Math.asin(2 * test); // attitude

          bank = Math.atan2(2 * x * w - 2 * y * z, 1 - 2 * sqx - 2 * sqz); // bank
        }

        break;

      default:
        throw new Error("Euler order " + order + " not supported yet.");
    }

    target.y = heading;
    target.z = attitude;
    target.x = bank;
  }
  /**
   * @param order The order to apply angles: 'XYZ' or 'YXZ' or any other combination.
   *
   * See {@link https://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors MathWorks} reference
   */


  setFromEuler(x, y, z, order = 'XYZ') {
    const c1 = Math.cos(x / 2);
    const c2 = Math.cos(y / 2);
    const c3 = Math.cos(z / 2);
    const s1 = Math.sin(x / 2);
    const s2 = Math.sin(y / 2);
    const s3 = Math.sin(z / 2);

    if (order === 'XYZ') {
      this.x = s1 * c2 * c3 + c1 * s2 * s3;
      this.y = c1 * s2 * c3 - s1 * c2 * s3;
      this.z = c1 * c2 * s3 + s1 * s2 * c3;
      this.w = c1 * c2 * c3 - s1 * s2 * s3;
    } else if (order === 'YXZ') {
      this.x = s1 * c2 * c3 + c1 * s2 * s3;
      this.y = c1 * s2 * c3 - s1 * c2 * s3;
      this.z = c1 * c2 * s3 - s1 * s2 * c3;
      this.w = c1 * c2 * c3 + s1 * s2 * s3;
    } else if (order === 'ZXY') {
      this.x = s1 * c2 * c3 - c1 * s2 * s3;
      this.y = c1 * s2 * c3 + s1 * c2 * s3;
      this.z = c1 * c2 * s3 + s1 * s2 * c3;
      this.w = c1 * c2 * c3 - s1 * s2 * s3;
    } else if (order === 'ZYX') {
      this.x = s1 * c2 * c3 - c1 * s2 * s3;
      this.y = c1 * s2 * c3 + s1 * c2 * s3;
      this.z = c1 * c2 * s3 - s1 * s2 * c3;
      this.w = c1 * c2 * c3 + s1 * s2 * s3;
    } else if (order === 'YZX') {
      this.x = s1 * c2 * c3 + c1 * s2 * s3;
      this.y = c1 * s2 * c3 + s1 * c2 * s3;
      this.z = c1 * c2 * s3 - s1 * s2 * c3;
      this.w = c1 * c2 * c3 - s1 * s2 * s3;
    } else if (order === 'XZY') {
      this.x = s1 * c2 * c3 - c1 * s2 * s3;
      this.y = c1 * s2 * c3 - s1 * c2 * s3;
      this.z = c1 * c2 * s3 + s1 * s2 * c3;
      this.w = c1 * c2 * c3 + s1 * s2 * s3;
    }

    return this;
  }

  clone() {
    return new Quaternion(this.x, this.y, this.z, this.w);
  }
  /**
   * Performs a spherical linear interpolation between two quat
   *
   * @param toQuat second operand
   * @param t interpolation amount between the self quaternion and toQuat
   * @param target A quaternion to store the result in. If not provided, a new one will be created.
   * @returns {Quaternion} The "target" object
   */


  slerp(toQuat, t, target = new Quaternion()) {
    const ax = this.x;
    const ay = this.y;
    const az = this.z;
    const aw = this.w;
    let bx = toQuat.x;
    let by = toQuat.y;
    let bz = toQuat.z;
    let bw = toQuat.w;
    let omega;
    let cosom;
    let sinom;
    let scale0;
    let scale1; // calc cosine

    cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

    if (cosom < 0.0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    } // calculate coefficients


    if (1.0 - cosom > 0.000001) {
      // standard case (slerp)
      omega = Math.acos(cosom);
      sinom = Math.sin(omega);
      scale0 = Math.sin((1.0 - t) * omega) / sinom;
      scale1 = Math.sin(t * omega) / sinom;
    } else {
      // "from" and "to" quaternions are very close
      //  ... so we can do a linear interpolation
      scale0 = 1.0 - t;
      scale1 = t;
    } // calculate final values


    target.x = scale0 * ax + scale1 * bx;
    target.y = scale0 * ay + scale1 * by;
    target.z = scale0 * az + scale1 * bz;
    target.w = scale0 * aw + scale1 * bw;
    return target;
  }
  /**
   * Rotate an absolute orientation quaternion given an angular velocity and a time step.
   */


  integrate(angularVelocity, dt, angularFactor, target = new Quaternion()) {
    const ax = angularVelocity.x * angularFactor.x,
          ay = angularVelocity.y * angularFactor.y,
          az = angularVelocity.z * angularFactor.z,
          bx = this.x,
          by = this.y,
          bz = this.z,
          bw = this.w;
    const half_dt = dt * 0.5;
    target.x += half_dt * (ax * bw + ay * bz - az * by);
    target.y += half_dt * (ay * bw + az * bx - ax * bz);
    target.z += half_dt * (az * bw + ax * by - ay * bx);
    target.w += half_dt * (-ax * bx - ay * by - az * bz);
    return target;
  }

}
const sfv_t1 = new Vec3();
const sfv_t2 = new Vec3();

/**
 * The available shape types.
 */
const SHAPE_TYPES = {
  /** SPHERE */
  SPHERE: 1,

  /** PLANE */
  PLANE: 2,

  /** BOX */
  BOX: 4,

  /** COMPOUND */
  COMPOUND: 8,

  /** CONVEXPOLYHEDRON */
  CONVEXPOLYHEDRON: 16,

  /** HEIGHTFIELD */
  HEIGHTFIELD: 32,

  /** PARTICLE */
  PARTICLE: 64,

  /** CYLINDER */
  CYLINDER: 128,

  /** TRIMESH */
  TRIMESH: 256
};
/**
 * ShapeType
 */

/**
 * Base class for shapes
 */
class Shape {
  /**
   * Identifier of the Shape.
   */

  /**
   * The type of this shape. Must be set to an int > 0 by subclasses.
   */

  /**
   * The local bounding sphere radius of this shape.
   */

  /**
   * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled.
   * @default true
   */

  /**
   * @default 1
   */

  /**
   * @default -1
   */

  /**
   * Optional material of the shape that regulates contact properties.
   */

  /**
   * The body to which the shape is added to.
   */

  /**
   * All the Shape types.
   */
  constructor(options = {}) {
    this.id = void 0;
    this.type = void 0;
    this.boundingSphereRadius = void 0;
    this.collisionResponse = void 0;
    this.collisionFilterGroup = void 0;
    this.collisionFilterMask = void 0;
    this.material = void 0;
    this.body = void 0;
    this.id = Shape.idCounter++;
    this.type = options.type || 0;
    this.boundingSphereRadius = 0;
    this.collisionResponse = options.collisionResponse ? options.collisionResponse : true;
    this.collisionFilterGroup = options.collisionFilterGroup !== undefined ? options.collisionFilterGroup : 1;
    this.collisionFilterMask = options.collisionFilterMask !== undefined ? options.collisionFilterMask : -1;
    this.material = options.material ? options.material : null;
    this.body = null;
  }
  /**
   * Computes the bounding sphere radius.
   * The result is stored in the property `.boundingSphereRadius`
   */


  updateBoundingSphereRadius() {
    throw "computeBoundingSphereRadius() not implemented for shape type " + this.type;
  }
  /**
   * Get the volume of this shape
   */


  volume() {
    throw "volume() not implemented for shape type " + this.type;
  }
  /**
   * Calculates the inertia in the local frame for this shape.
   * @see http://en.wikipedia.org/wiki/List_of_moments_of_inertia
   */


  calculateLocalInertia(mass, target) {
    throw "calculateLocalInertia() not implemented for shape type " + this.type;
  }
  /**
   * @todo use abstract for these kind of methods
   */


  calculateWorldAABB(pos, quat, min, max) {
    throw "calculateWorldAABB() not implemented for shape type " + this.type;
  }

}
Shape.idCounter = 0;
Shape.types = SHAPE_TYPES;

/**
 * Transformation utilities.
 */
class Transform {
  /**
   * position
   */

  /**
   * quaternion
   */
  constructor(options = {}) {
    this.position = void 0;
    this.quaternion = void 0;
    this.position = new Vec3();
    this.quaternion = new Quaternion();

    if (options.position) {
      this.position.copy(options.position);
    }

    if (options.quaternion) {
      this.quaternion.copy(options.quaternion);
    }
  }
  /**
   * Get a global point in local transform coordinates.
   */


  pointToLocal(worldPoint, result) {
    return Transform.pointToLocalFrame(this.position, this.quaternion, worldPoint, result);
  }
  /**
   * Get a local point in global transform coordinates.
   */


  pointToWorld(localPoint, result) {
    return Transform.pointToWorldFrame(this.position, this.quaternion, localPoint, result);
  }
  /**
   * vectorToWorldFrame
   */


  vectorToWorldFrame(localVector, result = new Vec3()) {
    this.quaternion.vmult(localVector, result);
    return result;
  }
  /**
   * pointToLocalFrame
   */


  static pointToLocalFrame(position, quaternion, worldPoint, result = new Vec3()) {
    worldPoint.vsub(position, result);
    quaternion.conjugate(tmpQuat$1);
    tmpQuat$1.vmult(result, result);
    return result;
  }
  /**
   * pointToWorldFrame
   */


  static pointToWorldFrame(position, quaternion, localPoint, result = new Vec3()) {
    quaternion.vmult(localPoint, result);
    result.vadd(position, result);
    return result;
  }
  /**
   * vectorToWorldFrame
   */


  static vectorToWorldFrame(quaternion, localVector, result = new Vec3()) {
    quaternion.vmult(localVector, result);
    return result;
  }
  /**
   * vectorToLocalFrame
   */


  static vectorToLocalFrame(position, quaternion, worldVector, result = new Vec3()) {
    quaternion.w *= -1;
    quaternion.vmult(worldVector, result);
    quaternion.w *= -1;
    return result;
  }

}
const tmpQuat$1 = new Quaternion();

/**
 * A set of polygons describing a convex shape.
 *
 * The shape MUST be convex for the code to work properly. No polygons may be coplanar (contained
 * in the same 3D plane), instead these should be merged into one polygon.
 *
 * @author qiao / https://github.com/qiao (original author, see https://github.com/qiao/three.js/commit/85026f0c769e4000148a67d45a9e9b9c5108836f)
 * @author schteppe / https://github.com/schteppe
 * @see https://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/
 *
 * @todo Move the clipping functions to ContactGenerator?
 * @todo Automatically merge coplanar polygons in constructor.
 * @example
 *     const convexShape = new CANNON.ConvexPolyhedron({ vertices, faces })
 *     const convexBody = new CANNON.Body({ mass: 1, shape: convexShape })
 *     world.addBody(convexBody)
 */
class ConvexPolyhedron extends Shape {
  /** vertices */

  /**
   * Array of integer arrays, indicating which vertices each face consists of
   */

  /** faceNormals */

  /** worldVertices */

  /** worldVerticesNeedsUpdate */

  /** worldFaceNormals */

  /** worldFaceNormalsNeedsUpdate */

  /**
   * If given, these locally defined, normalized axes are the only ones being checked when doing separating axis check.
   */

  /** uniqueEdges */

  /**
   * @param vertices An array of Vec3's
   * @param faces Array of integer arrays, describing which vertices that is included in each face.
   */
  constructor(props = {}) {
    const {
      vertices = [],
      faces = [],
      normals = [],
      axes,
      boundingSphereRadius
    } = props;
    super({
      type: Shape.types.CONVEXPOLYHEDRON
    });
    this.vertices = void 0;
    this.faces = void 0;
    this.faceNormals = void 0;
    this.worldVertices = void 0;
    this.worldVerticesNeedsUpdate = void 0;
    this.worldFaceNormals = void 0;
    this.worldFaceNormalsNeedsUpdate = void 0;
    this.uniqueAxes = void 0;
    this.uniqueEdges = void 0;
    this.vertices = vertices;
    this.faces = faces;
    this.faceNormals = normals;

    if (this.faceNormals.length === 0) {
      this.computeNormals();
    }

    if (!boundingSphereRadius) {
      this.updateBoundingSphereRadius();
    } else {
      this.boundingSphereRadius = boundingSphereRadius;
    }

    this.worldVertices = []; // World transformed version of .vertices

    this.worldVerticesNeedsUpdate = true;
    this.worldFaceNormals = []; // World transformed version of .faceNormals

    this.worldFaceNormalsNeedsUpdate = true;
    this.uniqueAxes = axes ? axes.slice() : null;
    this.uniqueEdges = [];
    this.computeEdges();
  }
  /**
   * Computes uniqueEdges
   */


  computeEdges() {
    const faces = this.faces;
    const vertices = this.vertices;
    const edges = this.uniqueEdges;
    edges.length = 0;
    const edge = new Vec3();

    for (let i = 0; i !== faces.length; i++) {
      const face = faces[i];
      const numVertices = face.length;

      for (let j = 0; j !== numVertices; j++) {
        const k = (j + 1) % numVertices;
        vertices[face[j]].vsub(vertices[face[k]], edge);
        edge.normalize();
        let found = false;

        for (let p = 0; p !== edges.length; p++) {
          if (edges[p].almostEquals(edge) || edges[p].almostEquals(edge)) {
            found = true;
            break;
          }
        }

        if (!found) {
          edges.push(edge.clone());
        }
      }
    }
  }
  /**
   * Compute the normals of the faces.
   * Will reuse existing Vec3 objects in the `faceNormals` array if they exist.
   */


  computeNormals() {
    this.faceNormals.length = this.faces.length; // Generate normals

    for (let i = 0; i < this.faces.length; i++) {
      // Check so all vertices exists for this face
      for (let j = 0; j < this.faces[i].length; j++) {
        if (!this.vertices[this.faces[i][j]]) {
          throw new Error("Vertex " + this.faces[i][j] + " not found!");
        }
      }

      const n = this.faceNormals[i] || new Vec3();
      this.getFaceNormal(i, n);
      n.negate(n);
      this.faceNormals[i] = n;
      const vertex = this.vertices[this.faces[i][0]];

      if (n.dot(vertex) < 0) {
        console.error(".faceNormals[" + i + "] = Vec3(" + n.toString() + ") looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.");

        for (let j = 0; j < this.faces[i].length; j++) {
          console.warn(".vertices[" + this.faces[i][j] + "] = Vec3(" + this.vertices[this.faces[i][j]].toString() + ")");
        }
      }
    }
  }
  /**
   * Compute the normal of a face from its vertices
   */


  getFaceNormal(i, target) {
    const f = this.faces[i];
    const va = this.vertices[f[0]];
    const vb = this.vertices[f[1]];
    const vc = this.vertices[f[2]];
    ConvexPolyhedron.computeNormal(va, vb, vc, target);
  }
  /**
   * Get face normal given 3 vertices
   */


  static computeNormal(va, vb, vc, target) {
    const cb = new Vec3();
    const ab = new Vec3();
    vb.vsub(va, ab);
    vc.vsub(vb, cb);
    cb.cross(ab, target);

    if (!target.isZero()) {
      target.normalize();
    }
  }
  /**
   * @param minDist Clamp distance
   * @param result The an array of contact point objects, see clipFaceAgainstHull
   */


  clipAgainstHull(posA, quatA, hullB, posB, quatB, separatingNormal, minDist, maxDist, result) {
    const WorldNormal = new Vec3();
    let closestFaceB = -1;
    let dmax = -Number.MAX_VALUE;

    for (let face = 0; face < hullB.faces.length; face++) {
      WorldNormal.copy(hullB.faceNormals[face]);
      quatB.vmult(WorldNormal, WorldNormal);
      const d = WorldNormal.dot(separatingNormal);

      if (d > dmax) {
        dmax = d;
        closestFaceB = face;
      }
    }

    const worldVertsB1 = [];

    for (let i = 0; i < hullB.faces[closestFaceB].length; i++) {
      const b = hullB.vertices[hullB.faces[closestFaceB][i]];
      const worldb = new Vec3();
      worldb.copy(b);
      quatB.vmult(worldb, worldb);
      posB.vadd(worldb, worldb);
      worldVertsB1.push(worldb);
    }

    if (closestFaceB >= 0) {
      this.clipFaceAgainstHull(separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist, result);
    }
  }
  /**
   * Find the separating axis between this hull and another
   * @param target The target vector to save the axis in
   * @return Returns false if a separation is found, else true
   */


  findSeparatingAxis(hullB, posA, quatA, posB, quatB, target, faceListA, faceListB) {
    const faceANormalWS3 = new Vec3();
    const Worldnormal1 = new Vec3();
    const deltaC = new Vec3();
    const worldEdge0 = new Vec3();
    const worldEdge1 = new Vec3();
    const Cross = new Vec3();
    let dmin = Number.MAX_VALUE;
    const hullA = this;

    if (!hullA.uniqueAxes) {
      const numFacesA = faceListA ? faceListA.length : hullA.faces.length; // Test face normals from hullA

      for (let i = 0; i < numFacesA; i++) {
        const fi = faceListA ? faceListA[i] : i; // Get world face normal

        faceANormalWS3.copy(hullA.faceNormals[fi]);
        quatA.vmult(faceANormalWS3, faceANormalWS3);
        const d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);

        if (d === false) {
          return false;
        }

        if (d < dmin) {
          dmin = d;
          target.copy(faceANormalWS3);
        }
      }
    } else {
      // Test unique axes
      for (let i = 0; i !== hullA.uniqueAxes.length; i++) {
        // Get world axis
        quatA.vmult(hullA.uniqueAxes[i], faceANormalWS3);
        const d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);

        if (d === false) {
          return false;
        }

        if (d < dmin) {
          dmin = d;
          target.copy(faceANormalWS3);
        }
      }
    }

    if (!hullB.uniqueAxes) {
      // Test face normals from hullB
      const numFacesB = faceListB ? faceListB.length : hullB.faces.length;

      for (let i = 0; i < numFacesB; i++) {
        const fi = faceListB ? faceListB[i] : i;
        Worldnormal1.copy(hullB.faceNormals[fi]);
        quatB.vmult(Worldnormal1, Worldnormal1);
        const d = hullA.testSepAxis(Worldnormal1, hullB, posA, quatA, posB, quatB);

        if (d === false) {
          return false;
        }

        if (d < dmin) {
          dmin = d;
          target.copy(Worldnormal1);
        }
      }
    } else {
      // Test unique axes in B
      for (let i = 0; i !== hullB.uniqueAxes.length; i++) {
        quatB.vmult(hullB.uniqueAxes[i], Worldnormal1);
        const d = hullA.testSepAxis(Worldnormal1, hullB, posA, quatA, posB, quatB);

        if (d === false) {
          return false;
        }

        if (d < dmin) {
          dmin = d;
          target.copy(Worldnormal1);
        }
      }
    } // Test edges


    for (let e0 = 0; e0 !== hullA.uniqueEdges.length; e0++) {
      // Get world edge
      quatA.vmult(hullA.uniqueEdges[e0], worldEdge0);

      for (let e1 = 0; e1 !== hullB.uniqueEdges.length; e1++) {
        // Get world edge 2
        quatB.vmult(hullB.uniqueEdges[e1], worldEdge1);
        worldEdge0.cross(worldEdge1, Cross);

        if (!Cross.almostZero()) {
          Cross.normalize();
          const dist = hullA.testSepAxis(Cross, hullB, posA, quatA, posB, quatB);

          if (dist === false) {
            return false;
          }

          if (dist < dmin) {
            dmin = dist;
            target.copy(Cross);
          }
        }
      }
    }

    posB.vsub(posA, deltaC);

    if (deltaC.dot(target) > 0.0) {
      target.negate(target);
    }

    return true;
  }
  /**
   * Test separating axis against two hulls. Both hulls are projected onto the axis and the overlap size is returned if there is one.
   * @return The overlap depth, or FALSE if no penetration.
   */


  testSepAxis(axis, hullB, posA, quatA, posB, quatB) {
    const hullA = this;
    ConvexPolyhedron.project(hullA, axis, posA, quatA, maxminA);
    ConvexPolyhedron.project(hullB, axis, posB, quatB, maxminB);
    const maxA = maxminA[0];
    const minA = maxminA[1];
    const maxB = maxminB[0];
    const minB = maxminB[1];

    if (maxA < minB || maxB < minA) {
      return false; // Separated
    }

    const d0 = maxA - minB;
    const d1 = maxB - minA;
    const depth = d0 < d1 ? d0 : d1;
    return depth;
  }
  /**
   * calculateLocalInertia
   */


  calculateLocalInertia(mass, target) {
    // Approximate with box inertia
    // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it
    const aabbmax = new Vec3();
    const aabbmin = new Vec3();
    this.computeLocalAABB(aabbmin, aabbmax);
    const x = aabbmax.x - aabbmin.x;
    const y = aabbmax.y - aabbmin.y;
    const z = aabbmax.z - aabbmin.z;
    target.x = 1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * z * 2 * z);
    target.y = 1.0 / 12.0 * mass * (2 * x * 2 * x + 2 * z * 2 * z);
    target.z = 1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * x * 2 * x);
  }
  /**
   * @param face_i Index of the face
   */


  getPlaneConstantOfFace(face_i) {
    const f = this.faces[face_i];
    const n = this.faceNormals[face_i];
    const v = this.vertices[f[0]];
    const c = -n.dot(v);
    return c;
  }
  /**
   * Clip a face against a hull.
   * @param worldVertsB1 An array of Vec3 with vertices in the world frame.
   * @param minDist Distance clamping
   * @param Array result Array to store resulting contact points in. Will be objects with properties: point, depth, normal. These are represented in world coordinates.
   */


  clipFaceAgainstHull(separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist, result) {
    const faceANormalWS = new Vec3();
    const edge0 = new Vec3();
    const WorldEdge0 = new Vec3();
    const worldPlaneAnormal1 = new Vec3();
    const planeNormalWS1 = new Vec3();
    const worldA1 = new Vec3();
    const localPlaneNormal = new Vec3();
    const planeNormalWS = new Vec3();
    const hullA = this;
    const worldVertsB2 = [];
    const pVtxIn = worldVertsB1;
    const pVtxOut = worldVertsB2;
    let closestFaceA = -1;
    let dmin = Number.MAX_VALUE; // Find the face with normal closest to the separating axis

    for (let face = 0; face < hullA.faces.length; face++) {
      faceANormalWS.copy(hullA.faceNormals[face]);
      quatA.vmult(faceANormalWS, faceANormalWS);
      const d = faceANormalWS.dot(separatingNormal);

      if (d < dmin) {
        dmin = d;
        closestFaceA = face;
      }
    }

    if (closestFaceA < 0) {
      return;
    } // Get the face and construct connected faces


    const polyA = hullA.faces[closestFaceA];
    polyA.connectedFaces = [];

    for (let i = 0; i < hullA.faces.length; i++) {
      for (let j = 0; j < hullA.faces[i].length; j++) {
        if (
        /* Sharing a vertex*/
        polyA.indexOf(hullA.faces[i][j]) !== -1 &&
        /* Not the one we are looking for connections from */
        i !== closestFaceA &&
        /* Not already added */
        polyA.connectedFaces.indexOf(i) === -1) {
          polyA.connectedFaces.push(i);
        }
      }
    } // Clip the polygon to the back of the planes of all faces of hull A,
    // that are adjacent to the witness face


    const numVerticesA = polyA.length;

    for (let i = 0; i < numVerticesA; i++) {
      const a = hullA.vertices[polyA[i]];
      const b = hullA.vertices[polyA[(i + 1) % numVerticesA]];
      a.vsub(b, edge0);
      WorldEdge0.copy(edge0);
      quatA.vmult(WorldEdge0, WorldEdge0);
      posA.vadd(WorldEdge0, WorldEdge0);
      worldPlaneAnormal1.copy(this.faceNormals[closestFaceA]);
      quatA.vmult(worldPlaneAnormal1, worldPlaneAnormal1);
      posA.vadd(worldPlaneAnormal1, worldPlaneAnormal1);
      WorldEdge0.cross(worldPlaneAnormal1, planeNormalWS1);
      planeNormalWS1.negate(planeNormalWS1);
      worldA1.copy(a);
      quatA.vmult(worldA1, worldA1);
      posA.vadd(worldA1, worldA1);
      const otherFace = polyA.connectedFaces[i];
      localPlaneNormal.copy(this.faceNormals[otherFace]);
      const localPlaneEq = this.getPlaneConstantOfFace(otherFace);
      planeNormalWS.copy(localPlaneNormal);
      quatA.vmult(planeNormalWS, planeNormalWS);
      const planeEqWS = localPlaneEq - planeNormalWS.dot(posA); // Clip face against our constructed plane

      this.clipFaceAgainstPlane(pVtxIn, pVtxOut, planeNormalWS, planeEqWS); // Throw away all clipped points, but save the remaining until next clip

      while (pVtxIn.length) {
        pVtxIn.shift();
      }

      while (pVtxOut.length) {
        pVtxIn.push(pVtxOut.shift());
      }
    } // only keep contact points that are behind the witness face


    localPlaneNormal.copy(this.faceNormals[closestFaceA]);
    const localPlaneEq = this.getPlaneConstantOfFace(closestFaceA);
    planeNormalWS.copy(localPlaneNormal);
    quatA.vmult(planeNormalWS, planeNormalWS);
    const planeEqWS = localPlaneEq - planeNormalWS.dot(posA);

    for (let i = 0; i < pVtxIn.length; i++) {
      let depth = planeNormalWS.dot(pVtxIn[i]) + planeEqWS; // ???

      if (depth <= minDist) {
        console.log("clamped: depth=" + depth + " to minDist=" + minDist);
        depth = minDist;
      }

      if (depth <= maxDist) {
        const point = pVtxIn[i];

        if (depth <= 1e-6) {
          const p = {
            point,
            normal: planeNormalWS,
            depth
          };
          result.push(p);
        }
      }
    }
  }
  /**
   * Clip a face in a hull against the back of a plane.
   * @param planeConstant The constant in the mathematical plane equation
   */


  clipFaceAgainstPlane(inVertices, outVertices, planeNormal, planeConstant) {
    let n_dot_first;
    let n_dot_last;
    const numVerts = inVertices.length;

    if (numVerts < 2) {
      return outVertices;
    }

    let firstVertex = inVertices[inVertices.length - 1];
    let lastVertex = inVertices[0];
    n_dot_first = planeNormal.dot(firstVertex) + planeConstant;

    for (let vi = 0; vi < numVerts; vi++) {
      lastVertex = inVertices[vi];
      n_dot_last = planeNormal.dot(lastVertex) + planeConstant;

      if (n_dot_first < 0) {
        if (n_dot_last < 0) {
          // Start < 0, end < 0, so output lastVertex
          const newv = new Vec3();
          newv.copy(lastVertex);
          outVertices.push(newv);
        } else {
          // Start < 0, end >= 0, so output intersection
          const newv = new Vec3();
          firstVertex.lerp(lastVertex, n_dot_first / (n_dot_first - n_dot_last), newv);
          outVertices.push(newv);
        }
      } else {
        if (n_dot_last < 0) {
          // Start >= 0, end < 0 so output intersection and end
          const newv = new Vec3();
          firstVertex.lerp(lastVertex, n_dot_first / (n_dot_first - n_dot_last), newv);
          outVertices.push(newv);
          outVertices.push(lastVertex);
        }
      }

      firstVertex = lastVertex;
      n_dot_first = n_dot_last;
    }

    return outVertices;
  }
  /**
   * Updates `.worldVertices` and sets `.worldVerticesNeedsUpdate` to false.
   */


  computeWorldVertices(position, quat) {
    while (this.worldVertices.length < this.vertices.length) {
      this.worldVertices.push(new Vec3());
    }

    const verts = this.vertices;
    const worldVerts = this.worldVertices;

    for (let i = 0; i !== this.vertices.length; i++) {
      quat.vmult(verts[i], worldVerts[i]);
      position.vadd(worldVerts[i], worldVerts[i]);
    }

    this.worldVerticesNeedsUpdate = false;
  }

  computeLocalAABB(aabbmin, aabbmax) {
    const vertices = this.vertices;
    aabbmin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    aabbmax.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);

    for (let i = 0; i < this.vertices.length; i++) {
      const v = vertices[i];

      if (v.x < aabbmin.x) {
        aabbmin.x = v.x;
      } else if (v.x > aabbmax.x) {
        aabbmax.x = v.x;
      }

      if (v.y < aabbmin.y) {
        aabbmin.y = v.y;
      } else if (v.y > aabbmax.y) {
        aabbmax.y = v.y;
      }

      if (v.z < aabbmin.z) {
        aabbmin.z = v.z;
      } else if (v.z > aabbmax.z) {
        aabbmax.z = v.z;
      }
    }
  }
  /**
   * Updates `worldVertices` and sets `worldVerticesNeedsUpdate` to false.
   */


  computeWorldFaceNormals(quat) {
    const N = this.faceNormals.length;

    while (this.worldFaceNormals.length < N) {
      this.worldFaceNormals.push(new Vec3());
    }

    const normals = this.faceNormals;
    const worldNormals = this.worldFaceNormals;

    for (let i = 0; i !== N; i++) {
      quat.vmult(normals[i], worldNormals[i]);
    }

    this.worldFaceNormalsNeedsUpdate = false;
  }
  /**
   * updateBoundingSphereRadius
   */


  updateBoundingSphereRadius() {
    // Assume points are distributed with local (0,0,0) as center
    let max2 = 0;
    const verts = this.vertices;

    for (let i = 0; i !== verts.length; i++) {
      const norm2 = verts[i].lengthSquared();

      if (norm2 > max2) {
        max2 = norm2;
      }
    }

    this.boundingSphereRadius = Math.sqrt(max2);
  }
  /**
   * calculateWorldAABB
   */


  calculateWorldAABB(pos, quat, min, max) {
    const verts = this.vertices;
    let minx;
    let miny;
    let minz;
    let maxx;
    let maxy;
    let maxz;
    let tempWorldVertex = new Vec3();

    for (let i = 0; i < verts.length; i++) {
      tempWorldVertex.copy(verts[i]);
      quat.vmult(tempWorldVertex, tempWorldVertex);
      pos.vadd(tempWorldVertex, tempWorldVertex);
      const v = tempWorldVertex;

      if (minx === undefined || v.x < minx) {
        minx = v.x;
      }

      if (maxx === undefined || v.x > maxx) {
        maxx = v.x;
      }

      if (miny === undefined || v.y < miny) {
        miny = v.y;
      }

      if (maxy === undefined || v.y > maxy) {
        maxy = v.y;
      }

      if (minz === undefined || v.z < minz) {
        minz = v.z;
      }

      if (maxz === undefined || v.z > maxz) {
        maxz = v.z;
      }
    }

    min.set(minx, miny, minz);
    max.set(maxx, maxy, maxz);
  }
  /**
   * Get approximate convex volume
   */


  volume() {
    return 4.0 * Math.PI * this.boundingSphereRadius / 3.0;
  }
  /**
   * Get an average of all the vertices positions
   */


  getAveragePointLocal(target = new Vec3()) {
    const verts = this.vertices;

    for (let i = 0; i < verts.length; i++) {
      target.vadd(verts[i], target);
    }

    target.scale(1 / verts.length, target);
    return target;
  }
  /**
   * Transform all local points. Will change the .vertices
   */


  transformAllPoints(offset, quat) {
    const n = this.vertices.length;
    const verts = this.vertices; // Apply rotation

    if (quat) {
      // Rotate vertices
      for (let i = 0; i < n; i++) {
        const v = verts[i];
        quat.vmult(v, v);
      } // Rotate face normals


      for (let i = 0; i < this.faceNormals.length; i++) {
        const v = this.faceNormals[i];
        quat.vmult(v, v);
      }
      /*
            // Rotate edges
            for(let i=0; i<this.uniqueEdges.length; i++){
                const v = this.uniqueEdges[i];
                quat.vmult(v,v);
            }*/

    } // Apply offset


    if (offset) {
      for (let i = 0; i < n; i++) {
        const v = verts[i];
        v.vadd(offset, v);
      }
    }
  }
  /**
   * Checks whether p is inside the polyhedra. Must be in local coords.
   * The point lies outside of the convex hull of the other points if and only if the direction
   * of all the vectors from it to those other points are on less than one half of a sphere around it.
   * @param p A point given in local coordinates
   */


  pointIsInside(p) {
    const verts = this.vertices;
    const faces = this.faces;
    const normals = this.faceNormals;
    const pointInside = new Vec3();
    this.getAveragePointLocal(pointInside);

    for (let i = 0; i < this.faces.length; i++) {
      let n = normals[i];
      const v = verts[faces[i][0]]; // We only need one point in the face
      // This dot product determines which side of the edge the point is

      const vToP = new Vec3();
      p.vsub(v, vToP);
      const r1 = n.dot(vToP);
      const vToPointInside = new Vec3();
      pointInside.vsub(v, vToPointInside);
      const r2 = n.dot(vToPointInside);

      if (r1 < 0 && r2 > 0 || r1 > 0 && r2 < 0) {
        return false; // Encountered some other sign. Exit.
      }
    } // If we got here, all dot products were of the same sign.


    return -1;
  }
  /**
   * Get max and min dot product of a convex hull at position (pos,quat) projected onto an axis.
   * Results are saved in the array maxmin.
   * @param result result[0] and result[1] will be set to maximum and minimum, respectively.
   */


  static project(shape, axis, pos, quat, result) {
    const n = shape.vertices.length;
    const localAxis = project_localAxis;
    let max = 0;
    let min = 0;
    const localOrigin = project_localOrigin;
    const vs = shape.vertices;
    localOrigin.setZero(); // Transform the axis to local

    Transform.vectorToLocalFrame(pos, quat, axis, localAxis);
    Transform.pointToLocalFrame(pos, quat, localOrigin, localOrigin);
    const add = localOrigin.dot(localAxis);
    min = max = vs[0].dot(localAxis);

    for (let i = 1; i < n; i++) {
      const val = vs[i].dot(localAxis);

      if (val > max) {
        max = val;
      }

      if (val < min) {
        min = val;
      }
    }

    min -= add;
    max -= add;

    if (min > max) {
      // Inconsistent - swap
      const temp = min;
      min = max;
      max = temp;
    } // Output


    result[0] = max;
    result[1] = min;
  }

}
const maxminA = [];
const maxminB = [];
const project_localAxis = new Vec3();
const project_localOrigin = new Vec3();

/**
 * A 3d box shape.
 * @example
 *     const size = 1
 *     const halfExtents = new CANNON.Vec3(size, size, size)
 *     const boxShape = new CANNON.Box(halfExtents)
 *     const boxBody = new CANNON.Body({ mass: 1, shape: boxShape })
 *     world.addBody(boxBody)
 */
class Box extends Shape {
  /**
   * The half extents of the box.
   */

  /**
   * Used by the contact generator to make contacts with other convex polyhedra for example.
   */
  constructor(halfExtents) {
    super({
      type: Shape.types.BOX
    });
    this.halfExtents = void 0;
    this.convexPolyhedronRepresentation = void 0;
    this.halfExtents = halfExtents;
    this.convexPolyhedronRepresentation = null;
    this.updateConvexPolyhedronRepresentation();
    this.updateBoundingSphereRadius();
  }
  /**
   * Updates the local convex polyhedron representation used for some collisions.
   */


  updateConvexPolyhedronRepresentation() {
    const sx = this.halfExtents.x;
    const sy = this.halfExtents.y;
    const sz = this.halfExtents.z;
    const V = Vec3;
    const vertices = [new V(-sx, -sy, -sz), new V(sx, -sy, -sz), new V(sx, sy, -sz), new V(-sx, sy, -sz), new V(-sx, -sy, sz), new V(sx, -sy, sz), new V(sx, sy, sz), new V(-sx, sy, sz)];
    const faces = [[3, 2, 1, 0], // -z
    [4, 5, 6, 7], // +z
    [5, 4, 0, 1], // -y
    [2, 3, 7, 6], // +y
    [0, 4, 7, 3], // -x
    [1, 2, 6, 5] // +x
    ];
    const axes = [new V(0, 0, 1), new V(0, 1, 0), new V(1, 0, 0)];
    const h = new ConvexPolyhedron({
      vertices,
      faces,
      axes
    });
    this.convexPolyhedronRepresentation = h;
    h.material = this.material;
  }
  /**
   * Calculate the inertia of the box.
   */


  calculateLocalInertia(mass, target = new Vec3()) {
    Box.calculateInertia(this.halfExtents, mass, target);
    return target;
  }

  static calculateInertia(halfExtents, mass, target) {
    const e = halfExtents;
    target.x = 1.0 / 12.0 * mass * (2 * e.y * 2 * e.y + 2 * e.z * 2 * e.z);
    target.y = 1.0 / 12.0 * mass * (2 * e.x * 2 * e.x + 2 * e.z * 2 * e.z);
    target.z = 1.0 / 12.0 * mass * (2 * e.y * 2 * e.y + 2 * e.x * 2 * e.x);
  }
  /**
   * Get the box 6 side normals
   * @param sixTargetVectors An array of 6 vectors, to store the resulting side normals in.
   * @param quat Orientation to apply to the normal vectors. If not provided, the vectors will be in respect to the local frame.
   */


  getSideNormals(sixTargetVectors, quat) {
    const sides = sixTargetVectors;
    const ex = this.halfExtents;
    sides[0].set(ex.x, 0, 0);
    sides[1].set(0, ex.y, 0);
    sides[2].set(0, 0, ex.z);
    sides[3].set(-ex.x, 0, 0);
    sides[4].set(0, -ex.y, 0);
    sides[5].set(0, 0, -ex.z);

    if (quat !== undefined) {
      for (let i = 0; i !== sides.length; i++) {
        quat.vmult(sides[i], sides[i]);
      }
    }

    return sides;
  }
  /**
   * Returns the volume of the box.
   */


  volume() {
    return 8.0 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z;
  }
  /**
   * updateBoundingSphereRadius
   */


  updateBoundingSphereRadius() {
    this.boundingSphereRadius = this.halfExtents.length();
  }
  /**
   * forEachWorldCorner
   */


  forEachWorldCorner(pos, quat, callback) {
    const e = this.halfExtents;
    const corners = [[e.x, e.y, e.z], [-e.x, e.y, e.z], [-e.x, -e.y, e.z], [-e.x, -e.y, -e.z], [e.x, -e.y, -e.z], [e.x, e.y, -e.z], [-e.x, e.y, -e.z], [e.x, -e.y, e.z]];

    for (let i = 0; i < corners.length; i++) {
      worldCornerTempPos.set(corners[i][0], corners[i][1], corners[i][2]);
      quat.vmult(worldCornerTempPos, worldCornerTempPos);
      pos.vadd(worldCornerTempPos, worldCornerTempPos);
      callback(worldCornerTempPos.x, worldCornerTempPos.y, worldCornerTempPos.z);
    }
  }
  /**
   * calculateWorldAABB
   */


  calculateWorldAABB(pos, quat, min, max) {
    const e = this.halfExtents;
    worldCornersTemp[0].set(e.x, e.y, e.z);
    worldCornersTemp[1].set(-e.x, e.y, e.z);
    worldCornersTemp[2].set(-e.x, -e.y, e.z);
    worldCornersTemp[3].set(-e.x, -e.y, -e.z);
    worldCornersTemp[4].set(e.x, -e.y, -e.z);
    worldCornersTemp[5].set(e.x, e.y, -e.z);
    worldCornersTemp[6].set(-e.x, e.y, -e.z);
    worldCornersTemp[7].set(e.x, -e.y, e.z);
    const wc = worldCornersTemp[0];
    quat.vmult(wc, wc);
    pos.vadd(wc, wc);
    max.copy(wc);
    min.copy(wc);

    for (let i = 1; i < 8; i++) {
      const wc = worldCornersTemp[i];
      quat.vmult(wc, wc);
      pos.vadd(wc, wc);
      const x = wc.x;
      const y = wc.y;
      const z = wc.z;

      if (x > max.x) {
        max.x = x;
      }

      if (y > max.y) {
        max.y = y;
      }

      if (z > max.z) {
        max.z = z;
      }

      if (x < min.x) {
        min.x = x;
      }

      if (y < min.y) {
        min.y = y;
      }

      if (z < min.z) {
        min.z = z;
      }
    } // Get each axis max
    // min.set(Infinity,Infinity,Infinity);
    // max.set(-Infinity,-Infinity,-Infinity);
    // this.forEachWorldCorner(pos,quat,function(x,y,z){
    //     if(x > max.x){
    //         max.x = x;
    //     }
    //     if(y > max.y){
    //         max.y = y;
    //     }
    //     if(z > max.z){
    //         max.z = z;
    //     }
    //     if(x < min.x){
    //         min.x = x;
    //     }
    //     if(y < min.y){
    //         min.y = y;
    //     }
    //     if(z < min.z){
    //         min.z = z;
    //     }
    // });

  }

}
const worldCornerTempPos = new Vec3();
const worldCornersTemp = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];

/**
 * BODY_TYPES
 */
const BODY_TYPES = {
  /** DYNAMIC */
  DYNAMIC: 1,

  /** STATIC */
  STATIC: 2,

  /** KINEMATIC */
  KINEMATIC: 4
};
/**
 * BodyType
 */

/**
 * BODY_SLEEP_STATES
 */
const BODY_SLEEP_STATES = {
  /** AWAKE */
  AWAKE: 0,

  /** SLEEPY */
  SLEEPY: 1,

  /** SLEEPING */
  SLEEPING: 2
};
/**
 * BodySleepState
 */

/**
 * Base class for all body types.
 * @example
 *     const shape = new CANNON.Sphere(1)
 *     const body = new CANNON.Body({
 *       mass: 1,
 *       shape,
 *     })
 *     world.addBody(body)
 */
class Body extends EventTarget {
  /**
   * Dispatched after two bodies collide. This event is dispatched on each
   * of the two bodies involved in the collision.
   * @event collide
   * @param body The body that was involved in the collision.
   * @param contact The details of the collision.
   */

  /**
   * A dynamic body is fully simulated. Can be moved manually by the user, but normally they move according to forces. A dynamic body can collide with all body types. A dynamic body always has finite, non-zero mass.
   */

  /**
   * A static body does not move during simulation and behaves as if it has infinite mass. Static bodies can be moved manually by setting the position of the body. The velocity of a static body is always zero. Static bodies do not collide with other static or kinematic bodies.
   */

  /**
   * A kinematic body moves under simulation according to its velocity. They do not respond to forces. They can be moved manually, but normally a kinematic body is moved by setting its velocity. A kinematic body behaves as if it has infinite mass. Kinematic bodies do not collide with other static or kinematic bodies.
   */

  /**
   * AWAKE
   */

  /**
   * SLEEPY
   */

  /**
   * SLEEPING
   */

  /**
   * Dispatched after a sleeping body has woken up.
   * @event wakeup
   */

  /**
   * Dispatched after a body has gone in to the sleepy state.
   * @event sleepy
   */

  /**
   * Dispatched after a body has fallen asleep.
   * @event sleep
   */

  /**
   * Identifier of the body.
   */

  /**
   * Position of body in World.bodies. Updated by World and used in ArrayCollisionMatrix.
   */

  /**
   * Reference to the world the body is living in.
   */

  /**
   * Callback function that is used BEFORE stepping the system. Use it to apply forces, for example. Inside the function, "this" will refer to this Body object. Deprecated - use World events instead.
   * @deprecated Use World events instead
   */

  /**
   * Callback function that is used AFTER stepping the system. Inside the function, "this" will refer to this Body object. Deprecated - use World events instead.
   * @deprecated Use World events instead
   */

  /**
   * The collision group the body belongs to.
   * @default 1
   */

  /**
   * The collision group the body can collide with.
   * @default -1
   */

  /**
   * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled - i.e. "collide" events will be raised, but forces will not be altered.
   */

  /**
   * World space position of the body.
   */

  /**
   * Interpolated position of the body.
   */

  /**
   * Initial position of the body.
   */

  /**
   * World space velocity of the body.
   */

  /**
   * Initial velocity of the body.
   */

  /**
   * Linear force on the body in world space.
   */

  /**
   * The mass of the body.
   * @default 0
   */

  /**
   * The physics material of the body. It defines the body interaction with other bodies.
   */

  /**
   * How much to damp the body velocity each step. It can go from 0 to 1.
   * @default 0.01
   */

  /**
   * One of: `Body.DYNAMIC`, `Body.STATIC` and `Body.KINEMATIC`.
   */

  /**
   * If true, the body will automatically fall to sleep.
   * @default true
   */

  /**
   * Current sleep state.
   */

  /**
   * If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.
   * @default 0.1
   */

  /**
   * If the body has been sleepy for this sleepTimeLimit seconds, it is considered sleeping.
   * @default 1
   */

  /**
   * World space rotational force on the body, around center of mass.
   */

  /**
   * World space orientation of the body.
   */

  /**
   * Initial quaternion of the body.
   */

  /**
   * Interpolated orientation of the body.
   */

  /**
   * Angular velocity of the body, in world space. Think of the angular velocity as a vector, which the body rotates around. The length of this vector determines how fast (in radians per second) the body rotates.
   */

  /**
   * Initial angular velocity of the body.
   */

  /**
   * List of Shapes that have been added to the body.
   */

  /**
   * Position of each Shape in the body, given in local Body space.
   */

  /**
   * Orientation of each Shape, given in local Body space.
   */

  /**
   * The inertia of the body.
   */

  /**
   * Set to true if you don't want the body to rotate. Make sure to run .updateMassProperties() if you change this after the body creation.
   * @default false
   */

  /**
   * How much to damp the body angular velocity each step. It can go from 0 to 1.
   * @default 0.01
   */

  /**
   * Use this property to limit the motion along any world axis. (1,1,1) will allow motion along all axes while (0,0,0) allows none.
   */

  /**
   * Use this property to limit the rotational motion along any world axis. (1,1,1) will allow rotation along all axes while (0,0,0) allows none.
   */

  /**
   * World space bounding box of the body and its shapes.
   */

  /**
   * Indicates if the AABB needs to be updated before use.
   */

  /**
   * Total bounding radius of the Body including its shapes, relative to body.position.
   */

  /**
   * When true the body behaves like a trigger. It does not collide
   * with other bodies but collision events are still triggered.
   * @default false
   */
  constructor(options = {}) {
    super();
    this.id = void 0;
    this.index = void 0;
    this.world = void 0;
    this.preStep = void 0;
    this.postStep = void 0;
    this.vlambda = void 0;
    this.collisionFilterGroup = void 0;
    this.collisionFilterMask = void 0;
    this.collisionResponse = void 0;
    this.position = void 0;
    this.previousPosition = void 0;
    this.interpolatedPosition = void 0;
    this.initPosition = void 0;
    this.velocity = void 0;
    this.initVelocity = void 0;
    this.force = void 0;
    this.mass = void 0;
    this.invMass = void 0;
    this.material = void 0;
    this.linearDamping = void 0;
    this.type = void 0;
    this.allowSleep = void 0;
    this.sleepState = void 0;
    this.sleepSpeedLimit = void 0;
    this.sleepTimeLimit = void 0;
    this.timeLastSleepy = void 0;
    this.wakeUpAfterNarrowphase = void 0;
    this.torque = void 0;
    this.quaternion = void 0;
    this.initQuaternion = void 0;
    this.previousQuaternion = void 0;
    this.interpolatedQuaternion = void 0;
    this.angularVelocity = void 0;
    this.initAngularVelocity = void 0;
    this.shapes = void 0;
    this.shapeOffsets = void 0;
    this.shapeOrientations = void 0;
    this.inertia = void 0;
    this.invInertia = void 0;
    this.invInertiaWorld = void 0;
    this.invMassSolve = void 0;
    this.invInertiaSolve = void 0;
    this.invInertiaWorldSolve = void 0;
    this.fixedRotation = void 0;
    this.angularDamping = void 0;
    this.linearFactor = void 0;
    this.angularFactor = void 0;
    this.aabb = void 0;
    this.aabbNeedsUpdate = void 0;
    this.boundingRadius = void 0;
    this.wlambda = void 0;
    this.isTrigger = void 0;
    this.id = Body.idCounter++;
    this.index = -1;
    this.world = null;
    this.preStep = null;
    this.postStep = null;
    this.vlambda = new Vec3();
    this.collisionFilterGroup = typeof options.collisionFilterGroup === 'number' ? options.collisionFilterGroup : 1;
    this.collisionFilterMask = typeof options.collisionFilterMask === 'number' ? options.collisionFilterMask : -1;
    this.collisionResponse = typeof options.collisionResponse === 'boolean' ? options.collisionResponse : true;
    this.position = new Vec3();
    this.previousPosition = new Vec3();
    this.interpolatedPosition = new Vec3();
    this.initPosition = new Vec3();

    if (options.position) {
      this.position.copy(options.position);
      this.previousPosition.copy(options.position);
      this.interpolatedPosition.copy(options.position);
      this.initPosition.copy(options.position);
    }

    this.velocity = new Vec3();

    if (options.velocity) {
      this.velocity.copy(options.velocity);
    }

    this.initVelocity = new Vec3();
    this.force = new Vec3();
    const mass = typeof options.mass === 'number' ? options.mass : 0;
    this.mass = mass;
    this.invMass = mass > 0 ? 1.0 / mass : 0;
    this.material = options.material || null;
    this.linearDamping = typeof options.linearDamping === 'number' ? options.linearDamping : 0.01;
    this.type = mass <= 0.0 ? Body.STATIC : Body.DYNAMIC;

    if (typeof options.type === typeof Body.STATIC) {
      this.type = options.type;
    }

    this.allowSleep = typeof options.allowSleep !== 'undefined' ? options.allowSleep : true;
    this.sleepState = Body.AWAKE;
    this.sleepSpeedLimit = typeof options.sleepSpeedLimit !== 'undefined' ? options.sleepSpeedLimit : 0.1;
    this.sleepTimeLimit = typeof options.sleepTimeLimit !== 'undefined' ? options.sleepTimeLimit : 1;
    this.timeLastSleepy = 0;
    this.wakeUpAfterNarrowphase = false;
    this.torque = new Vec3();
    this.quaternion = new Quaternion();
    this.initQuaternion = new Quaternion();
    this.previousQuaternion = new Quaternion();
    this.interpolatedQuaternion = new Quaternion();

    if (options.quaternion) {
      this.quaternion.copy(options.quaternion);
      this.initQuaternion.copy(options.quaternion);
      this.previousQuaternion.copy(options.quaternion);
      this.interpolatedQuaternion.copy(options.quaternion);
    }

    this.angularVelocity = new Vec3();

    if (options.angularVelocity) {
      this.angularVelocity.copy(options.angularVelocity);
    }

    this.initAngularVelocity = new Vec3();
    this.shapes = [];
    this.shapeOffsets = [];
    this.shapeOrientations = [];
    this.inertia = new Vec3();
    this.invInertia = new Vec3();
    this.invInertiaWorld = new Mat3();
    this.invMassSolve = 0;
    this.invInertiaSolve = new Vec3();
    this.invInertiaWorldSolve = new Mat3();
    this.fixedRotation = typeof options.fixedRotation !== 'undefined' ? options.fixedRotation : false;
    this.angularDamping = typeof options.angularDamping !== 'undefined' ? options.angularDamping : 0.01;
    this.linearFactor = new Vec3(1, 1, 1);

    if (options.linearFactor) {
      this.linearFactor.copy(options.linearFactor);
    }

    this.angularFactor = new Vec3(1, 1, 1);

    if (options.angularFactor) {
      this.angularFactor.copy(options.angularFactor);
    }

    this.aabb = new AABB();
    this.aabbNeedsUpdate = true;
    this.boundingRadius = 0;
    this.wlambda = new Vec3();
    this.isTrigger = Boolean(options.isTrigger);

    if (options.shape) {
      this.addShape(options.shape);
    }

    this.updateMassProperties();
  }
  /**
   * Wake the body up.
   */


  wakeUp() {
    const prevState = this.sleepState;
    this.sleepState = Body.AWAKE;
    this.wakeUpAfterNarrowphase = false;

    if (prevState === Body.SLEEPING) {
      this.dispatchEvent(Body.wakeupEvent);
    }
  }
  /**
   * Force body sleep
   */


  sleep() {
    this.sleepState = Body.SLEEPING;
    this.velocity.set(0, 0, 0);
    this.angularVelocity.set(0, 0, 0);
    this.wakeUpAfterNarrowphase = false;
  }
  /**
   * Called every timestep to update internal sleep timer and change sleep state if needed.
   * @param time The world time in seconds
   */


  sleepTick(time) {
    if (this.allowSleep) {
      const sleepState = this.sleepState;
      const speedSquared = this.velocity.lengthSquared() + this.angularVelocity.lengthSquared();
      const speedLimitSquared = this.sleepSpeedLimit ** 2;

      if (sleepState === Body.AWAKE && speedSquared < speedLimitSquared) {
        this.sleepState = Body.SLEEPY; // Sleepy

        this.timeLastSleepy = time;
        this.dispatchEvent(Body.sleepyEvent);
      } else if (sleepState === Body.SLEEPY && speedSquared > speedLimitSquared) {
        this.wakeUp(); // Wake up
      } else if (sleepState === Body.SLEEPY && time - this.timeLastSleepy > this.sleepTimeLimit) {
        this.sleep(); // Sleeping

        this.dispatchEvent(Body.sleepEvent);
      }
    }
  }
  /**
   * If the body is sleeping, it should be immovable / have infinite mass during solve. We solve it by having a separate "solve mass".
   */


  updateSolveMassProperties() {
    if (this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC) {
      this.invMassSolve = 0;
      this.invInertiaSolve.setZero();
      this.invInertiaWorldSolve.setZero();
    } else {
      this.invMassSolve = this.invMass;
      this.invInertiaSolve.copy(this.invInertia);
      this.invInertiaWorldSolve.copy(this.invInertiaWorld);
    }
  }
  /**
   * Convert a world point to local body frame.
   */


  pointToLocalFrame(worldPoint, result = new Vec3()) {
    worldPoint.vsub(this.position, result);
    this.quaternion.conjugate().vmult(result, result);
    return result;
  }
  /**
   * Convert a world vector to local body frame.
   */


  vectorToLocalFrame(worldVector, result = new Vec3()) {
    this.quaternion.conjugate().vmult(worldVector, result);
    return result;
  }
  /**
   * Convert a local body point to world frame.
   */


  pointToWorldFrame(localPoint, result = new Vec3()) {
    this.quaternion.vmult(localPoint, result);
    result.vadd(this.position, result);
    return result;
  }
  /**
   * Convert a local body point to world frame.
   */


  vectorToWorldFrame(localVector, result = new Vec3()) {
    this.quaternion.vmult(localVector, result);
    return result;
  }
  /**
   * Add a shape to the body with a local offset and orientation.
   * @return The body object, for chainability.
   */


  addShape(shape, _offset, _orientation) {
    const offset = new Vec3();
    const orientation = new Quaternion();

    if (_offset) {
      offset.copy(_offset);
    }

    if (_orientation) {
      orientation.copy(_orientation);
    }

    this.shapes.push(shape);
    this.shapeOffsets.push(offset);
    this.shapeOrientations.push(orientation);
    this.updateMassProperties();
    this.updateBoundingRadius();
    this.aabbNeedsUpdate = true;
    shape.body = this;
    return this;
  }
  /**
   * Remove a shape from the body.
   * @return The body object, for chainability.
   */


  removeShape(shape) {
    const index = this.shapes.indexOf(shape);

    if (index === -1) {
      console.warn('Shape does not belong to the body');
      return this;
    }

    this.shapes.splice(index, 1);
    this.shapeOffsets.splice(index, 1);
    this.shapeOrientations.splice(index, 1);
    this.updateMassProperties();
    this.updateBoundingRadius();
    this.aabbNeedsUpdate = true;
    shape.body = null;
    return this;
  }
  /**
   * Update the bounding radius of the body. Should be done if any of the shapes are changed.
   */


  updateBoundingRadius() {
    const shapes = this.shapes;
    const shapeOffsets = this.shapeOffsets;
    const N = shapes.length;
    let radius = 0;

    for (let i = 0; i !== N; i++) {
      const shape = shapes[i];
      shape.updateBoundingSphereRadius();
      const offset = shapeOffsets[i].length();
      const r = shape.boundingSphereRadius;

      if (offset + r > radius) {
        radius = offset + r;
      }
    }

    this.boundingRadius = radius;
  }
  /**
   * Updates the .aabb
   */


  updateAABB() {
    const shapes = this.shapes;
    const shapeOffsets = this.shapeOffsets;
    const shapeOrientations = this.shapeOrientations;
    const N = shapes.length;
    const offset = tmpVec;
    const orientation = tmpQuat;
    const bodyQuat = this.quaternion;
    const aabb = this.aabb;
    const shapeAABB = updateAABB_shapeAABB;

    for (let i = 0; i !== N; i++) {
      const shape = shapes[i]; // Get shape world position

      bodyQuat.vmult(shapeOffsets[i], offset);
      offset.vadd(this.position, offset); // Get shape world quaternion

      bodyQuat.mult(shapeOrientations[i], orientation); // Get shape AABB

      shape.calculateWorldAABB(offset, orientation, shapeAABB.lowerBound, shapeAABB.upperBound);

      if (i === 0) {
        aabb.copy(shapeAABB);
      } else {
        aabb.extend(shapeAABB);
      }
    }

    this.aabbNeedsUpdate = false;
  }
  /**
   * Update `.inertiaWorld` and `.invInertiaWorld`
   */


  updateInertiaWorld(force) {
    const I = this.invInertia;

    if (I.x === I.y && I.y === I.z && !force) ; else {
      const m1 = uiw_m1;
      const m2 = uiw_m2;
      m1.setRotationFromQuaternion(this.quaternion);
      m1.transpose(m2);
      m1.scale(I, m1);
      m1.mmult(m2, this.invInertiaWorld);
    }
  }
  /**
   * Apply force to a point of the body. This could for example be a point on the Body surface.
   * Applying force this way will add to Body.force and Body.torque.
   * @param force The amount of force to add.
   * @param relativePoint A point relative to the center of mass to apply the force on.
   */


  applyForce(force, relativePoint = new Vec3()) {
    // Needed?
    if (this.type !== Body.DYNAMIC) {
      return;
    }

    if (this.sleepState === Body.SLEEPING) {
      this.wakeUp();
    } // Compute produced rotational force


    const rotForce = Body_applyForce_rotForce;
    relativePoint.cross(force, rotForce); // Add linear force

    this.force.vadd(force, this.force); // Add rotational force

    this.torque.vadd(rotForce, this.torque);
  }
  /**
   * Apply force to a local point in the body.
   * @param force The force vector to apply, defined locally in the body frame.
   * @param localPoint A local point in the body to apply the force on.
   */


  applyLocalForce(localForce, localPoint = new Vec3()) {
    if (this.type !== Body.DYNAMIC) {
      return;
    }

    const worldForce = Body_applyLocalForce_worldForce;
    const relativePointWorld = Body_applyLocalForce_relativePointWorld; // Transform the force vector to world space

    this.vectorToWorldFrame(localForce, worldForce);
    this.vectorToWorldFrame(localPoint, relativePointWorld);
    this.applyForce(worldForce, relativePointWorld);
  }
  /**
   * Apply torque to the body.
   * @param torque The amount of torque to add.
   */


  applyTorque(torque) {
    if (this.type !== Body.DYNAMIC) {
      return;
    }

    if (this.sleepState === Body.SLEEPING) {
      this.wakeUp();
    } // Add rotational force


    this.torque.vadd(torque, this.torque);
  }
  /**
   * Apply impulse to a point of the body. This could for example be a point on the Body surface.
   * An impulse is a force added to a body during a short period of time (impulse = force * time).
   * Impulses will be added to Body.velocity and Body.angularVelocity.
   * @param impulse The amount of impulse to add.
   * @param relativePoint A point relative to the center of mass to apply the force on.
   */


  applyImpulse(impulse, relativePoint = new Vec3()) {
    if (this.type !== Body.DYNAMIC) {
      return;
    }

    if (this.sleepState === Body.SLEEPING) {
      this.wakeUp();
    } // Compute point position relative to the body center


    const r = relativePoint; // Compute produced central impulse velocity

    const velo = Body_applyImpulse_velo;
    velo.copy(impulse);
    velo.scale(this.invMass, velo); // Add linear impulse

    this.velocity.vadd(velo, this.velocity); // Compute produced rotational impulse velocity

    const rotVelo = Body_applyImpulse_rotVelo;
    r.cross(impulse, rotVelo);
    /*
     rotVelo.x *= this.invInertia.x;
     rotVelo.y *= this.invInertia.y;
     rotVelo.z *= this.invInertia.z;
     */

    this.invInertiaWorld.vmult(rotVelo, rotVelo); // Add rotational Impulse

    this.angularVelocity.vadd(rotVelo, this.angularVelocity);
  }
  /**
   * Apply locally-defined impulse to a local point in the body.
   * @param force The force vector to apply, defined locally in the body frame.
   * @param localPoint A local point in the body to apply the force on.
   */


  applyLocalImpulse(localImpulse, localPoint = new Vec3()) {
    if (this.type !== Body.DYNAMIC) {
      return;
    }

    const worldImpulse = Body_applyLocalImpulse_worldImpulse;
    const relativePointWorld = Body_applyLocalImpulse_relativePoint; // Transform the force vector to world space

    this.vectorToWorldFrame(localImpulse, worldImpulse);
    this.vectorToWorldFrame(localPoint, relativePointWorld);
    this.applyImpulse(worldImpulse, relativePointWorld);
  }
  /**
   * Should be called whenever you change the body shape or mass.
   */


  updateMassProperties() {
    const halfExtents = Body_updateMassProperties_halfExtents;
    this.invMass = this.mass > 0 ? 1.0 / this.mass : 0;
    const I = this.inertia;
    const fixed = this.fixedRotation; // Approximate with AABB box

    this.updateAABB();
    halfExtents.set((this.aabb.upperBound.x - this.aabb.lowerBound.x) / 2, (this.aabb.upperBound.y - this.aabb.lowerBound.y) / 2, (this.aabb.upperBound.z - this.aabb.lowerBound.z) / 2);
    Box.calculateInertia(halfExtents, this.mass, I);
    this.invInertia.set(I.x > 0 && !fixed ? 1.0 / I.x : 0, I.y > 0 && !fixed ? 1.0 / I.y : 0, I.z > 0 && !fixed ? 1.0 / I.z : 0);
    this.updateInertiaWorld(true);
  }
  /**
   * Get world velocity of a point in the body.
   * @param worldPoint
   * @param result
   * @return The result vector.
   */


  getVelocityAtWorldPoint(worldPoint, result) {
    const r = new Vec3();
    worldPoint.vsub(this.position, r);
    this.angularVelocity.cross(r, result);
    this.velocity.vadd(result, result);
    return result;
  }
  /**
   * Move the body forward in time.
   * @param dt Time step
   * @param quatNormalize Set to true to normalize the body quaternion
   * @param quatNormalizeFast If the quaternion should be normalized using "fast" quaternion normalization
   */


  integrate(dt, quatNormalize, quatNormalizeFast) {
    // Save previous position
    this.previousPosition.copy(this.position);
    this.previousQuaternion.copy(this.quaternion);

    if (!(this.type === Body.DYNAMIC || this.type === Body.KINEMATIC) || this.sleepState === Body.SLEEPING) {
      // Only for dynamic
      return;
    }

    const velo = this.velocity;
    const angularVelo = this.angularVelocity;
    const pos = this.position;
    const force = this.force;
    const torque = this.torque;
    const quat = this.quaternion;
    const invMass = this.invMass;
    const invInertia = this.invInertiaWorld;
    const linearFactor = this.linearFactor;
    const iMdt = invMass * dt;
    velo.x += force.x * iMdt * linearFactor.x;
    velo.y += force.y * iMdt * linearFactor.y;
    velo.z += force.z * iMdt * linearFactor.z;
    const e = invInertia.elements;
    const angularFactor = this.angularFactor;
    const tx = torque.x * angularFactor.x;
    const ty = torque.y * angularFactor.y;
    const tz = torque.z * angularFactor.z;
    angularVelo.x += dt * (e[0] * tx + e[1] * ty + e[2] * tz);
    angularVelo.y += dt * (e[3] * tx + e[4] * ty + e[5] * tz);
    angularVelo.z += dt * (e[6] * tx + e[7] * ty + e[8] * tz); // Use new velocity  - leap frog

    pos.x += velo.x * dt;
    pos.y += velo.y * dt;
    pos.z += velo.z * dt;
    quat.integrate(this.angularVelocity, dt, this.angularFactor, quat);

    if (quatNormalize) {
      if (quatNormalizeFast) {
        quat.normalizeFast();
      } else {
        quat.normalize();
      }
    }

    this.aabbNeedsUpdate = true; // Update world inertia

    this.updateInertiaWorld();
  }

}
Body.idCounter = 0;
Body.COLLIDE_EVENT_NAME = 'collide';
Body.DYNAMIC = BODY_TYPES.DYNAMIC;
Body.STATIC = BODY_TYPES.STATIC;
Body.KINEMATIC = BODY_TYPES.KINEMATIC;
Body.AWAKE = BODY_SLEEP_STATES.AWAKE;
Body.SLEEPY = BODY_SLEEP_STATES.SLEEPY;
Body.SLEEPING = BODY_SLEEP_STATES.SLEEPING;
Body.wakeupEvent = {
  type: 'wakeup'
};
Body.sleepyEvent = {
  type: 'sleepy'
};
Body.sleepEvent = {
  type: 'sleep'
};
const tmpVec = new Vec3();
const tmpQuat = new Quaternion();
const updateAABB_shapeAABB = new AABB();
const uiw_m1 = new Mat3();
const uiw_m2 = new Mat3();
const Body_applyForce_rotForce = new Vec3();
const Body_applyLocalForce_worldForce = new Vec3();
const Body_applyLocalForce_relativePointWorld = new Vec3();
const Body_applyImpulse_velo = new Vec3();
const Body_applyImpulse_rotVelo = new Vec3();
const Body_applyLocalImpulse_worldImpulse = new Vec3();
const Body_applyLocalImpulse_relativePoint = new Vec3();
const Body_updateMassProperties_halfExtents = new Vec3();

/**
 * Base class for broadphase implementations
 * @author schteppe
 */
class Broadphase {
  /**
   * The world to search for collisions in.
   */

  /**
   * If set to true, the broadphase uses bounding boxes for intersection tests, else it uses bounding spheres.
   */

  /**
   * Set to true if the objects in the world moved.
   */
  constructor() {
    this.world = void 0;
    this.useBoundingBoxes = void 0;
    this.dirty = void 0;
    this.world = null;
    this.useBoundingBoxes = false;
    this.dirty = true;
  }
  /**
   * Get the collision pairs from the world
   * @param world The world to search in
   * @param p1 Empty array to be filled with body objects
   * @param p2 Empty array to be filled with body objects
   */


  collisionPairs(world, p1, p2) {
    throw new Error('collisionPairs not implemented for this BroadPhase class!');
  }
  /**
   * Check if a body pair needs to be intersection tested at all.
   */


  needBroadphaseCollision(bodyA, bodyB) {
    // Check collision filter masks
    if ((bodyA.collisionFilterGroup & bodyB.collisionFilterMask) === 0 || (bodyB.collisionFilterGroup & bodyA.collisionFilterMask) === 0) {
      return false;
    } // Check types


    if (((bodyA.type & Body.STATIC) !== 0 || bodyA.sleepState === Body.SLEEPING) && ((bodyB.type & Body.STATIC) !== 0 || bodyB.sleepState === Body.SLEEPING)) {
      // Both bodies are static or sleeping. Skip.
      return false;
    }

    return true;
  }
  /**
   * Check if the bounding volumes of two bodies intersect.
   */


  intersectionTest(bodyA, bodyB, pairs1, pairs2) {
    if (this.useBoundingBoxes) {
      this.doBoundingBoxBroadphase(bodyA, bodyB, pairs1, pairs2);
    } else {
      this.doBoundingSphereBroadphase(bodyA, bodyB, pairs1, pairs2);
    }
  }
  /**
   * Check if the bounding spheres of two bodies are intersecting.
   * @param pairs1 bodyA is appended to this array if intersection
   * @param pairs2 bodyB is appended to this array if intersection
   */


  doBoundingSphereBroadphase(bodyA, bodyB, pairs1, pairs2) {
    const r = Broadphase_collisionPairs_r;
    bodyB.position.vsub(bodyA.position, r);
    const boundingRadiusSum2 = (bodyA.boundingRadius + bodyB.boundingRadius) ** 2;
    const norm2 = r.lengthSquared();

    if (norm2 < boundingRadiusSum2) {
      pairs1.push(bodyA);
      pairs2.push(bodyB);
    }
  }
  /**
   * Check if the bounding boxes of two bodies are intersecting.
   */


  doBoundingBoxBroadphase(bodyA, bodyB, pairs1, pairs2) {
    if (bodyA.aabbNeedsUpdate) {
      bodyA.updateAABB();
    }

    if (bodyB.aabbNeedsUpdate) {
      bodyB.updateAABB();
    } // Check AABB / AABB


    if (bodyA.aabb.overlaps(bodyB.aabb)) {
      pairs1.push(bodyA);
      pairs2.push(bodyB);
    }
  }
  /**
   * Removes duplicate pairs from the pair arrays.
   */


  makePairsUnique(pairs1, pairs2) {
    const t = Broadphase_makePairsUnique_temp;
    const p1 = Broadphase_makePairsUnique_p1;
    const p2 = Broadphase_makePairsUnique_p2;
    const N = pairs1.length;

    for (let i = 0; i !== N; i++) {
      p1[i] = pairs1[i];
      p2[i] = pairs2[i];
    }

    pairs1.length = 0;
    pairs2.length = 0;

    for (let i = 0; i !== N; i++) {
      const id1 = p1[i].id;
      const id2 = p2[i].id;
      const key = id1 < id2 ? id1 + "," + id2 : id2 + "," + id1;
      t[key] = i;
      t.keys.push(key);
    }

    for (let i = 0; i !== t.keys.length; i++) {
      const key = t.keys.pop();
      const pairIndex = t[key];
      pairs1.push(p1[pairIndex]);
      pairs2.push(p2[pairIndex]);
      delete t[key];
    }
  }
  /**
   * To be implemented by subcasses
   */


  setWorld(world) {}
  /**
   * Check if the bounding spheres of two bodies overlap.
   */


  static boundingSphereCheck(bodyA, bodyB) {
    const dist = new Vec3(); // bsc_dist;

    bodyA.position.vsub(bodyB.position, dist);
    const sa = bodyA.shapes[0];
    const sb = bodyB.shapes[0];
    return Math.pow(sa.boundingSphereRadius + sb.boundingSphereRadius, 2) > dist.lengthSquared();
  }
  /**
   * Returns all the bodies within the AABB.
   */


  aabbQuery(world, aabb, result) {
    console.warn('.aabbQuery is not implemented in this Broadphase subclass.');
    return [];
  }

} // Temp objects

const Broadphase_collisionPairs_r = new Vec3();
const Broadphase_makePairsUnique_temp = {
  keys: []
};
const Broadphase_makePairsUnique_p1 = [];
const Broadphase_makePairsUnique_p2 = [];

/**
 * Axis aligned uniform grid broadphase.
 * @todo Needs support for more than just planes and spheres.
 */
class GridBroadphase extends Broadphase {
  /**
   * Number of boxes along x
   */

  /**
   * Number of boxes along y
   */

  /**
   * Number of boxes along z
   */

  /**
   * aabbMin
   */

  /**
   * aabbMax
   */

  /**
   * bins
   */

  /**
   * binLengths
   */

  /**
   * @param nx Number of boxes along x.
   * @param ny Number of boxes along y.
   * @param nz Number of boxes along z.
   */
  constructor(aabbMin = new Vec3(100, 100, 100), aabbMax = new Vec3(-100, -100, -100), nx = 10, ny = 10, nz = 10) {
    super();
    this.nx = void 0;
    this.ny = void 0;
    this.nz = void 0;
    this.aabbMin = void 0;
    this.aabbMax = void 0;
    this.bins = void 0;
    this.binLengths = void 0;
    this.nx = nx;
    this.ny = ny;
    this.nz = nz;
    this.aabbMin = aabbMin;
    this.aabbMax = aabbMax;
    const nbins = this.nx * this.ny * this.nz;

    if (nbins <= 0) {
      throw "GridBroadphase: Each dimension's n must be >0";
    }

    this.bins = [];
    this.binLengths = []; // Rather than continually resizing arrays (thrashing the memory), just record length and allow them to grow

    this.bins.length = nbins;
    this.binLengths.length = nbins;

    for (let i = 0; i < nbins; i++) {
      this.bins[i] = [];
      this.binLengths[i] = 0;
    }
  }
  /**
   * Get all the collision pairs in the physics world
   */


  collisionPairs(world, pairs1, pairs2) {
    const N = world.numObjects();
    const bodies = world.bodies;
    const max = this.aabbMax;
    const min = this.aabbMin;
    const nx = this.nx;
    const ny = this.ny;
    const nz = this.nz;
    const xstep = ny * nz;
    const ystep = nz;
    const zstep = 1;
    const xmax = max.x;
    const ymax = max.y;
    const zmax = max.z;
    const xmin = min.x;
    const ymin = min.y;
    const zmin = min.z;
    const xmult = nx / (xmax - xmin);
    const ymult = ny / (ymax - ymin);
    const zmult = nz / (zmax - zmin);
    const binsizeX = (xmax - xmin) / nx;
    const binsizeY = (ymax - ymin) / ny;
    const binsizeZ = (zmax - zmin) / nz;
    const binRadius = Math.sqrt(binsizeX * binsizeX + binsizeY * binsizeY + binsizeZ * binsizeZ) * 0.5;
    const types = Shape.types;
    const SPHERE = types.SPHERE;
    const PLANE = types.PLANE;
    types.BOX;
    types.COMPOUND;
    types.CONVEXPOLYHEDRON;
    const bins = this.bins;
    const binLengths = this.binLengths;
    const Nbins = this.bins.length; // Reset bins

    for (let i = 0; i !== Nbins; i++) {
      binLengths[i] = 0;
    }

    const ceil = Math.ceil;

    function addBoxToBins(x0, y0, z0, x1, y1, z1, bi) {
      let xoff0 = (x0 - xmin) * xmult | 0;
      let yoff0 = (y0 - ymin) * ymult | 0;
      let zoff0 = (z0 - zmin) * zmult | 0;
      let xoff1 = ceil((x1 - xmin) * xmult);
      let yoff1 = ceil((y1 - ymin) * ymult);
      let zoff1 = ceil((z1 - zmin) * zmult);

      if (xoff0 < 0) {
        xoff0 = 0;
      } else if (xoff0 >= nx) {
        xoff0 = nx - 1;
      }

      if (yoff0 < 0) {
        yoff0 = 0;
      } else if (yoff0 >= ny) {
        yoff0 = ny - 1;
      }

      if (zoff0 < 0) {
        zoff0 = 0;
      } else if (zoff0 >= nz) {
        zoff0 = nz - 1;
      }

      if (xoff1 < 0) {
        xoff1 = 0;
      } else if (xoff1 >= nx) {
        xoff1 = nx - 1;
      }

      if (yoff1 < 0) {
        yoff1 = 0;
      } else if (yoff1 >= ny) {
        yoff1 = ny - 1;
      }

      if (zoff1 < 0) {
        zoff1 = 0;
      } else if (zoff1 >= nz) {
        zoff1 = nz - 1;
      }

      xoff0 *= xstep;
      yoff0 *= ystep;
      zoff0 *= zstep;
      xoff1 *= xstep;
      yoff1 *= ystep;
      zoff1 *= zstep;

      for (let xoff = xoff0; xoff <= xoff1; xoff += xstep) {
        for (let yoff = yoff0; yoff <= yoff1; yoff += ystep) {
          for (let zoff = zoff0; zoff <= zoff1; zoff += zstep) {
            const idx = xoff + yoff + zoff;
            bins[idx][binLengths[idx]++] = bi;
          }
        }
      }
    } // Put all bodies into the bins


    for (let i = 0; i !== N; i++) {
      const bi = bodies[i];
      const si = bi.shapes[0];

      switch (si.type) {
        case SPHERE:
          {
            const shape = si; // Put in bin
            // check if overlap with other bins

            const x = bi.position.x;
            const y = bi.position.y;
            const z = bi.position.z;
            const r = shape.radius;
            addBoxToBins(x - r, y - r, z - r, x + r, y + r, z + r, bi);
            break;
          }

        case PLANE:
          {
            const shape = si;

            if (shape.worldNormalNeedsUpdate) {
              shape.computeWorldNormal(bi.quaternion);
            }

            const planeNormal = shape.worldNormal; //Relative position from origin of plane object to the first bin
            //Incremented as we iterate through the bins

            const xreset = xmin + binsizeX * 0.5 - bi.position.x;
            const yreset = ymin + binsizeY * 0.5 - bi.position.y;
            const zreset = zmin + binsizeZ * 0.5 - bi.position.z;
            const d = GridBroadphase_collisionPairs_d;
            d.set(xreset, yreset, zreset);

            for (let xi = 0, xoff = 0; xi !== nx; xi++, xoff += xstep, d.y = yreset, d.x += binsizeX) {
              for (let yi = 0, yoff = 0; yi !== ny; yi++, yoff += ystep, d.z = zreset, d.y += binsizeY) {
                for (let zi = 0, zoff = 0; zi !== nz; zi++, zoff += zstep, d.z += binsizeZ) {
                  if (d.dot(planeNormal) < binRadius) {
                    const idx = xoff + yoff + zoff;
                    bins[idx][binLengths[idx]++] = bi;
                  }
                }
              }
            }

            break;
          }

        default:
          {
            if (bi.aabbNeedsUpdate) {
              bi.updateAABB();
            }

            addBoxToBins(bi.aabb.lowerBound.x, bi.aabb.lowerBound.y, bi.aabb.lowerBound.z, bi.aabb.upperBound.x, bi.aabb.upperBound.y, bi.aabb.upperBound.z, bi);
            break;
          }
      }
    } // Check each bin


    for (let i = 0; i !== Nbins; i++) {
      const binLength = binLengths[i]; //Skip bins with no potential collisions

      if (binLength > 1) {
        const bin = bins[i]; // Do N^2 broadphase inside

        for (let xi = 0; xi !== binLength; xi++) {
          const bi = bin[xi];

          for (let yi = 0; yi !== xi; yi++) {
            const bj = bin[yi];

            if (this.needBroadphaseCollision(bi, bj)) {
              this.intersectionTest(bi, bj, pairs1, pairs2);
            }
          }
        }
      }
    } //	for (let zi = 0, zoff=0; zi < nz; zi++, zoff+= zstep) {
    //		console.log("layer "+zi);
    //		for (let yi = 0, yoff=0; yi < ny; yi++, yoff += ystep) {
    //			const row = '';
    //			for (let xi = 0, xoff=0; xi < nx; xi++, xoff += xstep) {
    //				const idx = xoff + yoff + zoff;
    //				row += ' ' + binLengths[idx];
    //			}
    //			console.log(row);
    //		}
    //	}


    this.makePairsUnique(pairs1, pairs2);
  }

}
const GridBroadphase_collisionPairs_d = new Vec3();

/**
 * Naive broadphase implementation, used in lack of better ones.
 *
 * The naive broadphase looks at all possible pairs without restriction, therefore it has complexity N^2 _(which is bad)_
 */
class NaiveBroadphase extends Broadphase {
  /**
   * @todo Remove useless constructor
   */
  constructor() {
    super();
  }
  /**
   * Get all the collision pairs in the physics world
   */


  collisionPairs(world, pairs1, pairs2) {
    const bodies = world.bodies;
    const n = bodies.length;
    let bi;
    let bj; // Naive N^2 ftw!

    for (let i = 0; i !== n; i++) {
      for (let j = 0; j !== i; j++) {
        bi = bodies[i];
        bj = bodies[j];

        if (!this.needBroadphaseCollision(bi, bj)) {
          continue;
        }

        this.intersectionTest(bi, bj, pairs1, pairs2);
      }
    }
  }
  /**
   * Returns all the bodies within an AABB.
   * @param result An array to store resulting bodies in.
   */


  aabbQuery(world, aabb, result = []) {
    for (let i = 0; i < world.bodies.length; i++) {
      const b = world.bodies[i];

      if (b.aabbNeedsUpdate) {
        b.updateAABB();
      } // Ugly hack until Body gets aabb


      if (b.aabb.overlaps(aabb)) {
        result.push(b);
      }
    }

    return result;
  }

}

/**
 * Storage for Ray casting data
 */
class RaycastResult {
  /**
   * rayFromWorld
   */

  /**
   * rayToWorld
   */

  /**
   * hitNormalWorld
   */

  /**
   * hitPointWorld
   */

  /**
   * hasHit
   */

  /**
   * shape
   */

  /**
   * body
   */

  /**
   * The index of the hit triangle, if the hit shape was a trimesh
   */

  /**
   * Distance to the hit. Will be set to -1 if there was no hit
   */

  /**
   * If the ray should stop traversing the bodies
   */
  constructor() {
    this.rayFromWorld = void 0;
    this.rayToWorld = void 0;
    this.hitNormalWorld = void 0;
    this.hitPointWorld = void 0;
    this.hasHit = void 0;
    this.shape = void 0;
    this.body = void 0;
    this.hitFaceIndex = void 0;
    this.distance = void 0;
    this.shouldStop = void 0;
    this.rayFromWorld = new Vec3();
    this.rayToWorld = new Vec3();
    this.hitNormalWorld = new Vec3();
    this.hitPointWorld = new Vec3();
    this.hasHit = false;
    this.shape = null;
    this.body = null;
    this.hitFaceIndex = -1;
    this.distance = -1;
    this.shouldStop = false;
  }
  /**
   * Reset all result data.
   */


  reset() {
    this.rayFromWorld.setZero();
    this.rayToWorld.setZero();
    this.hitNormalWorld.setZero();
    this.hitPointWorld.setZero();
    this.hasHit = false;
    this.shape = null;
    this.body = null;
    this.hitFaceIndex = -1;
    this.distance = -1;
    this.shouldStop = false;
  }
  /**
   * abort
   */


  abort() {
    this.shouldStop = true;
  }
  /**
   * Set result data.
   */


  set(rayFromWorld, rayToWorld, hitNormalWorld, hitPointWorld, shape, body, distance) {
    this.rayFromWorld.copy(rayFromWorld);
    this.rayToWorld.copy(rayToWorld);
    this.hitNormalWorld.copy(hitNormalWorld);
    this.hitPointWorld.copy(hitPointWorld);
    this.shape = shape;
    this.body = body;
    this.distance = distance;
  }

}

let _Shape$types$SPHERE, _Shape$types$PLANE, _Shape$types$BOX, _Shape$types$CYLINDER, _Shape$types$CONVEXPO, _Shape$types$HEIGHTFI, _Shape$types$TRIMESH;

/**
 * RAY_MODES
 */
const RAY_MODES = {
  /** CLOSEST */
  CLOSEST: 1,

  /** ANY */
  ANY: 2,

  /** ALL */
  ALL: 4
};
/**
 * RayMode
 */

_Shape$types$SPHERE = Shape.types.SPHERE;
_Shape$types$PLANE = Shape.types.PLANE;
_Shape$types$BOX = Shape.types.BOX;
_Shape$types$CYLINDER = Shape.types.CYLINDER;
_Shape$types$CONVEXPO = Shape.types.CONVEXPOLYHEDRON;
_Shape$types$HEIGHTFI = Shape.types.HEIGHTFIELD;
_Shape$types$TRIMESH = Shape.types.TRIMESH;

/**
 * A line in 3D space that intersects bodies and return points.
 */
class Ray {
  /**
   * from
   */

  /**
   * to
   */

  /**
   * direction
   */

  /**
   * The precision of the ray. Used when checking parallelity etc.
   * @default 0.0001
   */

  /**
   * Set to `false` if you don't want the Ray to take `collisionResponse` flags into account on bodies and shapes.
   * @default true
   */

  /**
   * If set to `true`, the ray skips any hits with normal.dot(rayDirection) < 0.
   * @default false
   */

  /**
   * collisionFilterMask
   * @default -1
   */

  /**
   * collisionFilterGroup
   * @default -1
   */

  /**
   * The intersection mode. Should be Ray.ANY, Ray.ALL or Ray.CLOSEST.
   * @default RAY.ANY
   */

  /**
   * Current result object.
   */

  /**
   * Will be set to `true` during intersectWorld() if the ray hit anything.
   */

  /**
   * User-provided result callback. Will be used if mode is Ray.ALL.
   */

  /**
   * CLOSEST
   */

  /**
   * ANY
   */

  /**
   * ALL
   */
  get [_Shape$types$SPHERE]() {
    return this._intersectSphere;
  }

  get [_Shape$types$PLANE]() {
    return this._intersectPlane;
  }

  get [_Shape$types$BOX]() {
    return this._intersectBox;
  }

  get [_Shape$types$CYLINDER]() {
    return this._intersectConvex;
  }

  get [_Shape$types$CONVEXPO]() {
    return this._intersectConvex;
  }

  get [_Shape$types$HEIGHTFI]() {
    return this._intersectHeightfield;
  }

  get [_Shape$types$TRIMESH]() {
    return this._intersectTrimesh;
  }

  constructor(from = new Vec3(), to = new Vec3()) {
    this.from = void 0;
    this.to = void 0;
    this.direction = void 0;
    this.precision = void 0;
    this.checkCollisionResponse = void 0;
    this.skipBackfaces = void 0;
    this.collisionFilterMask = void 0;
    this.collisionFilterGroup = void 0;
    this.mode = void 0;
    this.result = void 0;
    this.hasHit = void 0;
    this.callback = void 0;
    this.from = from.clone();
    this.to = to.clone();
    this.direction = new Vec3();
    this.precision = 0.0001;
    this.checkCollisionResponse = true;
    this.skipBackfaces = false;
    this.collisionFilterMask = -1;
    this.collisionFilterGroup = -1;
    this.mode = Ray.ANY;
    this.result = new RaycastResult();
    this.hasHit = false;

    this.callback = result => {};
  }
  /**
   * Do itersection against all bodies in the given World.
   * @return True if the ray hit anything, otherwise false.
   */


  intersectWorld(world, options) {
    this.mode = options.mode || Ray.ANY;
    this.result = options.result || new RaycastResult();
    this.skipBackfaces = !!options.skipBackfaces;
    this.collisionFilterMask = typeof options.collisionFilterMask !== 'undefined' ? options.collisionFilterMask : -1;
    this.collisionFilterGroup = typeof options.collisionFilterGroup !== 'undefined' ? options.collisionFilterGroup : -1;
    this.checkCollisionResponse = typeof options.checkCollisionResponse !== 'undefined' ? options.checkCollisionResponse : true;

    if (options.from) {
      this.from.copy(options.from);
    }

    if (options.to) {
      this.to.copy(options.to);
    }

    this.callback = options.callback || (() => {});

    this.hasHit = false;
    this.result.reset();
    this.updateDirection();
    this.getAABB(tmpAABB$1);
    tmpArray.length = 0;
    world.broadphase.aabbQuery(world, tmpAABB$1, tmpArray);
    this.intersectBodies(tmpArray);
    return this.hasHit;
  }
  /**
   * Shoot a ray at a body, get back information about the hit.
   * @deprecated @param result set the result property of the Ray instead.
   */


  intersectBody(body, result) {
    if (result) {
      this.result = result;
      this.updateDirection();
    }

    const checkCollisionResponse = this.checkCollisionResponse;

    if (checkCollisionResponse && !body.collisionResponse) {
      return;
    }

    if ((this.collisionFilterGroup & body.collisionFilterMask) === 0 || (body.collisionFilterGroup & this.collisionFilterMask) === 0) {
      return;
    }

    const xi = intersectBody_xi;
    const qi = intersectBody_qi;

    for (let i = 0, N = body.shapes.length; i < N; i++) {
      const shape = body.shapes[i];

      if (checkCollisionResponse && !shape.collisionResponse) {
        continue; // Skip
      }

      body.quaternion.mult(body.shapeOrientations[i], qi);
      body.quaternion.vmult(body.shapeOffsets[i], xi);
      xi.vadd(body.position, xi);
      this.intersectShape(shape, qi, xi, body);

      if (this.result.shouldStop) {
        break;
      }
    }
  }
  /**
   * Shoot a ray at an array bodies, get back information about the hit.
   * @param bodies An array of Body objects.
   * @deprecated @param result set the result property of the Ray instead.
   *
   */


  intersectBodies(bodies, result) {
    if (result) {
      this.result = result;
      this.updateDirection();
    }

    for (let i = 0, l = bodies.length; !this.result.shouldStop && i < l; i++) {
      this.intersectBody(bodies[i]);
    }
  }
  /**
   * Updates the direction vector.
   */


  updateDirection() {
    this.to.vsub(this.from, this.direction);
    this.direction.normalize();
  }

  intersectShape(shape, quat, position, body) {
    const from = this.from; // Checking boundingSphere

    const distance = distanceFromIntersection(from, this.direction, position);

    if (distance > shape.boundingSphereRadius) {
      return;
    }

    const intersectMethod = this[shape.type];

    if (intersectMethod) {
      intersectMethod.call(this, shape, quat, position, body, shape);
    }
  }

  _intersectBox(box, quat, position, body, reportedShape) {
    return this._intersectConvex(box.convexPolyhedronRepresentation, quat, position, body, reportedShape);
  }

  _intersectPlane(shape, quat, position, body, reportedShape) {
    const from = this.from;
    const to = this.to;
    const direction = this.direction; // Get plane normal

    const worldNormal = new Vec3(0, 0, 1);
    quat.vmult(worldNormal, worldNormal);
    const len = new Vec3();
    from.vsub(position, len);
    const planeToFrom = len.dot(worldNormal);
    to.vsub(position, len);
    const planeToTo = len.dot(worldNormal);

    if (planeToFrom * planeToTo > 0) {
      // "from" and "to" are on the same side of the plane... bail out
      return;
    }

    if (from.distanceTo(to) < planeToFrom) {
      return;
    }

    const n_dot_dir = worldNormal.dot(direction);

    if (Math.abs(n_dot_dir) < this.precision) {
      // No intersection
      return;
    }

    const planePointToFrom = new Vec3();
    const dir_scaled_with_t = new Vec3();
    const hitPointWorld = new Vec3();
    from.vsub(position, planePointToFrom);
    const t = -worldNormal.dot(planePointToFrom) / n_dot_dir;
    direction.scale(t, dir_scaled_with_t);
    from.vadd(dir_scaled_with_t, hitPointWorld);
    this.reportIntersection(worldNormal, hitPointWorld, reportedShape, body, -1);
  }
  /**
   * Get the world AABB of the ray.
   */


  getAABB(aabb) {
    const {
      lowerBound,
      upperBound
    } = aabb;
    const to = this.to;
    const from = this.from;
    lowerBound.x = Math.min(to.x, from.x);
    lowerBound.y = Math.min(to.y, from.y);
    lowerBound.z = Math.min(to.z, from.z);
    upperBound.x = Math.max(to.x, from.x);
    upperBound.y = Math.max(to.y, from.y);
    upperBound.z = Math.max(to.z, from.z);
  }

  _intersectHeightfield(shape, quat, position, body, reportedShape) {
    shape.data;
    shape.elementSize; // Convert the ray to local heightfield coordinates

    const localRay = intersectHeightfield_localRay; //new Ray(this.from, this.to);

    localRay.from.copy(this.from);
    localRay.to.copy(this.to);
    Transform.pointToLocalFrame(position, quat, localRay.from, localRay.from);
    Transform.pointToLocalFrame(position, quat, localRay.to, localRay.to);
    localRay.updateDirection(); // Get the index of the data points to test against

    const index = intersectHeightfield_index;
    let iMinX;
    let iMinY;
    let iMaxX;
    let iMaxY; // Set to max

    iMinX = iMinY = 0;
    iMaxX = iMaxY = shape.data.length - 1;
    const aabb = new AABB();
    localRay.getAABB(aabb);
    shape.getIndexOfPosition(aabb.lowerBound.x, aabb.lowerBound.y, index, true);
    iMinX = Math.max(iMinX, index[0]);
    iMinY = Math.max(iMinY, index[1]);
    shape.getIndexOfPosition(aabb.upperBound.x, aabb.upperBound.y, index, true);
    iMaxX = Math.min(iMaxX, index[0] + 1);
    iMaxY = Math.min(iMaxY, index[1] + 1);

    for (let i = iMinX; i < iMaxX; i++) {
      for (let j = iMinY; j < iMaxY; j++) {
        if (this.result.shouldStop) {
          return;
        }

        shape.getAabbAtIndex(i, j, aabb);

        if (!aabb.overlapsRay(localRay)) {
          continue;
        } // Lower triangle


        shape.getConvexTrianglePillar(i, j, false);
        Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);

        this._intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, reportedShape, intersectConvexOptions);

        if (this.result.shouldStop) {
          return;
        } // Upper triangle


        shape.getConvexTrianglePillar(i, j, true);
        Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);

        this._intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, reportedShape, intersectConvexOptions);
      }
    }
  }

  _intersectSphere(sphere, quat, position, body, reportedShape) {
    const from = this.from;
    const to = this.to;
    const r = sphere.radius;
    const a = (to.x - from.x) ** 2 + (to.y - from.y) ** 2 + (to.z - from.z) ** 2;
    const b = 2 * ((to.x - from.x) * (from.x - position.x) + (to.y - from.y) * (from.y - position.y) + (to.z - from.z) * (from.z - position.z));
    const c = (from.x - position.x) ** 2 + (from.y - position.y) ** 2 + (from.z - position.z) ** 2 - r ** 2;
    const delta = b ** 2 - 4 * a * c;
    const intersectionPoint = Ray_intersectSphere_intersectionPoint;
    const normal = Ray_intersectSphere_normal;

    if (delta < 0) {
      // No intersection
      return;
    } else if (delta === 0) {
      // single intersection point
      from.lerp(to, delta, intersectionPoint);
      intersectionPoint.vsub(position, normal);
      normal.normalize();
      this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);
    } else {
      const d1 = (-b - Math.sqrt(delta)) / (2 * a);
      const d2 = (-b + Math.sqrt(delta)) / (2 * a);

      if (d1 >= 0 && d1 <= 1) {
        from.lerp(to, d1, intersectionPoint);
        intersectionPoint.vsub(position, normal);
        normal.normalize();
        this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);
      }

      if (this.result.shouldStop) {
        return;
      }

      if (d2 >= 0 && d2 <= 1) {
        from.lerp(to, d2, intersectionPoint);
        intersectionPoint.vsub(position, normal);
        normal.normalize();
        this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);
      }
    }
  }

  _intersectConvex(shape, quat, position, body, reportedShape, options) {
    const normal = intersectConvex_normal;
    const vector = intersectConvex_vector;
    const faceList = options && options.faceList || null; // Checking faces

    const faces = shape.faces;
    const vertices = shape.vertices;
    const normals = shape.faceNormals;
    const direction = this.direction;
    const from = this.from;
    const to = this.to;
    const fromToDistance = from.distanceTo(to);
    const Nfaces = faceList ? faceList.length : faces.length;
    const result = this.result;

    for (let j = 0; !result.shouldStop && j < Nfaces; j++) {
      const fi = faceList ? faceList[j] : j;
      const face = faces[fi];
      const faceNormal = normals[fi];
      const q = quat;
      const x = position; // determine if ray intersects the plane of the face
      // note: this works regardless of the direction of the face normal
      // Get plane point in world coordinates...

      vector.copy(vertices[face[0]]);
      q.vmult(vector, vector);
      vector.vadd(x, vector); // ...but make it relative to the ray from. We'll fix this later.

      vector.vsub(from, vector); // Get plane normal

      q.vmult(faceNormal, normal); // If this dot product is negative, we have something interesting

      const dot = direction.dot(normal); // Bail out if ray and plane are parallel

      if (Math.abs(dot) < this.precision) {
        continue;
      } // calc distance to plane


      const scalar = normal.dot(vector) / dot; // if negative distance, then plane is behind ray

      if (scalar < 0) {
        continue;
      } // if (dot < 0) {
      // Intersection point is from + direction * scalar


      direction.scale(scalar, intersectPoint);
      intersectPoint.vadd(from, intersectPoint); // a is the point we compare points b and c with.

      a.copy(vertices[face[0]]);
      q.vmult(a, a);
      x.vadd(a, a);

      for (let i = 1; !result.shouldStop && i < face.length - 1; i++) {
        // Transform 3 vertices to world coords
        b.copy(vertices[face[i]]);
        c.copy(vertices[face[i + 1]]);
        q.vmult(b, b);
        q.vmult(c, c);
        x.vadd(b, b);
        x.vadd(c, c);
        const distance = intersectPoint.distanceTo(from);

        if (!(Ray.pointInTriangle(intersectPoint, a, b, c) || Ray.pointInTriangle(intersectPoint, b, a, c)) || distance > fromToDistance) {
          continue;
        }

        this.reportIntersection(normal, intersectPoint, reportedShape, body, fi);
      } // }

    }
  }
  /**
   * @todo Optimize by transforming the world to local space first.
   * @todo Use Octree lookup
   */


  _intersectTrimesh(mesh, quat, position, body, reportedShape, options) {
    const normal = intersectTrimesh_normal;
    const triangles = intersectTrimesh_triangles;
    const treeTransform = intersectTrimesh_treeTransform;
    const vector = intersectConvex_vector;
    const localDirection = intersectTrimesh_localDirection;
    const localFrom = intersectTrimesh_localFrom;
    const localTo = intersectTrimesh_localTo;
    const worldIntersectPoint = intersectTrimesh_worldIntersectPoint;
    const worldNormal = intersectTrimesh_worldNormal; // Checking faces

    const indices = mesh.indices;
    mesh.vertices; // const normals = mesh.faceNormals

    const from = this.from;
    const to = this.to;
    const direction = this.direction;
    treeTransform.position.copy(position);
    treeTransform.quaternion.copy(quat); // Transform ray to local space!

    Transform.vectorToLocalFrame(position, quat, direction, localDirection);
    Transform.pointToLocalFrame(position, quat, from, localFrom);
    Transform.pointToLocalFrame(position, quat, to, localTo);
    localTo.x *= mesh.scale.x;
    localTo.y *= mesh.scale.y;
    localTo.z *= mesh.scale.z;
    localFrom.x *= mesh.scale.x;
    localFrom.y *= mesh.scale.y;
    localFrom.z *= mesh.scale.z;
    localTo.vsub(localFrom, localDirection);
    localDirection.normalize();
    const fromToDistanceSquared = localFrom.distanceSquared(localTo);
    mesh.tree.rayQuery(this, treeTransform, triangles);

    for (let i = 0, N = triangles.length; !this.result.shouldStop && i !== N; i++) {
      const trianglesIndex = triangles[i];
      mesh.getNormal(trianglesIndex, normal); // determine if ray intersects the plane of the face
      // note: this works regardless of the direction of the face normal
      // Get plane point in world coordinates...

      mesh.getVertex(indices[trianglesIndex * 3], a); // ...but make it relative to the ray from. We'll fix this later.

      a.vsub(localFrom, vector); // If this dot product is negative, we have something interesting

      const dot = localDirection.dot(normal); // Bail out if ray and plane are parallel
      // if (Math.abs( dot ) < this.precision){
      //     continue;
      // }
      // calc distance to plane

      const scalar = normal.dot(vector) / dot; // if negative distance, then plane is behind ray

      if (scalar < 0) {
        continue;
      } // Intersection point is from + direction * scalar


      localDirection.scale(scalar, intersectPoint);
      intersectPoint.vadd(localFrom, intersectPoint); // Get triangle vertices

      mesh.getVertex(indices[trianglesIndex * 3 + 1], b);
      mesh.getVertex(indices[trianglesIndex * 3 + 2], c);
      const squaredDistance = intersectPoint.distanceSquared(localFrom);

      if (!(Ray.pointInTriangle(intersectPoint, b, a, c) || Ray.pointInTriangle(intersectPoint, a, b, c)) || squaredDistance > fromToDistanceSquared) {
        continue;
      } // transform intersectpoint and normal to world


      Transform.vectorToWorldFrame(quat, normal, worldNormal);
      Transform.pointToWorldFrame(position, quat, intersectPoint, worldIntersectPoint);
      this.reportIntersection(worldNormal, worldIntersectPoint, reportedShape, body, trianglesIndex);
    }

    triangles.length = 0;
  }
  /**
   * @return True if the intersections should continue
   */


  reportIntersection(normal, hitPointWorld, shape, body, hitFaceIndex) {
    const from = this.from;
    const to = this.to;
    const distance = from.distanceTo(hitPointWorld);
    const result = this.result; // Skip back faces?

    if (this.skipBackfaces && normal.dot(this.direction) > 0) {
      return;
    }

    result.hitFaceIndex = typeof hitFaceIndex !== 'undefined' ? hitFaceIndex : -1;

    switch (this.mode) {
      case Ray.ALL:
        this.hasHit = true;
        result.set(from, to, normal, hitPointWorld, shape, body, distance);
        result.hasHit = true;
        this.callback(result);
        break;

      case Ray.CLOSEST:
        // Store if closer than current closest
        if (distance < result.distance || !result.hasHit) {
          this.hasHit = true;
          result.hasHit = true;
          result.set(from, to, normal, hitPointWorld, shape, body, distance);
        }

        break;

      case Ray.ANY:
        // Report and stop.
        this.hasHit = true;
        result.hasHit = true;
        result.set(from, to, normal, hitPointWorld, shape, body, distance);
        result.shouldStop = true;
        break;
    }
  }
  /**
   * As per "Barycentric Technique" as named
   * {@link https://www.blackpawn.com/texts/pointinpoly/default.html here} but without the division
   */


  static pointInTriangle(p, a, b, c) {
    c.vsub(a, v0);
    b.vsub(a, v1);
    p.vsub(a, v2);
    const dot00 = v0.dot(v0);
    const dot01 = v0.dot(v1);
    const dot02 = v0.dot(v2);
    const dot11 = v1.dot(v1);
    const dot12 = v1.dot(v2);
    let u;
    let v;
    return (u = dot11 * dot02 - dot01 * dot12) >= 0 && (v = dot00 * dot12 - dot01 * dot02) >= 0 && u + v < dot00 * dot11 - dot01 * dot01;
  }

}
Ray.CLOSEST = RAY_MODES.CLOSEST;
Ray.ANY = RAY_MODES.ANY;
Ray.ALL = RAY_MODES.ALL;
const tmpAABB$1 = new AABB();
const tmpArray = [];
const v1 = new Vec3();
const v2 = new Vec3();
const intersectBody_xi = new Vec3();
const intersectBody_qi = new Quaternion();
const intersectPoint = new Vec3();
const a = new Vec3();
const b = new Vec3();
const c = new Vec3();
const intersectConvexOptions = {
  faceList: [0]
};
const worldPillarOffset = new Vec3();
const intersectHeightfield_localRay = new Ray();
const intersectHeightfield_index = [];
const Ray_intersectSphere_intersectionPoint = new Vec3();
const Ray_intersectSphere_normal = new Vec3();
const intersectConvex_normal = new Vec3();
const intersectConvex_vector = new Vec3();
const intersectTrimesh_normal = new Vec3();
const intersectTrimesh_localDirection = new Vec3();
const intersectTrimesh_localFrom = new Vec3();
const intersectTrimesh_localTo = new Vec3();
const intersectTrimesh_worldNormal = new Vec3();
const intersectTrimesh_worldIntersectPoint = new Vec3();
new AABB();
const intersectTrimesh_triangles = [];
const intersectTrimesh_treeTransform = new Transform();
const v0 = new Vec3();
const intersect = new Vec3();

function distanceFromIntersection(from, direction, position) {
  // v0 is vector from from to position
  position.vsub(from, v0);
  const dot = v0.dot(direction); // intersect = direction*dot + from

  direction.scale(dot, intersect);
  intersect.vadd(from, intersect);
  const distance = position.distanceTo(intersect);
  return distance;
}

/**
 * Sweep and prune broadphase along one axis.
 */
class SAPBroadphase extends Broadphase {
  /**
   * List of bodies currently in the broadphase.
   */

  /**
   * The world to search in.
   */

  /**
   * Axis to sort the bodies along.
   * Set to 0 for x axis, and 1 for y axis.
   * For best performance, pick the axis where bodies are most distributed.
   */

  /**
   * Check if the bounds of two bodies overlap, along the given SAP axis.
   */
  static checkBounds(bi, bj, axisIndex) {
    let biPos;
    let bjPos;

    if (axisIndex === 0) {
      biPos = bi.position.x;
      bjPos = bj.position.x;
    } else if (axisIndex === 1) {
      biPos = bi.position.y;
      bjPos = bj.position.y;
    } else if (axisIndex === 2) {
      biPos = bi.position.z;
      bjPos = bj.position.z;
    }

    const ri = bi.boundingRadius,
          rj = bj.boundingRadius,
          boundA2 = biPos + ri,
          boundB1 = bjPos - rj;
    return boundB1 < boundA2;
  } // Note: these are identical, save for x/y/z lowerbound

  /**
   * insertionSortX
   */


  static insertionSortX(a) {
    for (let i = 1, l = a.length; i < l; i++) {
      const v = a[i];
      let j;

      for (j = i - 1; j >= 0; j--) {
        if (a[j].aabb.lowerBound.x <= v.aabb.lowerBound.x) {
          break;
        }

        a[j + 1] = a[j];
      }

      a[j + 1] = v;
    }

    return a;
  }
  /**
   * insertionSortY
   */


  static insertionSortY(a) {
    for (let i = 1, l = a.length; i < l; i++) {
      const v = a[i];
      let j;

      for (j = i - 1; j >= 0; j--) {
        if (a[j].aabb.lowerBound.y <= v.aabb.lowerBound.y) {
          break;
        }

        a[j + 1] = a[j];
      }

      a[j + 1] = v;
    }

    return a;
  }
  /**
   * insertionSortZ
   */


  static insertionSortZ(a) {
    for (let i = 1, l = a.length; i < l; i++) {
      const v = a[i];
      let j;

      for (j = i - 1; j >= 0; j--) {
        if (a[j].aabb.lowerBound.z <= v.aabb.lowerBound.z) {
          break;
        }

        a[j + 1] = a[j];
      }

      a[j + 1] = v;
    }

    return a;
  }

  constructor(world) {
    super();
    this.axisList = void 0;
    this.world = void 0;
    this.axisIndex = void 0;
    this._addBodyHandler = void 0;
    this._removeBodyHandler = void 0;
    this.axisList = [];
    this.world = null;
    this.axisIndex = 0;
    const axisList = this.axisList;

    this._addBodyHandler = event => {
      axisList.push(event.body);
    };

    this._removeBodyHandler = event => {
      const idx = axisList.indexOf(event.body);

      if (idx !== -1) {
        axisList.splice(idx, 1);
      }
    };

    if (world) {
      this.setWorld(world);
    }
  }
  /**
   * Change the world
   */


  setWorld(world) {
    // Clear the old axis array
    this.axisList.length = 0; // Add all bodies from the new world

    for (let i = 0; i < world.bodies.length; i++) {
      this.axisList.push(world.bodies[i]);
    } // Remove old handlers, if any


    world.removeEventListener('addBody', this._addBodyHandler);
    world.removeEventListener('removeBody', this._removeBodyHandler); // Add handlers to update the list of bodies.

    world.addEventListener('addBody', this._addBodyHandler);
    world.addEventListener('removeBody', this._removeBodyHandler);
    this.world = world;
    this.dirty = true;
  }
  /**
   * Collect all collision pairs
   */


  collisionPairs(world, p1, p2) {
    const bodies = this.axisList;
    const N = bodies.length;
    const axisIndex = this.axisIndex;
    let i;
    let j;

    if (this.dirty) {
      this.sortList();
      this.dirty = false;
    } // Look through the list


    for (i = 0; i !== N; i++) {
      const bi = bodies[i];

      for (j = i + 1; j < N; j++) {
        const bj = bodies[j];

        if (!this.needBroadphaseCollision(bi, bj)) {
          continue;
        }

        if (!SAPBroadphase.checkBounds(bi, bj, axisIndex)) {
          break;
        }

        this.intersectionTest(bi, bj, p1, p2);
      }
    }
  }

  sortList() {
    const axisList = this.axisList;
    const axisIndex = this.axisIndex;
    const N = axisList.length; // Update AABBs

    for (let i = 0; i !== N; i++) {
      const bi = axisList[i];

      if (bi.aabbNeedsUpdate) {
        bi.updateAABB();
      }
    } // Sort the list


    if (axisIndex === 0) {
      SAPBroadphase.insertionSortX(axisList);
    } else if (axisIndex === 1) {
      SAPBroadphase.insertionSortY(axisList);
    } else if (axisIndex === 2) {
      SAPBroadphase.insertionSortZ(axisList);
    }
  }
  /**
   * Computes the variance of the body positions and estimates the best axis to use.
   * Will automatically set property `axisIndex`.
   */


  autoDetectAxis() {
    let sumX = 0;
    let sumX2 = 0;
    let sumY = 0;
    let sumY2 = 0;
    let sumZ = 0;
    let sumZ2 = 0;
    const bodies = this.axisList;
    const N = bodies.length;
    const invN = 1 / N;

    for (let i = 0; i !== N; i++) {
      const b = bodies[i];
      const centerX = b.position.x;
      sumX += centerX;
      sumX2 += centerX * centerX;
      const centerY = b.position.y;
      sumY += centerY;
      sumY2 += centerY * centerY;
      const centerZ = b.position.z;
      sumZ += centerZ;
      sumZ2 += centerZ * centerZ;
    }

    const varianceX = sumX2 - sumX * sumX * invN;
    const varianceY = sumY2 - sumY * sumY * invN;
    const varianceZ = sumZ2 - sumZ * sumZ * invN;

    if (varianceX > varianceY) {
      if (varianceX > varianceZ) {
        this.axisIndex = 0;
      } else {
        this.axisIndex = 2;
      }
    } else if (varianceY > varianceZ) {
      this.axisIndex = 1;
    } else {
      this.axisIndex = 2;
    }
  }
  /**
   * Returns all the bodies within an AABB.
   * @param result An array to store resulting bodies in.
   */


  aabbQuery(world, aabb, result = []) {
    if (this.dirty) {
      this.sortList();
      this.dirty = false;
    }

    const axisIndex = this.axisIndex;
    let axis = 'x';

    if (axisIndex === 1) {
      axis = 'y';
    }

    if (axisIndex === 2) {
      axis = 'z';
    }

    const axisList = this.axisList;
    aabb.lowerBound[axis];
    aabb.upperBound[axis];

    for (let i = 0; i < axisList.length; i++) {
      const b = axisList[i];

      if (b.aabbNeedsUpdate) {
        b.updateAABB();
      }

      if (b.aabb.overlaps(aabb)) {
        result.push(b);
      }
    }

    return result;
  }

}

class Utils {
  /**
   * Extend an options object with default values.
   * @param options The options object. May be falsy: in this case, a new object is created and returned.
   * @param defaults An object containing default values.
   * @return The modified options object.
   */
  static defaults(options = {}, defaults) {
    for (let key in defaults) {
      if (!(key in options)) {
        options[key] = defaults[key];
      }
    }

    return options;
  }

}

/**
 * Constraint base class
 */
class Constraint {
  /**
   * Equations to be solved in this constraint.
   */

  /**
   * Body A.
   */

  /**
   * Body B.
   */

  /**
   * Set to false if you don't want the bodies to collide when they are connected.
   */
  constructor(bodyA, bodyB, options = {}) {
    this.equations = void 0;
    this.bodyA = void 0;
    this.bodyB = void 0;
    this.id = void 0;
    this.collideConnected = void 0;
    options = Utils.defaults(options, {
      collideConnected: true,
      wakeUpBodies: true
    });
    this.equations = [];
    this.bodyA = bodyA;
    this.bodyB = bodyB;
    this.id = Constraint.idCounter++;
    this.collideConnected = options.collideConnected;

    if (options.wakeUpBodies) {
      if (bodyA) {
        bodyA.wakeUp();
      }

      if (bodyB) {
        bodyB.wakeUp();
      }
    }
  }
  /**
   * Update all the equations with data.
   */


  update() {
    throw new Error('method update() not implmemented in this Constraint subclass!');
  }
  /**
   * Enables all equations in the constraint.
   */


  enable() {
    const eqs = this.equations;

    for (let i = 0; i < eqs.length; i++) {
      eqs[i].enabled = true;
    }
  }
  /**
   * Disables all equations in the constraint.
   */


  disable() {
    const eqs = this.equations;

    for (let i = 0; i < eqs.length; i++) {
      eqs[i].enabled = false;
    }
  }

}
Constraint.idCounter = 0;

/**
 * An element containing 6 entries, 3 spatial and 3 rotational degrees of freedom.
 */

class JacobianElement {
  /**
   * spatial
   */

  /**
   * rotational
   */
  constructor() {
    this.spatial = void 0;
    this.rotational = void 0;
    this.spatial = new Vec3();
    this.rotational = new Vec3();
  }
  /**
   * Multiply with other JacobianElement
   */


  multiplyElement(element) {
    return element.spatial.dot(this.spatial) + element.rotational.dot(this.rotational);
  }
  /**
   * Multiply with two vectors
   */


  multiplyVectors(spatial, rotational) {
    return spatial.dot(this.spatial) + rotational.dot(this.rotational);
  }

}

/**
 * Equation base class.
 *
 * `a`, `b` and `eps` are {@link https://www8.cs.umu.se/kurser/5DV058/VT15/lectures/SPOOKlabnotes.pdf SPOOK} parameters that default to `0.0`. See {@link https://github.com/schteppe/cannon.js/issues/238#issuecomment-147172327 this exchange} for more details on Cannon's physics implementation.
 */
class Equation {
  /**
   * Minimum (read: negative max) force to be applied by the constraint.
   */

  /**
   * Maximum (read: positive max) force to be applied by the constraint.
   */

  /**
   * SPOOK parameter
   */

  /**
   * SPOOK parameter
   */

  /**
   * SPOOK parameter
   */

  /**
   * A number, proportional to the force added to the bodies.
   */
  constructor(bi, bj, minForce = -1e6, maxForce = 1e6) {
    this.id = void 0;
    this.minForce = void 0;
    this.maxForce = void 0;
    this.bi = void 0;
    this.bj = void 0;
    this.si = void 0;
    this.sj = void 0;
    this.a = void 0;
    this.b = void 0;
    this.eps = void 0;
    this.jacobianElementA = void 0;
    this.jacobianElementB = void 0;
    this.enabled = void 0;
    this.multiplier = void 0;
    this.id = Equation.idCounter++;
    this.minForce = minForce;
    this.maxForce = maxForce;
    this.bi = bi;
    this.bj = bj;
    this.a = 0.0; // SPOOK parameter

    this.b = 0.0; // SPOOK parameter

    this.eps = 0.0; // SPOOK parameter

    this.jacobianElementA = new JacobianElement();
    this.jacobianElementB = new JacobianElement();
    this.enabled = true;
    this.multiplier = 0;
    this.setSpookParams(1e7, 4, 1 / 60); // Set typical spook params
  }
  /**
   * Recalculates a, b, and eps.
   *
   * The Equation constructor sets typical SPOOK parameters as such:
   * * `stiffness` = 1e7
   * * `relaxation` = 4
   * * `timeStep`= 1 / 60, _note the hardcoded refresh rate._
   */


  setSpookParams(stiffness, relaxation, timeStep) {
    const d = relaxation;
    const k = stiffness;
    const h = timeStep;
    this.a = 4.0 / (h * (1 + 4 * d));
    this.b = 4.0 * d / (1 + 4 * d);
    this.eps = 4.0 / (h * h * k * (1 + 4 * d));
  }
  /**
   * Computes the right hand side of the SPOOK equation
   */


  computeB(a, b, h) {
    const GW = this.computeGW();
    const Gq = this.computeGq();
    const GiMf = this.computeGiMf();
    return -Gq * a - GW * b - GiMf * h;
  }
  /**
   * Computes G*q, where q are the generalized body coordinates
   */


  computeGq() {
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB;
    const bi = this.bi;
    const bj = this.bj;
    const xi = bi.position;
    const xj = bj.position;
    return GA.spatial.dot(xi) + GB.spatial.dot(xj);
  }
  /**
   * Computes G*W, where W are the body velocities
   */


  computeGW() {
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB;
    const bi = this.bi;
    const bj = this.bj;
    const vi = bi.velocity;
    const vj = bj.velocity;
    const wi = bi.angularVelocity;
    const wj = bj.angularVelocity;
    return GA.multiplyVectors(vi, wi) + GB.multiplyVectors(vj, wj);
  }
  /**
   * Computes G*Wlambda, where W are the body velocities
   */


  computeGWlambda() {
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB;
    const bi = this.bi;
    const bj = this.bj;
    const vi = bi.vlambda;
    const vj = bj.vlambda;
    const wi = bi.wlambda;
    const wj = bj.wlambda;
    return GA.multiplyVectors(vi, wi) + GB.multiplyVectors(vj, wj);
  }
  /**
   * Computes G*inv(M)*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.
   */


  computeGiMf() {
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB;
    const bi = this.bi;
    const bj = this.bj;
    const fi = bi.force;
    const ti = bi.torque;
    const fj = bj.force;
    const tj = bj.torque;
    const invMassi = bi.invMassSolve;
    const invMassj = bj.invMassSolve;
    fi.scale(invMassi, iMfi);
    fj.scale(invMassj, iMfj);
    bi.invInertiaWorldSolve.vmult(ti, invIi_vmult_taui);
    bj.invInertiaWorldSolve.vmult(tj, invIj_vmult_tauj);
    return GA.multiplyVectors(iMfi, invIi_vmult_taui) + GB.multiplyVectors(iMfj, invIj_vmult_tauj);
  }
  /**
   * Computes G*inv(M)*G'
   */


  computeGiMGt() {
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB;
    const bi = this.bi;
    const bj = this.bj;
    const invMassi = bi.invMassSolve;
    const invMassj = bj.invMassSolve;
    const invIi = bi.invInertiaWorldSolve;
    const invIj = bj.invInertiaWorldSolve;
    let result = invMassi + invMassj;
    invIi.vmult(GA.rotational, tmp);
    result += tmp.dot(GA.rotational);
    invIj.vmult(GB.rotational, tmp);
    result += tmp.dot(GB.rotational);
    return result;
  }
  /**
   * Add constraint velocity to the bodies.
   */


  addToWlambda(deltalambda) {
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB;
    const bi = this.bi;
    const bj = this.bj;
    const temp = addToWlambda_temp; // Add to linear velocity
    // v_lambda += inv(M) * delta_lamba * G

    bi.vlambda.addScaledVector(bi.invMassSolve * deltalambda, GA.spatial, bi.vlambda);
    bj.vlambda.addScaledVector(bj.invMassSolve * deltalambda, GB.spatial, bj.vlambda); // Add to angular velocity

    bi.invInertiaWorldSolve.vmult(GA.rotational, temp);
    bi.wlambda.addScaledVector(deltalambda, temp, bi.wlambda);
    bj.invInertiaWorldSolve.vmult(GB.rotational, temp);
    bj.wlambda.addScaledVector(deltalambda, temp, bj.wlambda);
  }
  /**
   * Compute the denominator part of the SPOOK equation: C = G*inv(M)*G' + eps
   */


  computeC() {
    return this.computeGiMGt() + this.eps;
  }

}
Equation.idCounter = 0;
const iMfi = new Vec3();
const iMfj = new Vec3();
const invIi_vmult_taui = new Vec3();
const invIj_vmult_tauj = new Vec3();
const tmp = new Vec3();
const addToWlambda_temp = new Vec3();

/**
 * Contact/non-penetration constraint equation
 */
class ContactEquation extends Equation {
  /**
   * "bounciness": u1 = -e*u0
   */

  /**
   * World-oriented vector that goes from the center of bi to the contact point.
   */

  /**
   * World-oriented vector that starts in body j position and goes to the contact point.
   */

  /**
   * Contact normal, pointing out of body i.
   */
  constructor(bodyA, bodyB, maxForce = 1e6) {
    super(bodyA, bodyB, 0, maxForce);
    this.restitution = void 0;
    this.ri = void 0;
    this.rj = void 0;
    this.ni = void 0;
    this.restitution = 0.0;
    this.ri = new Vec3();
    this.rj = new Vec3();
    this.ni = new Vec3();
  }

  computeB(h) {
    const a = this.a;
    const b = this.b;
    const bi = this.bi;
    const bj = this.bj;
    const ri = this.ri;
    const rj = this.rj;
    const rixn = ContactEquation_computeB_temp1;
    const rjxn = ContactEquation_computeB_temp2;
    const vi = bi.velocity;
    const wi = bi.angularVelocity;
    bi.force;
    bi.torque;
    const vj = bj.velocity;
    const wj = bj.angularVelocity;
    bj.force;
    bj.torque;
    const penetrationVec = ContactEquation_computeB_temp3;
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB;
    const n = this.ni; // Caluclate cross products

    ri.cross(n, rixn);
    rj.cross(n, rjxn); // g = xj+rj -(xi+ri)
    // G = [ -ni  -rixn  ni  rjxn ]

    n.negate(GA.spatial);
    rixn.negate(GA.rotational);
    GB.spatial.copy(n);
    GB.rotational.copy(rjxn); // Calculate the penetration vector

    penetrationVec.copy(bj.position);
    penetrationVec.vadd(rj, penetrationVec);
    penetrationVec.vsub(bi.position, penetrationVec);
    penetrationVec.vsub(ri, penetrationVec);
    const g = n.dot(penetrationVec); // Compute iteration

    const ePlusOne = this.restitution + 1;
    const GW = ePlusOne * vj.dot(n) - ePlusOne * vi.dot(n) + wj.dot(rjxn) - wi.dot(rixn);
    const GiMf = this.computeGiMf();
    const B = -g * a - GW * b - h * GiMf;
    return B;
  }
  /**
   * Get the current relative velocity in the contact point.
   */


  getImpactVelocityAlongNormal() {
    const vi = ContactEquation_getImpactVelocityAlongNormal_vi;
    const vj = ContactEquation_getImpactVelocityAlongNormal_vj;
    const xi = ContactEquation_getImpactVelocityAlongNormal_xi;
    const xj = ContactEquation_getImpactVelocityAlongNormal_xj;
    const relVel = ContactEquation_getImpactVelocityAlongNormal_relVel;
    this.bi.position.vadd(this.ri, xi);
    this.bj.position.vadd(this.rj, xj);
    this.bi.getVelocityAtWorldPoint(xi, vi);
    this.bj.getVelocityAtWorldPoint(xj, vj);
    vi.vsub(vj, relVel);
    return this.ni.dot(relVel);
  }

}
const ContactEquation_computeB_temp1 = new Vec3(); // Temp vectors

const ContactEquation_computeB_temp2 = new Vec3();
const ContactEquation_computeB_temp3 = new Vec3();
const ContactEquation_getImpactVelocityAlongNormal_vi = new Vec3();
const ContactEquation_getImpactVelocityAlongNormal_vj = new Vec3();
const ContactEquation_getImpactVelocityAlongNormal_xi = new Vec3();
const ContactEquation_getImpactVelocityAlongNormal_xj = new Vec3();
const ContactEquation_getImpactVelocityAlongNormal_relVel = new Vec3();

/**
 * Connects two bodies at given offset points.
 * @example
 *     const bodyA = new Body({ mass: 1 })
 *     const bodyB = new Body({ mass: 1 })
 *     bodyA.position.set(-1, 0, 0)
 *     bodyB.position.set(1, 0, 0)
 *     bodyA.addShape(shapeA)
 *     bodyB.addShape(shapeB)
 *     world.addBody(bodyA)
 *     world.addBody(bodyB)
 *     const localPivotA = new Vec3(1, 0, 0)
 *     const localPivotB = new Vec3(-1, 0, 0)
 *     const constraint = new PointToPointConstraint(bodyA, localPivotA, bodyB, localPivotB)
 *     world.addConstraint(constraint)
 */
class PointToPointConstraint extends Constraint {
  /**
   * Pivot, defined locally in bodyA.
   */

  /**
   * Pivot, defined locally in bodyB.
   */

  /**
   * @param pivotA The point relative to the center of mass of bodyA which bodyA is constrained to.
   * @param bodyB Body that will be constrained in a similar way to the same point as bodyA. We will therefore get a link between bodyA and bodyB. If not specified, bodyA will be constrained to a static point.
   * @param pivotB The point relative to the center of mass of bodyB which bodyB is constrained to.
   * @param maxForce The maximum force that should be applied to constrain the bodies.
   */
  constructor(bodyA, pivotA = new Vec3(), bodyB, pivotB = new Vec3(), maxForce = 1e6) {
    super(bodyA, bodyB);
    this.pivotA = void 0;
    this.pivotB = void 0;
    this.equationX = void 0;
    this.equationY = void 0;
    this.equationZ = void 0;
    this.pivotA = pivotA.clone();
    this.pivotB = pivotB.clone();
    const x = this.equationX = new ContactEquation(bodyA, bodyB);
    const y = this.equationY = new ContactEquation(bodyA, bodyB);
    const z = this.equationZ = new ContactEquation(bodyA, bodyB); // Equations to be fed to the solver

    this.equations.push(x, y, z); // Make the equations bidirectional

    x.minForce = y.minForce = z.minForce = -maxForce;
    x.maxForce = y.maxForce = z.maxForce = maxForce;
    x.ni.set(1, 0, 0);
    y.ni.set(0, 1, 0);
    z.ni.set(0, 0, 1);
  }

  update() {
    const bodyA = this.bodyA;
    const bodyB = this.bodyB;
    const x = this.equationX;
    const y = this.equationY;
    const z = this.equationZ; // Rotate the pivots to world space

    bodyA.quaternion.vmult(this.pivotA, x.ri);
    bodyB.quaternion.vmult(this.pivotB, x.rj);
    y.ri.copy(x.ri);
    y.rj.copy(x.rj);
    z.ri.copy(x.ri);
    z.rj.copy(x.rj);
  }

}

/**
 * Cone equation. Works to keep the given body world vectors aligned, or tilted within a given angle from each other.
 */
class ConeEquation extends Equation {
  /**
   * Local axis in A
   */

  /**
   * Local axis in B
   */

  /**
   * The "cone angle" to keep
   */
  constructor(bodyA, bodyB, options = {}) {
    const maxForce = typeof options.maxForce !== 'undefined' ? options.maxForce : 1e6;
    super(bodyA, bodyB, -maxForce, maxForce);
    this.axisA = void 0;
    this.axisB = void 0;
    this.angle = void 0;
    this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);
    this.axisB = options.axisB ? options.axisB.clone() : new Vec3(0, 1, 0);
    this.angle = typeof options.angle !== 'undefined' ? options.angle : 0;
  }

  computeB(h) {
    const a = this.a;
    const b = this.b;
    const ni = this.axisA;
    const nj = this.axisB;
    const nixnj = tmpVec1$2;
    const njxni = tmpVec2$2;
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB; // Caluclate cross products

    ni.cross(nj, nixnj);
    nj.cross(ni, njxni); // The angle between two vector is:
    // cos(theta) = a * b / (length(a) * length(b) = { len(a) = len(b) = 1 } = a * b
    // g = a * b
    // gdot = (b x a) * wi + (a x b) * wj
    // G = [0 bxa 0 axb]
    // W = [vi wi vj wj]

    GA.rotational.copy(njxni);
    GB.rotational.copy(nixnj);
    const g = Math.cos(this.angle) - ni.dot(nj);
    const GW = this.computeGW();
    const GiMf = this.computeGiMf();
    const B = -g * a - GW * b - h * GiMf;
    return B;
  }

}
const tmpVec1$2 = new Vec3();
const tmpVec2$2 = new Vec3();

/**
 * Rotational constraint. Works to keep the local vectors orthogonal to each other in world space.
 */
class RotationalEquation extends Equation {
  /**
   * World oriented rotational axis.
   */

  /**
   * World oriented rotational axis.
   */

  /**
   * maxAngle
   */
  constructor(bodyA, bodyB, options = {}) {
    const maxForce = typeof options.maxForce !== 'undefined' ? options.maxForce : 1e6;
    super(bodyA, bodyB, -maxForce, maxForce);
    this.axisA = void 0;
    this.axisB = void 0;
    this.maxAngle = void 0;
    this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);
    this.axisB = options.axisB ? options.axisB.clone() : new Vec3(0, 1, 0);
    this.maxAngle = Math.PI / 2;
  }

  computeB(h) {
    const a = this.a;
    const b = this.b;
    const ni = this.axisA;
    const nj = this.axisB;
    const nixnj = tmpVec1$1;
    const njxni = tmpVec2$1;
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB; // Caluclate cross products

    ni.cross(nj, nixnj);
    nj.cross(ni, njxni); // g = ni * nj
    // gdot = (nj x ni) * wi + (ni x nj) * wj
    // G = [0 njxni 0 nixnj]
    // W = [vi wi vj wj]

    GA.rotational.copy(njxni);
    GB.rotational.copy(nixnj);
    const g = Math.cos(this.maxAngle) - ni.dot(nj);
    const GW = this.computeGW();
    const GiMf = this.computeGiMf();
    const B = -g * a - GW * b - h * GiMf;
    return B;
  }

}
const tmpVec1$1 = new Vec3();
const tmpVec2$1 = new Vec3();

/**
 * A Cone Twist constraint, useful for ragdolls.
 */
class ConeTwistConstraint extends PointToPointConstraint {
  /**
   * The axis direction for the constraint of the body A.
   */

  /**
   * The axis direction for the constraint of the body B.
   */

  /**
   * The aperture angle of the cone.
   */

  /**
   * The twist angle of the joint.
   */
  constructor(bodyA, bodyB, options = {}) {
    const maxForce = typeof options.maxForce !== 'undefined' ? options.maxForce : 1e6; // Set pivot point in between

    const pivotA = options.pivotA ? options.pivotA.clone() : new Vec3();
    const pivotB = options.pivotB ? options.pivotB.clone() : new Vec3();
    super(bodyA, pivotA, bodyB, pivotB, maxForce);
    this.axisA = void 0;
    this.axisB = void 0;
    this.angle = void 0;
    this.twistAngle = void 0;
    this.coneEquation = void 0;
    this.twistEquation = void 0;
    this.axisA = options.axisA ? options.axisA.clone() : new Vec3();
    this.axisB = options.axisB ? options.axisB.clone() : new Vec3();
    this.collideConnected = !!options.collideConnected;
    this.angle = typeof options.angle !== 'undefined' ? options.angle : 0;
    const c = this.coneEquation = new ConeEquation(bodyA, bodyB, options);
    const t = this.twistEquation = new RotationalEquation(bodyA, bodyB, options);
    this.twistAngle = typeof options.twistAngle !== 'undefined' ? options.twistAngle : 0; // Make the cone equation push the bodies toward the cone axis, not outward

    c.maxForce = 0;
    c.minForce = -maxForce; // Make the twist equation add torque toward the initial position

    t.maxForce = 0;
    t.minForce = -maxForce;
    this.equations.push(c, t);
  }

  update() {
    const bodyA = this.bodyA;
    const bodyB = this.bodyB;
    const cone = this.coneEquation;
    const twist = this.twistEquation;
    super.update(); // Update the axes to the cone constraint

    bodyA.vectorToWorldFrame(this.axisA, cone.axisA);
    bodyB.vectorToWorldFrame(this.axisB, cone.axisB); // Update the world axes in the twist constraint

    this.axisA.tangents(twist.axisA, twist.axisA);
    bodyA.vectorToWorldFrame(twist.axisA, twist.axisA);
    this.axisB.tangents(twist.axisB, twist.axisB);
    bodyB.vectorToWorldFrame(twist.axisB, twist.axisB);
    cone.angle = this.angle;
    twist.maxAngle = this.twistAngle;
  }

}

/**
 * Constrains two bodies to be at a constant distance from each others center of mass.
 */
class DistanceConstraint extends Constraint {
  /**
   * The distance to keep. If undefined, it will be set to the current distance between bodyA and bodyB
   */

  /**
   * @param distance The distance to keep. If undefined, it will be set to the current distance between bodyA and bodyB.
   * @param maxForce The maximum force that should be applied to constrain the bodies.
   */
  constructor(bodyA, bodyB, distance, maxForce = 1e6) {
    super(bodyA, bodyB);
    this.distance = void 0;
    this.distanceEquation = void 0;

    if (typeof distance === 'undefined') {
      distance = bodyA.position.distanceTo(bodyB.position);
    }

    this.distance = distance;
    const eq = this.distanceEquation = new ContactEquation(bodyA, bodyB);
    this.equations.push(eq); // Make it bidirectional

    eq.minForce = -maxForce;
    eq.maxForce = maxForce;
  }
  /**
   * update
   */


  update() {
    const bodyA = this.bodyA;
    const bodyB = this.bodyB;
    const eq = this.distanceEquation;
    const halfDist = this.distance * 0.5;
    const normal = eq.ni;
    bodyB.position.vsub(bodyA.position, normal);
    normal.normalize();
    normal.scale(halfDist, eq.ri);
    normal.scale(-halfDist, eq.rj);
  }

}

/**
 * Lock constraint. Will remove all degrees of freedom between the bodies.
 */
class LockConstraint extends PointToPointConstraint {
  constructor(bodyA, bodyB, options = {}) {
    const maxForce = typeof options.maxForce !== 'undefined' ? options.maxForce : 1e6; // Set pivot point in between

    const pivotA = new Vec3();
    const pivotB = new Vec3();
    const halfWay = new Vec3();
    bodyA.position.vadd(bodyB.position, halfWay);
    halfWay.scale(0.5, halfWay);
    bodyB.pointToLocalFrame(halfWay, pivotB);
    bodyA.pointToLocalFrame(halfWay, pivotA); // The point-to-point constraint will keep a point shared between the bodies

    super(bodyA, pivotA, bodyB, pivotB, maxForce); // Store initial rotation of the bodies as unit vectors in the local body spaces

    this.xA = void 0;
    this.xB = void 0;
    this.yA = void 0;
    this.yB = void 0;
    this.zA = void 0;
    this.zB = void 0;
    this.rotationalEquation1 = void 0;
    this.rotationalEquation2 = void 0;
    this.rotationalEquation3 = void 0;
    this.motorEquation = void 0;
    this.xA = bodyA.vectorToLocalFrame(Vec3.UNIT_X);
    this.xB = bodyB.vectorToLocalFrame(Vec3.UNIT_X);
    this.yA = bodyA.vectorToLocalFrame(Vec3.UNIT_Y);
    this.yB = bodyB.vectorToLocalFrame(Vec3.UNIT_Y);
    this.zA = bodyA.vectorToLocalFrame(Vec3.UNIT_Z);
    this.zB = bodyB.vectorToLocalFrame(Vec3.UNIT_Z); // ...and the following rotational equations will keep all rotational DOF's in place

    const r1 = this.rotationalEquation1 = new RotationalEquation(bodyA, bodyB, options);
    const r2 = this.rotationalEquation2 = new RotationalEquation(bodyA, bodyB, options);
    const r3 = this.rotationalEquation3 = new RotationalEquation(bodyA, bodyB, options);
    this.equations.push(r1, r2, r3);
  }
  /**
   * update
   */


  update() {
    const bodyA = this.bodyA;
    const bodyB = this.bodyB;
    this.motorEquation;
    const r1 = this.rotationalEquation1;
    const r2 = this.rotationalEquation2;
    const r3 = this.rotationalEquation3;
    super.update(); // These vector pairs must be orthogonal

    bodyA.vectorToWorldFrame(this.xA, r1.axisA);
    bodyB.vectorToWorldFrame(this.yB, r1.axisB);
    bodyA.vectorToWorldFrame(this.yA, r2.axisA);
    bodyB.vectorToWorldFrame(this.zB, r2.axisB);
    bodyA.vectorToWorldFrame(this.zA, r3.axisA);
    bodyB.vectorToWorldFrame(this.xB, r3.axisB);
  }

}

/**
 * Rotational motor constraint. Tries to keep the relative angular velocity of the bodies to a given value.
 */
class RotationalMotorEquation extends Equation {
  /**
   * World oriented rotational axis.
   */

  /**
   * World oriented rotational axis.
   */

  /**
   * Motor velocity.
   */
  constructor(bodyA, bodyB, maxForce = 1e6) {
    super(bodyA, bodyB, -maxForce, maxForce);
    this.axisA = void 0;
    this.axisB = void 0;
    this.targetVelocity = void 0;
    this.axisA = new Vec3();
    this.axisB = new Vec3();
    this.targetVelocity = 0;
  }

  computeB(h) {
    this.a;
    const b = this.b;
    this.bi;
    this.bj;
    const axisA = this.axisA;
    const axisB = this.axisB;
    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB; // g = 0
    // gdot = axisA * wi - axisB * wj
    // gdot = G * W = G * [vi wi vj wj]
    // =>
    // G = [0 axisA 0 -axisB]

    GA.rotational.copy(axisA);
    axisB.negate(GB.rotational);
    const GW = this.computeGW() - this.targetVelocity;
    const GiMf = this.computeGiMf();
    const B = -GW * b - h * GiMf;
    return B;
  }

}

/**
 * Hinge constraint. Think of it as a door hinge. It tries to keep the door in the correct place and with the correct orientation.
 */
class HingeConstraint extends PointToPointConstraint {
  /**
   * Rotation axis, defined locally in bodyA.
   */

  /**
   * Rotation axis, defined locally in bodyB.
   */
  constructor(bodyA, bodyB, options = {}) {
    const maxForce = typeof options.maxForce !== 'undefined' ? options.maxForce : 1e6;
    const pivotA = options.pivotA ? options.pivotA.clone() : new Vec3();
    const pivotB = options.pivotB ? options.pivotB.clone() : new Vec3();
    super(bodyA, pivotA, bodyB, pivotB, maxForce);
    this.axisA = void 0;
    this.axisB = void 0;
    this.rotationalEquation1 = void 0;
    this.rotationalEquation2 = void 0;
    this.motorEquation = void 0;
    const axisA = this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);
    axisA.normalize();
    const axisB = this.axisB = options.axisB ? options.axisB.clone() : new Vec3(1, 0, 0);
    axisB.normalize();
    this.collideConnected = !!options.collideConnected;
    const rotational1 = this.rotationalEquation1 = new RotationalEquation(bodyA, bodyB, options);
    const rotational2 = this.rotationalEquation2 = new RotationalEquation(bodyA, bodyB, options);
    const motor = this.motorEquation = new RotationalMotorEquation(bodyA, bodyB, maxForce);
    motor.enabled = false; // Not enabled by default
    // Equations to be fed to the solver

    this.equations.push(rotational1, rotational2, motor);
  }
  /**
   * enableMotor
   */


  enableMotor() {
    this.motorEquation.enabled = true;
  }
  /**
   * disableMotor
   */


  disableMotor() {
    this.motorEquation.enabled = false;
  }
  /**
   * setMotorSpeed
   */


  setMotorSpeed(speed) {
    this.motorEquation.targetVelocity = speed;
  }
  /**
   * setMotorMaxForce
   */


  setMotorMaxForce(maxForce) {
    this.motorEquation.maxForce = maxForce;
    this.motorEquation.minForce = -maxForce;
  }
  /**
   * update
   */


  update() {
    const bodyA = this.bodyA;
    const bodyB = this.bodyB;
    const motor = this.motorEquation;
    const r1 = this.rotationalEquation1;
    const r2 = this.rotationalEquation2;
    const worldAxisA = HingeConstraint_update_tmpVec1;
    const worldAxisB = HingeConstraint_update_tmpVec2;
    const axisA = this.axisA;
    const axisB = this.axisB;
    super.update(); // Get world axes

    bodyA.quaternion.vmult(axisA, worldAxisA);
    bodyB.quaternion.vmult(axisB, worldAxisB);
    worldAxisA.tangents(r1.axisA, r2.axisA);
    r1.axisB.copy(worldAxisB);
    r2.axisB.copy(worldAxisB);

    if (this.motorEquation.enabled) {
      bodyA.quaternion.vmult(this.axisA, motor.axisA);
      bodyB.quaternion.vmult(this.axisB, motor.axisB);
    }
  }

}
const HingeConstraint_update_tmpVec1 = new Vec3();
const HingeConstraint_update_tmpVec2 = new Vec3();

/**
 * Constrains the slipping in a contact along a tangent
 */
class FrictionEquation extends Equation {
  // Tangent

  /**
   * @param slipForce should be +-F_friction = +-mu * F_normal = +-mu * m * g
   */
  constructor(bodyA, bodyB, slipForce) {
    super(bodyA, bodyB, -slipForce, slipForce);
    this.ri = void 0;
    this.rj = void 0;
    this.t = void 0;
    this.ri = new Vec3();
    this.rj = new Vec3();
    this.t = new Vec3();
  }

  computeB(h) {
    this.a;
    const b = this.b;
    this.bi;
    this.bj;
    const ri = this.ri;
    const rj = this.rj;
    const rixt = FrictionEquation_computeB_temp1;
    const rjxt = FrictionEquation_computeB_temp2;
    const t = this.t; // Caluclate cross products

    ri.cross(t, rixt);
    rj.cross(t, rjxt); // G = [-t -rixt t rjxt]
    // And remember, this is a pure velocity constraint, g is always zero!

    const GA = this.jacobianElementA;
    const GB = this.jacobianElementB;
    t.negate(GA.spatial);
    rixt.negate(GA.rotational);
    GB.spatial.copy(t);
    GB.rotational.copy(rjxt);
    const GW = this.computeGW();
    const GiMf = this.computeGiMf();
    const B = -GW * b - h * GiMf;
    return B;
  }

}
const FrictionEquation_computeB_temp1 = new Vec3();
const FrictionEquation_computeB_temp2 = new Vec3();

/**
 * Defines what happens when two materials meet.
 * @todo Refactor materials to materialA and materialB
 */
class ContactMaterial {
  /**
   * Identifier of this material.
   */

  /**
   * Participating materials.
   */

  /**
   * Friction coefficient.
   * @default 0.3
   */

  /**
   * Restitution coefficient.
   * @default 0.3
   */

  /**
   * Stiffness of the produced contact equations.
   * @default 1e7
   */

  /**
   * Relaxation time of the produced contact equations.
   * @default 3
   */

  /**
   * Stiffness of the produced friction equations.
   * @default 1e7
   */

  /**
   * Relaxation time of the produced friction equations
   * @default 3
   */
  constructor(m1, m2, options) {
    this.id = void 0;
    this.materials = void 0;
    this.friction = void 0;
    this.restitution = void 0;
    this.contactEquationStiffness = void 0;
    this.contactEquationRelaxation = void 0;
    this.frictionEquationStiffness = void 0;
    this.frictionEquationRelaxation = void 0;
    options = Utils.defaults(options, {
      friction: 0.3,
      restitution: 0.3,
      contactEquationStiffness: 1e7,
      contactEquationRelaxation: 3,
      frictionEquationStiffness: 1e7,
      frictionEquationRelaxation: 3
    });
    this.id = ContactMaterial.idCounter++;
    this.materials = [m1, m2];
    this.friction = options.friction;
    this.restitution = options.restitution;
    this.contactEquationStiffness = options.contactEquationStiffness;
    this.contactEquationRelaxation = options.contactEquationRelaxation;
    this.frictionEquationStiffness = options.frictionEquationStiffness;
    this.frictionEquationRelaxation = options.frictionEquationRelaxation;
  }

}
ContactMaterial.idCounter = 0;

/**
 * Defines a physics material.
 */
class Material {
  /**
   * Material name.
   * If options is a string, name will be set to that string.
   * @todo Deprecate this
   */

  /** Material id. */

  /**
   * Friction for this material.
   * If non-negative, it will be used instead of the friction given by ContactMaterials. If there's no matching ContactMaterial, the value from `defaultContactMaterial` in the World will be used.
   */

  /**
   * Restitution for this material.
   * If non-negative, it will be used instead of the restitution given by ContactMaterials. If there's no matching ContactMaterial, the value from `defaultContactMaterial` in the World will be used.
   */
  constructor(options = {}) {
    this.name = void 0;
    this.id = void 0;
    this.friction = void 0;
    this.restitution = void 0;
    let name = ''; // Backwards compatibility fix

    if (typeof options === 'string') {
      //console.warn(`Passing a string to MaterialOptions is deprecated, and has no effect`)
      name = options;
      options = {};
    }

    this.name = name;
    this.id = Material.idCounter++;
    this.friction = typeof options.friction !== 'undefined' ? options.friction : -1;
    this.restitution = typeof options.restitution !== 'undefined' ? options.restitution : -1;
  }

}
Material.idCounter = 0;

/**
 * A spring, connecting two bodies.
 * @example
 *     const spring = new Spring(boxBody, sphereBody, {
 *       restLength: 0,
 *       stiffness: 50,
 *       damping: 1,
 *     })
 *
 *     // Compute the force after each step
 *     world.addEventListener('postStep', (event) => {
 *       spring.applyForce()
 *     })
 */
class Spring {
  /**
   * Rest length of the spring. A number > 0.
   * @default 1
   */

  /**
   * Stiffness of the spring. A number >= 0.
   * @default 100
   */

  /**
   * Damping of the spring. A number >= 0.
   * @default 1
   */

  /**
   * First connected body.
   */

  /**
   * Second connected body.
   */

  /**
   * Anchor for bodyA in local bodyA coordinates.
   * Where to hook the spring to body A, in local body coordinates.
   * @default new Vec3()
   */

  /**
   * Anchor for bodyB in local bodyB coordinates.
   * Where to hook the spring to body B, in local body coordinates.
   * @default new Vec3()
   */
  constructor(bodyA, bodyB, options = {}) {
    this.restLength = void 0;
    this.stiffness = void 0;
    this.damping = void 0;
    this.bodyA = void 0;
    this.bodyB = void 0;
    this.localAnchorA = void 0;
    this.localAnchorB = void 0;
    this.restLength = typeof options.restLength === 'number' ? options.restLength : 1;
    this.stiffness = options.stiffness || 100;
    this.damping = options.damping || 1;
    this.bodyA = bodyA;
    this.bodyB = bodyB;
    this.localAnchorA = new Vec3();
    this.localAnchorB = new Vec3();

    if (options.localAnchorA) {
      this.localAnchorA.copy(options.localAnchorA);
    }

    if (options.localAnchorB) {
      this.localAnchorB.copy(options.localAnchorB);
    }

    if (options.worldAnchorA) {
      this.setWorldAnchorA(options.worldAnchorA);
    }

    if (options.worldAnchorB) {
      this.setWorldAnchorB(options.worldAnchorB);
    }
  }
  /**
   * Set the anchor point on body A, using world coordinates.
   */


  setWorldAnchorA(worldAnchorA) {
    this.bodyA.pointToLocalFrame(worldAnchorA, this.localAnchorA);
  }
  /**
   * Set the anchor point on body B, using world coordinates.
   */


  setWorldAnchorB(worldAnchorB) {
    this.bodyB.pointToLocalFrame(worldAnchorB, this.localAnchorB);
  }
  /**
   * Get the anchor point on body A, in world coordinates.
   * @param result The vector to store the result in.
   */


  getWorldAnchorA(result) {
    this.bodyA.pointToWorldFrame(this.localAnchorA, result);
  }
  /**
   * Get the anchor point on body B, in world coordinates.
   * @param result The vector to store the result in.
   */


  getWorldAnchorB(result) {
    this.bodyB.pointToWorldFrame(this.localAnchorB, result);
  }
  /**
   * Apply the spring force to the connected bodies.
   */


  applyForce() {
    const k = this.stiffness;
    const d = this.damping;
    const l = this.restLength;
    const bodyA = this.bodyA;
    const bodyB = this.bodyB;
    const r = applyForce_r;
    const r_unit = applyForce_r_unit;
    const u = applyForce_u;
    const f = applyForce_f;
    const tmp = applyForce_tmp;
    const worldAnchorA = applyForce_worldAnchorA;
    const worldAnchorB = applyForce_worldAnchorB;
    const ri = applyForce_ri;
    const rj = applyForce_rj;
    const ri_x_f = applyForce_ri_x_f;
    const rj_x_f = applyForce_rj_x_f; // Get world anchors

    this.getWorldAnchorA(worldAnchorA);
    this.getWorldAnchorB(worldAnchorB); // Get offset points

    worldAnchorA.vsub(bodyA.position, ri);
    worldAnchorB.vsub(bodyB.position, rj); // Compute distance vector between world anchor points

    worldAnchorB.vsub(worldAnchorA, r);
    const rlen = r.length();
    r_unit.copy(r);
    r_unit.normalize(); // Compute relative velocity of the anchor points, u

    bodyB.velocity.vsub(bodyA.velocity, u); // Add rotational velocity

    bodyB.angularVelocity.cross(rj, tmp);
    u.vadd(tmp, u);
    bodyA.angularVelocity.cross(ri, tmp);
    u.vsub(tmp, u); // F = - k * ( x - L ) - D * ( u )

    r_unit.scale(-k * (rlen - l) - d * u.dot(r_unit), f); // Add forces to bodies

    bodyA.force.vsub(f, bodyA.force);
    bodyB.force.vadd(f, bodyB.force); // Angular force

    ri.cross(f, ri_x_f);
    rj.cross(f, rj_x_f);
    bodyA.torque.vsub(ri_x_f, bodyA.torque);
    bodyB.torque.vadd(rj_x_f, bodyB.torque);
  }

}
const applyForce_r = new Vec3();
const applyForce_r_unit = new Vec3();
const applyForce_u = new Vec3();
const applyForce_f = new Vec3();
const applyForce_worldAnchorA = new Vec3();
const applyForce_worldAnchorB = new Vec3();
const applyForce_ri = new Vec3();
const applyForce_rj = new Vec3();
const applyForce_ri_x_f = new Vec3();
const applyForce_rj_x_f = new Vec3();
const applyForce_tmp = new Vec3();

/**
 * WheelInfo
 */
class WheelInfo {
  /**
   * Max travel distance of the suspension, in meters.
   * @default 1
   */

  /**
   * Speed to apply to the wheel rotation when the wheel is sliding.
   * @default -0.1
   */

  /**
   * If the customSlidingRotationalSpeed should be used.
   * @default false
   */

  /**
   * sliding
   */

  /**
   * Connection point, defined locally in the chassis body frame.
   */

  /**
   * chassisConnectionPointWorld
   */

  /**
   * directionLocal
   */

  /**
   * directionWorld
   */

  /**
   * axleLocal
   */

  /**
   * axleWorld
   */

  /**
   * suspensionRestLength
   * @default 1
   */

  /**
   * suspensionMaxLength
   * @default 2
   */

  /**
   * radius
   * @default 1
   */

  /**
   * suspensionStiffness
   * @default 100
   */

  /**
   * dampingCompression
   * @default 10
   */

  /**
   * dampingRelaxation
   * @default 10
   */

  /**
   * frictionSlip
   * @default 10.5
   */

  /** forwardAcceleration */

  /** sideAcceleration */

  /**
   * steering
   * @default 0
   */

  /**
   * Rotation value, in radians.
   * @default 0
   */

  /**
   * deltaRotation
   * @default 0
   */

  /**
   * rollInfluence
   * @default 0.01
   */

  /**
   * maxSuspensionForce
   */

  /**
   * engineForce
   */

  /**
   * brake
   */

  /**
   * isFrontWheel
   * @default true
   */

  /**
   * clippedInvContactDotSuspension
   * @default 1
   */

  /**
   * suspensionRelativeVelocity
   * @default 0
   */

  /**
   * suspensionForce
   * @default 0
   */

  /**
   * slipInfo
   */

  /**
   * skidInfo
   * @default 0
   */

  /**
   * suspensionLength
   * @default 0
   */

  /**
   * sideImpulse
   */

  /**
   * forwardImpulse
   */

  /**
   * The result from raycasting.
   */

  /**
   * Wheel world transform.
   */

  /**
   * isInContact
   */
  constructor(options = {}) {
    this.maxSuspensionTravel = void 0;
    this.customSlidingRotationalSpeed = void 0;
    this.useCustomSlidingRotationalSpeed = void 0;
    this.sliding = void 0;
    this.chassisConnectionPointLocal = void 0;
    this.chassisConnectionPointWorld = void 0;
    this.directionLocal = void 0;
    this.directionWorld = void 0;
    this.axleLocal = void 0;
    this.axleWorld = void 0;
    this.suspensionRestLength = void 0;
    this.suspensionMaxLength = void 0;
    this.radius = void 0;
    this.suspensionStiffness = void 0;
    this.dampingCompression = void 0;
    this.dampingRelaxation = void 0;
    this.frictionSlip = void 0;
    this.forwardAcceleration = void 0;
    this.sideAcceleration = void 0;
    this.steering = void 0;
    this.rotation = void 0;
    this.deltaRotation = void 0;
    this.rollInfluence = void 0;
    this.maxSuspensionForce = void 0;
    this.engineForce = void 0;
    this.brake = void 0;
    this.isFrontWheel = void 0;
    this.clippedInvContactDotSuspension = void 0;
    this.suspensionRelativeVelocity = void 0;
    this.suspensionForce = void 0;
    this.slipInfo = void 0;
    this.skidInfo = void 0;
    this.suspensionLength = void 0;
    this.sideImpulse = void 0;
    this.forwardImpulse = void 0;
    this.raycastResult = void 0;
    this.worldTransform = void 0;
    this.isInContact = void 0;
    options = Utils.defaults(options, {
      chassisConnectionPointLocal: new Vec3(),
      chassisConnectionPointWorld: new Vec3(),
      directionLocal: new Vec3(),
      directionWorld: new Vec3(),
      axleLocal: new Vec3(),
      axleWorld: new Vec3(),
      suspensionRestLength: 1,
      suspensionMaxLength: 2,
      radius: 1,
      suspensionStiffness: 100,
      dampingCompression: 10,
      dampingRelaxation: 10,
      frictionSlip: 10.5,
      forwardAcceleration: 1,
      sideAcceleration: 1,
      steering: 0,
      rotation: 0,
      deltaRotation: 0,
      rollInfluence: 0.01,
      maxSuspensionForce: Number.MAX_VALUE,
      isFrontWheel: true,
      clippedInvContactDotSuspension: 1,
      suspensionRelativeVelocity: 0,
      suspensionForce: 0,
      slipInfo: 0,
      skidInfo: 0,
      suspensionLength: 0,
      maxSuspensionTravel: 1,
      useCustomSlidingRotationalSpeed: false,
      customSlidingRotationalSpeed: -0.1
    });
    this.maxSuspensionTravel = options.maxSuspensionTravel;
    this.customSlidingRotationalSpeed = options.customSlidingRotationalSpeed;
    this.useCustomSlidingRotationalSpeed = options.useCustomSlidingRotationalSpeed;
    this.sliding = false;
    this.chassisConnectionPointLocal = options.chassisConnectionPointLocal.clone();
    this.chassisConnectionPointWorld = options.chassisConnectionPointWorld.clone();
    this.directionLocal = options.directionLocal.clone();
    this.directionWorld = options.directionWorld.clone();
    this.axleLocal = options.axleLocal.clone();
    this.axleWorld = options.axleWorld.clone();
    this.suspensionRestLength = options.suspensionRestLength;
    this.suspensionMaxLength = options.suspensionMaxLength;
    this.radius = options.radius;
    this.suspensionStiffness = options.suspensionStiffness;
    this.dampingCompression = options.dampingCompression;
    this.dampingRelaxation = options.dampingRelaxation;
    this.frictionSlip = options.frictionSlip;
    this.forwardAcceleration = options.forwardAcceleration;
    this.sideAcceleration = options.sideAcceleration;
    this.steering = 0;
    this.rotation = 0;
    this.deltaRotation = 0;
    this.rollInfluence = options.rollInfluence;
    this.maxSuspensionForce = options.maxSuspensionForce;
    this.engineForce = 0;
    this.brake = 0;
    this.isFrontWheel = options.isFrontWheel;
    this.clippedInvContactDotSuspension = 1;
    this.suspensionRelativeVelocity = 0;
    this.suspensionForce = 0;
    this.slipInfo = 0;
    this.skidInfo = 0;
    this.suspensionLength = 0;
    this.sideImpulse = 0;
    this.forwardImpulse = 0;
    this.raycastResult = new RaycastResult();
    this.worldTransform = new Transform();
    this.isInContact = false;
  }

  updateWheel(chassis) {
    const raycastResult = this.raycastResult;

    if (this.isInContact) {
      const project = raycastResult.hitNormalWorld.dot(raycastResult.directionWorld);
      raycastResult.hitPointWorld.vsub(chassis.position, relpos);
      chassis.getVelocityAtWorldPoint(relpos, chassis_velocity_at_contactPoint);
      const projVel = raycastResult.hitNormalWorld.dot(chassis_velocity_at_contactPoint);

      if (project >= -0.1) {
        this.suspensionRelativeVelocity = 0.0;
        this.clippedInvContactDotSuspension = 1.0 / 0.1;
      } else {
        const inv = -1 / project;
        this.suspensionRelativeVelocity = projVel * inv;
        this.clippedInvContactDotSuspension = inv;
      }
    } else {
      // Not in contact : position wheel in a nice (rest length) position
      raycastResult.suspensionLength = this.suspensionRestLength;
      this.suspensionRelativeVelocity = 0.0;
      raycastResult.directionWorld.scale(-1, raycastResult.hitNormalWorld);
      this.clippedInvContactDotSuspension = 1.0;
    }
  }

}
const chassis_velocity_at_contactPoint = new Vec3();
const relpos = new Vec3();

/**
 * Vehicle helper class that casts rays from the wheel positions towards the ground and applies forces.
 */
class RaycastVehicle {
  /** The car chassis body. */

  /** The wheels. */

  /** Will be set to true if the car is sliding. */

  /** Index of the right axis. x=0, y=1, z=2 */

  /** Index of the forward axis. x=0, y=1, z=2 */

  /** Index of the up axis. x=0, y=1, z=2 */

  /** The constraints. */

  /** Optional pre-step callback. */

  /** Number of wheels on the ground. */
  constructor(options) {
    this.chassisBody = void 0;
    this.wheelInfos = void 0;
    this.sliding = void 0;
    this.world = void 0;
    this.indexRightAxis = void 0;
    this.indexForwardAxis = void 0;
    this.indexUpAxis = void 0;
    this.constraints = void 0;
    this.preStepCallback = void 0;
    this.currentVehicleSpeedKmHour = void 0;
    this.numWheelsOnGround = void 0;
    this.chassisBody = options.chassisBody;
    this.wheelInfos = [];
    this.sliding = false;
    this.world = null;
    this.indexRightAxis = typeof options.indexRightAxis !== 'undefined' ? options.indexRightAxis : 2;
    this.indexForwardAxis = typeof options.indexForwardAxis !== 'undefined' ? options.indexForwardAxis : 0;
    this.indexUpAxis = typeof options.indexUpAxis !== 'undefined' ? options.indexUpAxis : 1;
    this.constraints = [];

    this.preStepCallback = () => {};

    this.currentVehicleSpeedKmHour = 0;
    this.numWheelsOnGround = 0;
  }
  /**
   * Add a wheel. For information about the options, see `WheelInfo`.
   */


  addWheel(options = {}) {
    const info = new WheelInfo(options);
    const index = this.wheelInfos.length;
    this.wheelInfos.push(info);
    return index;
  }
  /**
   * Set the steering value of a wheel.
   */


  setSteeringValue(value, wheelIndex) {
    const wheel = this.wheelInfos[wheelIndex];
    wheel.steering = value;
  }
  /**
   * Set the wheel force to apply on one of the wheels each time step
   */


  applyEngineForce(value, wheelIndex) {
    this.wheelInfos[wheelIndex].engineForce = value;
  }
  /**
   * Set the braking force of a wheel
   */


  setBrake(brake, wheelIndex) {
    this.wheelInfos[wheelIndex].brake = brake;
  }
  /**
   * Add the vehicle including its constraints to the world.
   */


  addToWorld(world) {
    world.addBody(this.chassisBody);
    const that = this;

    this.preStepCallback = () => {
      that.updateVehicle(world.dt);
    };

    world.addEventListener('preStep', this.preStepCallback);
    this.world = world;
  }
  /**
   * Get one of the wheel axles, world-oriented.
   */


  getVehicleAxisWorld(axisIndex, result) {
    result.set(axisIndex === 0 ? 1 : 0, axisIndex === 1 ? 1 : 0, axisIndex === 2 ? 1 : 0);
    this.chassisBody.vectorToWorldFrame(result, result);
  }

  updateVehicle(timeStep) {
    const wheelInfos = this.wheelInfos;
    const numWheels = wheelInfos.length;
    const chassisBody = this.chassisBody;

    for (let i = 0; i < numWheels; i++) {
      this.updateWheelTransform(i);
    }

    this.currentVehicleSpeedKmHour = 3.6 * chassisBody.velocity.length();
    const forwardWorld = new Vec3();
    this.getVehicleAxisWorld(this.indexForwardAxis, forwardWorld);

    if (forwardWorld.dot(chassisBody.velocity) < 0) {
      this.currentVehicleSpeedKmHour *= -1;
    } // simulate suspension


    for (let i = 0; i < numWheels; i++) {
      this.castRay(wheelInfos[i]);
    }

    this.updateSuspension(timeStep);
    const impulse = new Vec3();
    const relpos = new Vec3();

    for (let i = 0; i < numWheels; i++) {
      //apply suspension force
      const wheel = wheelInfos[i];
      let suspensionForce = wheel.suspensionForce;

      if (suspensionForce > wheel.maxSuspensionForce) {
        suspensionForce = wheel.maxSuspensionForce;
      }

      wheel.raycastResult.hitNormalWorld.scale(suspensionForce * timeStep, impulse);
      wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, relpos);
      chassisBody.applyImpulse(impulse, relpos);
    }

    this.updateFriction(timeStep);
    const hitNormalWorldScaledWithProj = new Vec3();
    const fwd = new Vec3();
    const vel = new Vec3();

    for (let i = 0; i < numWheels; i++) {
      const wheel = wheelInfos[i]; //const relpos = new Vec3();
      //wheel.chassisConnectionPointWorld.vsub(chassisBody.position, relpos);

      chassisBody.getVelocityAtWorldPoint(wheel.chassisConnectionPointWorld, vel); // Hack to get the rotation in the correct direction

      let m = 1;

      switch (this.indexUpAxis) {
        case 1:
          m = -1;
          break;
      }

      if (wheel.isInContact) {
        this.getVehicleAxisWorld(this.indexForwardAxis, fwd);
        const proj = fwd.dot(wheel.raycastResult.hitNormalWorld);
        wheel.raycastResult.hitNormalWorld.scale(proj, hitNormalWorldScaledWithProj);
        fwd.vsub(hitNormalWorldScaledWithProj, fwd);
        const proj2 = fwd.dot(vel);
        wheel.deltaRotation = m * proj2 * timeStep / wheel.radius;
      }

      if ((wheel.sliding || !wheel.isInContact) && wheel.engineForce !== 0 && wheel.useCustomSlidingRotationalSpeed) {
        // Apply custom rotation when accelerating and sliding
        wheel.deltaRotation = (wheel.engineForce > 0 ? 1 : -1) * wheel.customSlidingRotationalSpeed * timeStep;
      } // Lock wheels


      if (Math.abs(wheel.brake) > Math.abs(wheel.engineForce)) {
        wheel.deltaRotation = 0;
      }

      wheel.rotation += wheel.deltaRotation; // Use the old value

      wheel.deltaRotation *= 0.99; // damping of rotation when not in contact
    }
  }

  updateSuspension(deltaTime) {
    const chassisBody = this.chassisBody;
    const chassisMass = chassisBody.mass;
    const wheelInfos = this.wheelInfos;
    const numWheels = wheelInfos.length;

    for (let w_it = 0; w_it < numWheels; w_it++) {
      const wheel = wheelInfos[w_it];

      if (wheel.isInContact) {
        let force; // Spring

        const susp_length = wheel.suspensionRestLength;
        const current_length = wheel.suspensionLength;
        const length_diff = susp_length - current_length;
        force = wheel.suspensionStiffness * length_diff * wheel.clippedInvContactDotSuspension; // Damper

        const projected_rel_vel = wheel.suspensionRelativeVelocity;
        let susp_damping;

        if (projected_rel_vel < 0) {
          susp_damping = wheel.dampingCompression;
        } else {
          susp_damping = wheel.dampingRelaxation;
        }

        force -= susp_damping * projected_rel_vel;
        wheel.suspensionForce = force * chassisMass;

        if (wheel.suspensionForce < 0) {
          wheel.suspensionForce = 0;
        }
      } else {
        wheel.suspensionForce = 0;
      }
    }
  }
  /**
   * Remove the vehicle including its constraints from the world.
   */


  removeFromWorld(world) {
    this.constraints;
    world.removeBody(this.chassisBody);
    world.removeEventListener('preStep', this.preStepCallback);
    this.world = null;
  }

  castRay(wheel) {
    const rayvector = castRay_rayvector;
    const target = castRay_target;
    this.updateWheelTransformWorld(wheel);
    const chassisBody = this.chassisBody;
    let depth = -1;
    const raylen = wheel.suspensionRestLength + wheel.radius;
    wheel.directionWorld.scale(raylen, rayvector);
    const source = wheel.chassisConnectionPointWorld;
    source.vadd(rayvector, target);
    const raycastResult = wheel.raycastResult;
    raycastResult.reset(); // Turn off ray collision with the chassis temporarily

    const oldState = chassisBody.collisionResponse;
    chassisBody.collisionResponse = false; // Cast ray against world

    this.world.rayTest(source, target, raycastResult);
    chassisBody.collisionResponse = oldState;
    const object = raycastResult.body;
    wheel.raycastResult.groundObject = 0;

    if (object) {
      depth = raycastResult.distance;
      wheel.raycastResult.hitNormalWorld = raycastResult.hitNormalWorld;
      wheel.isInContact = true;
      const hitDistance = raycastResult.distance;
      wheel.suspensionLength = hitDistance - wheel.radius; // clamp on max suspension travel

      const minSuspensionLength = wheel.suspensionRestLength - wheel.maxSuspensionTravel;
      const maxSuspensionLength = wheel.suspensionRestLength + wheel.maxSuspensionTravel;

      if (wheel.suspensionLength < minSuspensionLength) {
        wheel.suspensionLength = minSuspensionLength;
      }

      if (wheel.suspensionLength > maxSuspensionLength) {
        wheel.suspensionLength = maxSuspensionLength;
        wheel.raycastResult.reset();
      }

      const denominator = wheel.raycastResult.hitNormalWorld.dot(wheel.directionWorld);
      const chassis_velocity_at_contactPoint = new Vec3();
      chassisBody.getVelocityAtWorldPoint(wheel.raycastResult.hitPointWorld, chassis_velocity_at_contactPoint);
      const projVel = wheel.raycastResult.hitNormalWorld.dot(chassis_velocity_at_contactPoint);

      if (denominator >= -0.1) {
        wheel.suspensionRelativeVelocity = 0;
        wheel.clippedInvContactDotSuspension = 1 / 0.1;
      } else {
        const inv = -1 / denominator;
        wheel.suspensionRelativeVelocity = projVel * inv;
        wheel.clippedInvContactDotSuspension = inv;
      }
    } else {
      //put wheel info as in rest position
      wheel.suspensionLength = wheel.suspensionRestLength + 0 * wheel.maxSuspensionTravel;
      wheel.suspensionRelativeVelocity = 0.0;
      wheel.directionWorld.scale(-1, wheel.raycastResult.hitNormalWorld);
      wheel.clippedInvContactDotSuspension = 1.0;
    }

    return depth;
  }

  updateWheelTransformWorld(wheel) {
    wheel.isInContact = false;
    const chassisBody = this.chassisBody;
    chassisBody.pointToWorldFrame(wheel.chassisConnectionPointLocal, wheel.chassisConnectionPointWorld);
    chassisBody.vectorToWorldFrame(wheel.directionLocal, wheel.directionWorld);
    chassisBody.vectorToWorldFrame(wheel.axleLocal, wheel.axleWorld);
  }
  /**
   * Update one of the wheel transform.
   * Note when rendering wheels: during each step, wheel transforms are updated BEFORE the chassis; ie. their position becomes invalid after the step. Thus when you render wheels, you must update wheel transforms before rendering them. See raycastVehicle demo for an example.
   * @param wheelIndex The wheel index to update.
   */


  updateWheelTransform(wheelIndex) {
    const up = tmpVec4;
    const right = tmpVec5;
    const fwd = tmpVec6;
    const wheel = this.wheelInfos[wheelIndex];
    this.updateWheelTransformWorld(wheel);
    wheel.directionLocal.scale(-1, up);
    right.copy(wheel.axleLocal);
    up.cross(right, fwd);
    fwd.normalize();
    right.normalize(); // Rotate around steering over the wheelAxle

    const steering = wheel.steering;
    const steeringOrn = new Quaternion();
    steeringOrn.setFromAxisAngle(up, steering);
    const rotatingOrn = new Quaternion();
    rotatingOrn.setFromAxisAngle(right, wheel.rotation); // World rotation of the wheel

    const q = wheel.worldTransform.quaternion;
    this.chassisBody.quaternion.mult(steeringOrn, q);
    q.mult(rotatingOrn, q);
    q.normalize(); // world position of the wheel

    const p = wheel.worldTransform.position;
    p.copy(wheel.directionWorld);
    p.scale(wheel.suspensionLength, p);
    p.vadd(wheel.chassisConnectionPointWorld, p);
  }
  /**
   * Get the world transform of one of the wheels
   */


  getWheelTransformWorld(wheelIndex) {
    return this.wheelInfos[wheelIndex].worldTransform;
  }

  updateFriction(timeStep) {
    const surfNormalWS_scaled_proj = updateFriction_surfNormalWS_scaled_proj; //calculate the impulse, so that the wheels don't move sidewards

    const wheelInfos = this.wheelInfos;
    const numWheels = wheelInfos.length;
    const chassisBody = this.chassisBody;
    const forwardWS = updateFriction_forwardWS;
    const axle = updateFriction_axle;
    this.numWheelsOnGround = 0;

    for (let i = 0; i < numWheels; i++) {
      const wheel = wheelInfos[i];
      const groundObject = wheel.raycastResult.body;

      if (groundObject) {
        this.numWheelsOnGround++;
      }

      wheel.sideImpulse = 0;
      wheel.forwardImpulse = 0;

      if (!forwardWS[i]) {
        forwardWS[i] = new Vec3();
      }

      if (!axle[i]) {
        axle[i] = new Vec3();
      }
    }

    for (let i = 0; i < numWheels; i++) {
      const wheel = wheelInfos[i];
      const groundObject = wheel.raycastResult.body;

      if (groundObject) {
        const axlei = axle[i];
        const wheelTrans = this.getWheelTransformWorld(i); // Get world axle

        wheelTrans.vectorToWorldFrame(directions[this.indexRightAxis], axlei);
        const surfNormalWS = wheel.raycastResult.hitNormalWorld;
        const proj = axlei.dot(surfNormalWS);
        surfNormalWS.scale(proj, surfNormalWS_scaled_proj);
        axlei.vsub(surfNormalWS_scaled_proj, axlei);
        axlei.normalize();
        surfNormalWS.cross(axlei, forwardWS[i]);
        forwardWS[i].normalize();
        wheel.sideImpulse = resolveSingleBilateral(chassisBody, wheel.raycastResult.hitPointWorld, groundObject, wheel.raycastResult.hitPointWorld, axlei);
        wheel.sideImpulse *= sideFrictionStiffness2;
      }
    }

    const sideFactor = 1;
    const fwdFactor = 0.5;
    this.sliding = false;

    for (let i = 0; i < numWheels; i++) {
      const wheel = wheelInfos[i];
      const groundObject = wheel.raycastResult.body;
      let rollingFriction = 0;
      wheel.slipInfo = 1;

      if (groundObject) {
        const defaultRollingFrictionImpulse = 0;
        const maxImpulse = wheel.brake ? wheel.brake : defaultRollingFrictionImpulse; // btWheelContactPoint contactPt(chassisBody,groundObject,wheelInfraycastInfo.hitPointWorld,forwardWS[wheel],maxImpulse);
        // rollingFriction = calcRollingFriction(contactPt);

        rollingFriction = calcRollingFriction(chassisBody, groundObject, wheel.raycastResult.hitPointWorld, forwardWS[i], maxImpulse);
        rollingFriction += wheel.engineForce * timeStep; // rollingFriction = 0;

        const factor = maxImpulse / rollingFriction;
        wheel.slipInfo *= factor;
      } //switch between active rolling (throttle), braking and non-active rolling friction (nthrottle/break)


      wheel.forwardImpulse = 0;
      wheel.skidInfo = 1;

      if (groundObject) {
        wheel.skidInfo = 1;
        const maximp = wheel.suspensionForce * timeStep * wheel.frictionSlip;
        const maximpSide = maximp;
        const maximpSquared = maximp * maximpSide;
        wheel.forwardImpulse = rollingFriction; //wheelInfo.engineForce* timeStep;

        const x = wheel.forwardImpulse * fwdFactor / wheel.forwardAcceleration;
        const y = wheel.sideImpulse * sideFactor / wheel.sideAcceleration;
        const impulseSquared = x * x + y * y;
        wheel.sliding = false;

        if (impulseSquared > maximpSquared) {
          this.sliding = true;
          wheel.sliding = true;
          const factor = maximp / Math.sqrt(impulseSquared);
          wheel.skidInfo *= factor;
        }
      }
    }

    if (this.sliding) {
      for (let i = 0; i < numWheels; i++) {
        const wheel = wheelInfos[i];

        if (wheel.sideImpulse !== 0) {
          if (wheel.skidInfo < 1) {
            wheel.forwardImpulse *= wheel.skidInfo;
            wheel.sideImpulse *= wheel.skidInfo;
          }
        }
      }
    } // apply the impulses


    for (let i = 0; i < numWheels; i++) {
      const wheel = wheelInfos[i];
      const rel_pos = new Vec3();
      wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, rel_pos); // cannons applyimpulse is using world coord for the position
      //rel_pos.copy(wheel.raycastResult.hitPointWorld);

      if (wheel.forwardImpulse !== 0) {
        const impulse = new Vec3();
        forwardWS[i].scale(wheel.forwardImpulse, impulse);
        chassisBody.applyImpulse(impulse, rel_pos);
      }

      if (wheel.sideImpulse !== 0) {
        const groundObject = wheel.raycastResult.body;
        const rel_pos2 = new Vec3();
        wheel.raycastResult.hitPointWorld.vsub(groundObject.position, rel_pos2); //rel_pos2.copy(wheel.raycastResult.hitPointWorld);

        const sideImp = new Vec3();
        axle[i].scale(wheel.sideImpulse, sideImp); // Scale the relative position in the up direction with rollInfluence.
        // If rollInfluence is 1, the impulse will be applied on the hitPoint (easy to roll over), if it is zero it will be applied in the same plane as the center of mass (not easy to roll over).

        chassisBody.vectorToLocalFrame(rel_pos, rel_pos);
        rel_pos['xyz'[this.indexUpAxis]] *= wheel.rollInfluence;
        chassisBody.vectorToWorldFrame(rel_pos, rel_pos);
        chassisBody.applyImpulse(sideImp, rel_pos); //apply friction impulse on the ground

        sideImp.scale(-1, sideImp);
        groundObject.applyImpulse(sideImp, rel_pos2);
      }
    }
  }

}
const tmpVec4 = new Vec3();
const tmpVec5 = new Vec3();
const tmpVec6 = new Vec3();
new Ray();
const castRay_rayvector = new Vec3();
const castRay_target = new Vec3();
const directions = [new Vec3(1, 0, 0), new Vec3(0, 1, 0), new Vec3(0, 0, 1)];
const updateFriction_surfNormalWS_scaled_proj = new Vec3();
const updateFriction_axle = [];
const updateFriction_forwardWS = [];
const sideFrictionStiffness2 = 1;
const calcRollingFriction_vel1 = new Vec3();
const calcRollingFriction_vel2 = new Vec3();
const calcRollingFriction_vel = new Vec3();

function calcRollingFriction(body0, body1, frictionPosWorld, frictionDirectionWorld, maxImpulse) {
  let j1 = 0;
  const contactPosWorld = frictionPosWorld; // const rel_pos1 = new Vec3();
  // const rel_pos2 = new Vec3();

  const vel1 = calcRollingFriction_vel1;
  const vel2 = calcRollingFriction_vel2;
  const vel = calcRollingFriction_vel; // contactPosWorld.vsub(body0.position, rel_pos1);
  // contactPosWorld.vsub(body1.position, rel_pos2);

  body0.getVelocityAtWorldPoint(contactPosWorld, vel1);
  body1.getVelocityAtWorldPoint(contactPosWorld, vel2);
  vel1.vsub(vel2, vel);
  const vrel = frictionDirectionWorld.dot(vel);
  const denom0 = computeImpulseDenominator(body0, frictionPosWorld, frictionDirectionWorld);
  const denom1 = computeImpulseDenominator(body1, frictionPosWorld, frictionDirectionWorld);
  const relaxation = 1;
  const jacDiagABInv = relaxation / (denom0 + denom1); // calculate j that moves us to zero relative velocity

  j1 = -vrel * jacDiagABInv;

  if (maxImpulse < j1) {
    j1 = maxImpulse;
  }

  if (j1 < -maxImpulse) {
    j1 = -maxImpulse;
  }

  return j1;
}

const computeImpulseDenominator_r0 = new Vec3();
const computeImpulseDenominator_c0 = new Vec3();
const computeImpulseDenominator_vec = new Vec3();
const computeImpulseDenominator_m = new Vec3();

function computeImpulseDenominator(body, pos, normal) {
  const r0 = computeImpulseDenominator_r0;
  const c0 = computeImpulseDenominator_c0;
  const vec = computeImpulseDenominator_vec;
  const m = computeImpulseDenominator_m;
  pos.vsub(body.position, r0);
  r0.cross(normal, c0);
  body.invInertiaWorld.vmult(c0, m);
  m.cross(r0, vec);
  return body.invMass + normal.dot(vec);
}

const resolveSingleBilateral_vel1 = new Vec3();
const resolveSingleBilateral_vel2 = new Vec3();
const resolveSingleBilateral_vel = new Vec3(); // bilateral constraint between two dynamic objects

function resolveSingleBilateral(body1, pos1, body2, pos2, normal) {
  const normalLenSqr = normal.lengthSquared();

  if (normalLenSqr > 1.1) {
    return 0; // no impulse
  } // const rel_pos1 = new Vec3();
  // const rel_pos2 = new Vec3();
  // pos1.vsub(body1.position, rel_pos1);
  // pos2.vsub(body2.position, rel_pos2);


  const vel1 = resolveSingleBilateral_vel1;
  const vel2 = resolveSingleBilateral_vel2;
  const vel = resolveSingleBilateral_vel;
  body1.getVelocityAtWorldPoint(pos1, vel1);
  body2.getVelocityAtWorldPoint(pos2, vel2);
  vel1.vsub(vel2, vel);
  const rel_vel = normal.dot(vel);
  const contactDamping = 0.2;
  const massTerm = 1 / (body1.invMass + body2.invMass);
  const impulse = -contactDamping * rel_vel * massTerm;
  return impulse;
}

/**
 * Spherical shape
 * @example
 *     const radius = 1
 *     const sphereShape = new CANNON.Sphere(radius)
 *     const sphereBody = new CANNON.Body({ mass: 1, shape: sphereShape })
 *     world.addBody(sphereBody)
 */
class Sphere extends Shape {
  /**
   * The radius of the sphere.
   */

  /**
   *
   * @param radius The radius of the sphere, a non-negative number.
   */
  constructor(radius) {
    super({
      type: Shape.types.SPHERE
    });
    this.radius = void 0;
    this.radius = radius !== undefined ? radius : 1.0;

    if (this.radius < 0) {
      throw new Error('The sphere radius cannot be negative.');
    }

    this.updateBoundingSphereRadius();
  }
  /** calculateLocalInertia */


  calculateLocalInertia(mass, target = new Vec3()) {
    const I = 2.0 * mass * this.radius * this.radius / 5.0;
    target.x = I;
    target.y = I;
    target.z = I;
    return target;
  }
  /** volume */


  volume() {
    return 4.0 * Math.PI * Math.pow(this.radius, 3) / 3.0;
  }

  updateBoundingSphereRadius() {
    this.boundingSphereRadius = this.radius;
  }

  calculateWorldAABB(pos, quat, min, max) {
    const r = this.radius;
    const axes = ['x', 'y', 'z'];

    for (let i = 0; i < axes.length; i++) {
      const ax = axes[i];
      min[ax] = pos[ax] - r;
      max[ax] = pos[ax] + r;
    }
  }

}

/**
 * Simple vehicle helper class with spherical rigid body wheels.
 */
class RigidVehicle {
  /**
   * The bodies of the wheels.
   */

  /**
   * The chassis body.
   */

  /**
   * The constraints.
   */

  /**
   * The wheel axes.
   */

  /**
   * The wheel forces.
   */
  constructor(options = {}) {
    this.wheelBodies = void 0;
    this.coordinateSystem = void 0;
    this.chassisBody = void 0;
    this.constraints = void 0;
    this.wheelAxes = void 0;
    this.wheelForces = void 0;
    this.wheelBodies = [];
    this.coordinateSystem = typeof options.coordinateSystem !== 'undefined' ? options.coordinateSystem.clone() : new Vec3(1, 2, 3);

    if (options.chassisBody) {
      this.chassisBody = options.chassisBody;
    } else {
      // No chassis body given. Create it!
      this.chassisBody = new Body({
        mass: 1,
        shape: new Box(new Vec3(5, 0.5, 2))
      });
    }

    this.constraints = [];
    this.wheelAxes = [];
    this.wheelForces = [];
  }
  /**
   * Add a wheel
   */


  addWheel(options = {}) {
    let wheelBody;

    if (options.body) {
      wheelBody = options.body;
    } else {
      // No wheel body given. Create it!
      wheelBody = new Body({
        mass: 1,
        shape: new Sphere(1.2)
      });
    }

    this.wheelBodies.push(wheelBody);
    this.wheelForces.push(0); // Position constrain wheels

    const position = typeof options.position !== 'undefined' ? options.position.clone() : new Vec3(); // Set position locally to the chassis

    const worldPosition = new Vec3();
    this.chassisBody.pointToWorldFrame(position, worldPosition);
    wheelBody.position.set(worldPosition.x, worldPosition.y, worldPosition.z); // Constrain wheel

    const axis = typeof options.axis !== 'undefined' ? options.axis.clone() : new Vec3(0, 0, 1);
    this.wheelAxes.push(axis);
    const hingeConstraint = new HingeConstraint(this.chassisBody, wheelBody, {
      pivotA: position,
      axisA: axis,
      pivotB: Vec3.ZERO,
      axisB: axis,
      collideConnected: false
    });
    this.constraints.push(hingeConstraint);
    return this.wheelBodies.length - 1;
  }
  /**
   * Set the steering value of a wheel.
   * @todo check coordinateSystem
   */


  setSteeringValue(value, wheelIndex) {
    // Set angle of the hinge axis
    const axis = this.wheelAxes[wheelIndex];
    const c = Math.cos(value);
    const s = Math.sin(value);
    const x = axis.x;
    const z = axis.z;
    this.constraints[wheelIndex].axisA.set(-c * x + s * z, 0, s * x + c * z);
  }
  /**
   * Set the target rotational speed of the hinge constraint.
   */


  setMotorSpeed(value, wheelIndex) {
    const hingeConstraint = this.constraints[wheelIndex];
    hingeConstraint.enableMotor();
    hingeConstraint.motorTargetVelocity = value;
  }
  /**
   * Set the target rotational speed of the hinge constraint.
   */


  disableMotor(wheelIndex) {
    const hingeConstraint = this.constraints[wheelIndex];
    hingeConstraint.disableMotor();
  }
  /**
   * Set the wheel force to apply on one of the wheels each time step
   */


  setWheelForce(value, wheelIndex) {
    this.wheelForces[wheelIndex] = value;
  }
  /**
   * Apply a torque on one of the wheels.
   */


  applyWheelForce(value, wheelIndex) {
    const axis = this.wheelAxes[wheelIndex];
    const wheelBody = this.wheelBodies[wheelIndex];
    const bodyTorque = wheelBody.torque;
    axis.scale(value, torque);
    wheelBody.vectorToWorldFrame(torque, torque);
    bodyTorque.vadd(torque, bodyTorque);
  }
  /**
   * Add the vehicle including its constraints to the world.
   */


  addToWorld(world) {
    const constraints = this.constraints;
    const bodies = this.wheelBodies.concat([this.chassisBody]);

    for (let i = 0; i < bodies.length; i++) {
      world.addBody(bodies[i]);
    }

    for (let i = 0; i < constraints.length; i++) {
      world.addConstraint(constraints[i]);
    }

    world.addEventListener('preStep', this._update.bind(this));
  }

  _update() {
    const wheelForces = this.wheelForces;

    for (let i = 0; i < wheelForces.length; i++) {
      this.applyWheelForce(wheelForces[i], i);
    }
  }
  /**
   * Remove the vehicle including its constraints from the world.
   */


  removeFromWorld(world) {
    const constraints = this.constraints;
    const bodies = this.wheelBodies.concat([this.chassisBody]);

    for (let i = 0; i < bodies.length; i++) {
      world.removeBody(bodies[i]);
    }

    for (let i = 0; i < constraints.length; i++) {
      world.removeConstraint(constraints[i]);
    }
  }
  /**
   * Get current rotational velocity of a wheel
   */


  getWheelSpeed(wheelIndex) {
    const axis = this.wheelAxes[wheelIndex];
    const wheelBody = this.wheelBodies[wheelIndex];
    const w = wheelBody.angularVelocity;
    this.chassisBody.vectorToWorldFrame(axis, worldAxis);
    return w.dot(worldAxis);
  }

}
const torque = new Vec3();
const worldAxis = new Vec3();

/**
 * Smoothed-particle hydrodynamics system
 * @todo Make parameters customizable in the constructor
 */
class SPHSystem {
  /**
   * The particles array.
   */

  /**
   * Density of the system (kg/m3).
   * @default 1
   */

  /**
   * Distance below which two particles are considered to be neighbors.
   * It should be adjusted so there are about 15-20 neighbor particles within this radius.
   * @default 1
   */

  /**
   * @default 1
   */

  /**
   * Viscosity of the system.
   * @default 0.01
   */

  /**
   * @default 0.000001
   */
  constructor() {
    this.particles = void 0;
    this.density = void 0;
    this.smoothingRadius = void 0;
    this.speedOfSound = void 0;
    this.viscosity = void 0;
    this.eps = void 0;
    this.pressures = void 0;
    this.densities = void 0;
    this.neighbors = void 0;
    this.particles = [];
    this.density = 1;
    this.smoothingRadius = 1;
    this.speedOfSound = 1;
    this.viscosity = 0.01;
    this.eps = 0.000001; // Stuff Computed per particle

    this.pressures = [];
    this.densities = [];
    this.neighbors = [];
  }
  /**
   * Add a particle to the system.
   */


  add(particle) {
    this.particles.push(particle);

    if (this.neighbors.length < this.particles.length) {
      this.neighbors.push([]);
    }
  }
  /**
   * Remove a particle from the system.
   */


  remove(particle) {
    const idx = this.particles.indexOf(particle);

    if (idx !== -1) {
      this.particles.splice(idx, 1);

      if (this.neighbors.length > this.particles.length) {
        this.neighbors.pop();
      }
    }
  }
  /**
   * Get neighbors within smoothing volume, save in the array neighbors
   */


  getNeighbors(particle, neighbors) {
    const N = this.particles.length;
    const id = particle.id;
    const R2 = this.smoothingRadius * this.smoothingRadius;
    const dist = SPHSystem_getNeighbors_dist;

    for (let i = 0; i !== N; i++) {
      const p = this.particles[i];
      p.position.vsub(particle.position, dist);

      if (id !== p.id && dist.lengthSquared() < R2) {
        neighbors.push(p);
      }
    }
  }

  update() {
    const N = this.particles.length;
    const dist = SPHSystem_update_dist;
    const cs = this.speedOfSound;
    const eps = this.eps;

    for (let i = 0; i !== N; i++) {
      const p = this.particles[i]; // Current particle

      const neighbors = this.neighbors[i]; // Get neighbors

      neighbors.length = 0;
      this.getNeighbors(p, neighbors);
      neighbors.push(this.particles[i]); // Add current too

      const numNeighbors = neighbors.length; // Accumulate density for the particle

      let sum = 0.0;

      for (let j = 0; j !== numNeighbors; j++) {
        //printf("Current particle has position %f %f %f\n",objects[id].pos.x(),objects[id].pos.y(),objects[id].pos.z());
        p.position.vsub(neighbors[j].position, dist);
        const len = dist.length();
        const weight = this.w(len);
        sum += neighbors[j].mass * weight;
      } // Save


      this.densities[i] = sum;
      this.pressures[i] = cs * cs * (this.densities[i] - this.density);
    } // Add forces
    // Sum to these accelerations


    const a_pressure = SPHSystem_update_a_pressure;
    const a_visc = SPHSystem_update_a_visc;
    const gradW = SPHSystem_update_gradW;
    const r_vec = SPHSystem_update_r_vec;
    const u = SPHSystem_update_u;

    for (let i = 0; i !== N; i++) {
      const particle = this.particles[i];
      a_pressure.set(0, 0, 0);
      a_visc.set(0, 0, 0); // Init vars

      let Pij;
      let nabla;

      const neighbors = this.neighbors[i];
      const numNeighbors = neighbors.length; //printf("Neighbors: ");

      for (let j = 0; j !== numNeighbors; j++) {
        const neighbor = neighbors[j]; //printf("%d ",nj);
        // Get r once for all..

        particle.position.vsub(neighbor.position, r_vec);
        const r = r_vec.length(); // Pressure contribution

        Pij = -neighbor.mass * (this.pressures[i] / (this.densities[i] * this.densities[i] + eps) + this.pressures[j] / (this.densities[j] * this.densities[j] + eps));
        this.gradw(r_vec, gradW); // Add to pressure acceleration

        gradW.scale(Pij, gradW);
        a_pressure.vadd(gradW, a_pressure); // Viscosity contribution

        neighbor.velocity.vsub(particle.velocity, u);
        u.scale(1.0 / (0.0001 + this.densities[i] * this.densities[j]) * this.viscosity * neighbor.mass, u);
        nabla = this.nablaw(r);
        u.scale(nabla, u); // Add to viscosity acceleration

        a_visc.vadd(u, a_visc);
      } // Calculate force


      a_visc.scale(particle.mass, a_visc);
      a_pressure.scale(particle.mass, a_pressure); // Add force to particles

      particle.force.vadd(a_visc, particle.force);
      particle.force.vadd(a_pressure, particle.force);
    }
  } // Calculate the weight using the W(r) weightfunction


  w(r) {
    // 315
    const h = this.smoothingRadius;
    return 315.0 / (64.0 * Math.PI * h ** 9) * (h * h - r * r) ** 3;
  } // calculate gradient of the weight function


  gradw(rVec, resultVec) {
    const r = rVec.length();
    const h = this.smoothingRadius;
    rVec.scale(945.0 / (32.0 * Math.PI * h ** 9) * (h * h - r * r) ** 2, resultVec);
  } // Calculate nabla(W)


  nablaw(r) {
    const h = this.smoothingRadius;
    const nabla = 945.0 / (32.0 * Math.PI * h ** 9) * (h * h - r * r) * (7 * r * r - 3 * h * h);
    return nabla;
  }

}
const SPHSystem_getNeighbors_dist = new Vec3(); // Temp vectors for calculation

const SPHSystem_update_dist = new Vec3(); // Relative velocity

const SPHSystem_update_a_pressure = new Vec3();
const SPHSystem_update_a_visc = new Vec3();
const SPHSystem_update_gradW = new Vec3();
const SPHSystem_update_r_vec = new Vec3();
const SPHSystem_update_u = new Vec3();

/**
 * Cylinder class.
 * @example
 *     const radiusTop = 0.5
 *     const radiusBottom = 0.5
 *     const height = 2
 *     const numSegments = 12
 *     const cylinderShape = new CANNON.Cylinder(radiusTop, radiusBottom, height, numSegments)
 *     const cylinderBody = new CANNON.Body({ mass: 1, shape: cylinderShape })
 *     world.addBody(cylinderBody)
 */

class Cylinder extends ConvexPolyhedron {
  /** The radius of the top of the Cylinder. */

  /** The radius of the bottom of the Cylinder. */

  /** The height of the Cylinder. */

  /** The number of segments to build the cylinder out of. */

  /**
   * @param radiusTop The radius of the top of the Cylinder.
   * @param radiusBottom The radius of the bottom of the Cylinder.
   * @param height The height of the Cylinder.
   * @param numSegments The number of segments to build the cylinder out of.
   */
  constructor(radiusTop = 1, radiusBottom = 1, height = 1, numSegments = 8) {
    if (radiusTop < 0) {
      throw new Error('The cylinder radiusTop cannot be negative.');
    }

    if (radiusBottom < 0) {
      throw new Error('The cylinder radiusBottom cannot be negative.');
    }

    const N = numSegments;
    const vertices = [];
    const axes = [];
    const faces = [];
    const bottomface = [];
    const topface = [];
    const cos = Math.cos;
    const sin = Math.sin; // First bottom point

    vertices.push(new Vec3(-radiusBottom * sin(0), -height * 0.5, radiusBottom * cos(0)));
    bottomface.push(0); // First top point

    vertices.push(new Vec3(-radiusTop * sin(0), height * 0.5, radiusTop * cos(0)));
    topface.push(1);

    for (let i = 0; i < N; i++) {
      const theta = 2 * Math.PI / N * (i + 1);
      const thetaN = 2 * Math.PI / N * (i + 0.5);

      if (i < N - 1) {
        // Bottom
        vertices.push(new Vec3(-radiusBottom * sin(theta), -height * 0.5, radiusBottom * cos(theta)));
        bottomface.push(2 * i + 2); // Top

        vertices.push(new Vec3(-radiusTop * sin(theta), height * 0.5, radiusTop * cos(theta)));
        topface.push(2 * i + 3); // Face

        faces.push([2 * i, 2 * i + 1, 2 * i + 3, 2 * i + 2]);
      } else {
        faces.push([2 * i, 2 * i + 1, 1, 0]); // Connect
      } // Axis: we can cut off half of them if we have even number of segments


      if (N % 2 === 1 || i < N / 2) {
        axes.push(new Vec3(-sin(thetaN), 0, cos(thetaN)));
      }
    }

    faces.push(bottomface);
    axes.push(new Vec3(0, 1, 0)); // Reorder top face

    const temp = [];

    for (let i = 0; i < topface.length; i++) {
      temp.push(topface[topface.length - i - 1]);
    }

    faces.push(temp);
    super({
      vertices,
      faces,
      axes
    });
    this.radiusTop = void 0;
    this.radiusBottom = void 0;
    this.height = void 0;
    this.numSegments = void 0;
    this.type = Shape.types.CYLINDER;
    this.radiusTop = radiusTop;
    this.radiusBottom = radiusBottom;
    this.height = height;
    this.numSegments = numSegments;
  }

}

/**
 * Particle shape.
 * @example
 *     const particleShape = new CANNON.Particle()
 *     const particleBody = new CANNON.Body({ mass: 1, shape: particleShape })
 *     world.addBody(particleBody)
 */
class Particle extends Shape {
  constructor() {
    super({
      type: Shape.types.PARTICLE
    });
  }
  /**
   * calculateLocalInertia
   */


  calculateLocalInertia(mass, target = new Vec3()) {
    target.set(0, 0, 0);
    return target;
  }

  volume() {
    return 0;
  }

  updateBoundingSphereRadius() {
    this.boundingSphereRadius = 0;
  }

  calculateWorldAABB(pos, quat, min, max) {
    // Get each axis max
    min.copy(pos);
    max.copy(pos);
  }

}

/**
 * A plane, facing in the Z direction. The plane has its surface at z=0 and everything below z=0 is assumed to be solid plane. To make the plane face in some other direction than z, you must put it inside a Body and rotate that body. See the demos.
 * @example
 *     const planeShape = new CANNON.Plane()
 *     const planeBody = new CANNON.Body({ mass: 0, shape:  planeShape })
 *     planeBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0) // make it face up
 *     world.addBody(planeBody)
 */
class Plane extends Shape {
  /** worldNormal */

  /** worldNormalNeedsUpdate */
  constructor() {
    super({
      type: Shape.types.PLANE
    }); // World oriented normal

    this.worldNormal = void 0;
    this.worldNormalNeedsUpdate = void 0;
    this.boundingSphereRadius = void 0;
    this.worldNormal = new Vec3();
    this.worldNormalNeedsUpdate = true;
    this.boundingSphereRadius = Number.MAX_VALUE;
  }
  /** computeWorldNormal */


  computeWorldNormal(quat) {
    const n = this.worldNormal;
    n.set(0, 0, 1);
    quat.vmult(n, n);
    this.worldNormalNeedsUpdate = false;
  }

  calculateLocalInertia(mass, target = new Vec3()) {
    return target;
  }

  volume() {
    return (// The plane is infinite...
      Number.MAX_VALUE
    );
  }

  calculateWorldAABB(pos, quat, min, max) {
    // The plane AABB is infinite, except if the normal is pointing along any axis
    tempNormal.set(0, 0, 1); // Default plane normal is z

    quat.vmult(tempNormal, tempNormal);
    const maxVal = Number.MAX_VALUE;
    min.set(-maxVal, -maxVal, -maxVal);
    max.set(maxVal, maxVal, maxVal);

    if (tempNormal.x === 1) {
      max.x = pos.x;
    } else if (tempNormal.x === -1) {
      min.x = pos.x;
    }

    if (tempNormal.y === 1) {
      max.y = pos.y;
    } else if (tempNormal.y === -1) {
      min.y = pos.y;
    }

    if (tempNormal.z === 1) {
      max.z = pos.z;
    } else if (tempNormal.z === -1) {
      min.z = pos.z;
    }
  }

  updateBoundingSphereRadius() {
    this.boundingSphereRadius = Number.MAX_VALUE;
  }

}
const tempNormal = new Vec3();

/**
 * Heightfield shape class. Height data is given as an array. These data points are spread out evenly with a given distance.
 * @todo Should be possible to use along all axes, not just y
 * @todo should be possible to scale along all axes
 * @todo Refactor elementSize to elementSizeX and elementSizeY
 *
 * @example
 *     // Generate some height data (y-values).
 *     const data = []
 *     for (let i = 0; i < 1000; i++) {
 *         const y = 0.5 * Math.cos(0.2 * i)
 *         data.push(y)
 *     }
 *
 *     // Create the heightfield shape
 *     const heightfieldShape = new CANNON.Heightfield(data, {
 *         elementSize: 1 // Distance between the data points in X and Y directions
 *     })
 *     const heightfieldBody = new CANNON.Body({ shape: heightfieldShape })
 *     world.addBody(heightfieldBody)
 */
class Heightfield extends Shape {
  /**
   * An array of numbers, or height values, that are spread out along the x axis.
   */

  /**
   * Max value of the data points in the data array.
   */

  /**
   * Minimum value of the data points in the data array.
   */

  /**
   * World spacing between the data points in X and Y direction.
   * @todo elementSizeX and Y
   * @default 1
   */

  /**
   * @default true
   */

  /**
   * @param data An array of numbers, or height values, that are spread out along the x axis.
   */
  constructor(data, options = {}) {
    options = Utils.defaults(options, {
      maxValue: null,
      minValue: null,
      elementSize: 1
    });
    super({
      type: Shape.types.HEIGHTFIELD
    });
    this.data = void 0;
    this.maxValue = void 0;
    this.minValue = void 0;
    this.elementSize = void 0;
    this.cacheEnabled = void 0;
    this.pillarConvex = void 0;
    this.pillarOffset = void 0;
    this._cachedPillars = void 0;
    this.data = data;
    this.maxValue = options.maxValue;
    this.minValue = options.minValue;
    this.elementSize = options.elementSize;

    if (options.minValue === null) {
      this.updateMinValue();
    }

    if (options.maxValue === null) {
      this.updateMaxValue();
    }

    this.cacheEnabled = true;
    this.pillarConvex = new ConvexPolyhedron();
    this.pillarOffset = new Vec3();
    this.updateBoundingSphereRadius(); // "i_j_isUpper" => { convex: ..., offset: ... }
    // for example:
    // _cachedPillars["0_2_1"]

    this._cachedPillars = {};
  }
  /**
   * Call whenever you change the data array.
   */


  update() {
    this._cachedPillars = {};
  }
  /**
   * Update the `minValue` property
   */


  updateMinValue() {
    const data = this.data;
    let minValue = data[0][0];

    for (let i = 0; i !== data.length; i++) {
      for (let j = 0; j !== data[i].length; j++) {
        const v = data[i][j];

        if (v < minValue) {
          minValue = v;
        }
      }
    }

    this.minValue = minValue;
  }
  /**
   * Update the `maxValue` property
   */


  updateMaxValue() {
    const data = this.data;
    let maxValue = data[0][0];

    for (let i = 0; i !== data.length; i++) {
      for (let j = 0; j !== data[i].length; j++) {
        const v = data[i][j];

        if (v > maxValue) {
          maxValue = v;
        }
      }
    }

    this.maxValue = maxValue;
  }
  /**
   * Set the height value at an index. Don't forget to update maxValue and minValue after you're done.
   */


  setHeightValueAtIndex(xi, yi, value) {
    const data = this.data;
    data[xi][yi] = value; // Invalidate cache

    this.clearCachedConvexTrianglePillar(xi, yi, false);

    if (xi > 0) {
      this.clearCachedConvexTrianglePillar(xi - 1, yi, true);
      this.clearCachedConvexTrianglePillar(xi - 1, yi, false);
    }

    if (yi > 0) {
      this.clearCachedConvexTrianglePillar(xi, yi - 1, true);
      this.clearCachedConvexTrianglePillar(xi, yi - 1, false);
    }

    if (yi > 0 && xi > 0) {
      this.clearCachedConvexTrianglePillar(xi - 1, yi - 1, true);
    }
  }
  /**
   * Get max/min in a rectangle in the matrix data
   * @param result An array to store the results in.
   * @return The result array, if it was passed in. Minimum will be at position 0 and max at 1.
   */


  getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, result = []) {
    // Get max and min of the data
    const data = this.data; // Set first value

    let max = this.minValue;

    for (let i = iMinX; i <= iMaxX; i++) {
      for (let j = iMinY; j <= iMaxY; j++) {
        const height = data[i][j];

        if (height > max) {
          max = height;
        }
      }
    }

    result[0] = this.minValue;
    result[1] = max;
  }
  /**
   * Get the index of a local position on the heightfield. The indexes indicate the rectangles, so if your terrain is made of N x N height data points, you will have rectangle indexes ranging from 0 to N-1.
   * @param result Two-element array
   * @param clamp If the position should be clamped to the heightfield edge.
   */


  getIndexOfPosition(x, y, result, clamp) {
    // Get the index of the data points to test against
    const w = this.elementSize;
    const data = this.data;
    let xi = Math.floor(x / w);
    let yi = Math.floor(y / w);
    result[0] = xi;
    result[1] = yi;

    if (clamp) {
      // Clamp index to edges
      if (xi < 0) {
        xi = 0;
      }

      if (yi < 0) {
        yi = 0;
      }

      if (xi >= data.length - 1) {
        xi = data.length - 1;
      }

      if (yi >= data[0].length - 1) {
        yi = data[0].length - 1;
      }
    } // Bail out if we are out of the terrain


    if (xi < 0 || yi < 0 || xi >= data.length - 1 || yi >= data[0].length - 1) {
      return false;
    }

    return true;
  }

  getTriangleAt(x, y, edgeClamp, a, b, c) {
    const idx = getHeightAt_idx;
    this.getIndexOfPosition(x, y, idx, edgeClamp);
    let xi = idx[0];
    let yi = idx[1];
    const data = this.data;

    if (edgeClamp) {
      xi = Math.min(data.length - 2, Math.max(0, xi));
      yi = Math.min(data[0].length - 2, Math.max(0, yi));
    }

    const elementSize = this.elementSize;
    const lowerDist2 = (x / elementSize - xi) ** 2 + (y / elementSize - yi) ** 2;
    const upperDist2 = (x / elementSize - (xi + 1)) ** 2 + (y / elementSize - (yi + 1)) ** 2;
    const upper = lowerDist2 > upperDist2;
    this.getTriangle(xi, yi, upper, a, b, c);
    return upper;
  }

  getNormalAt(x, y, edgeClamp, result) {
    const a = getNormalAt_a;
    const b = getNormalAt_b;
    const c = getNormalAt_c;
    const e0 = getNormalAt_e0;
    const e1 = getNormalAt_e1;
    this.getTriangleAt(x, y, edgeClamp, a, b, c);
    b.vsub(a, e0);
    c.vsub(a, e1);
    e0.cross(e1, result);
    result.normalize();
  }
  /**
   * Get an AABB of a square in the heightfield
   * @param xi
   * @param yi
   * @param result
   */


  getAabbAtIndex(xi, yi, {
    lowerBound,
    upperBound
  }) {
    const data = this.data;
    const elementSize = this.elementSize;
    lowerBound.set(xi * elementSize, yi * elementSize, data[xi][yi]);
    upperBound.set((xi + 1) * elementSize, (yi + 1) * elementSize, data[xi + 1][yi + 1]);
  }
  /**
   * Get the height in the heightfield at a given position
   */


  getHeightAt(x, y, edgeClamp) {
    const data = this.data;
    const a = getHeightAt_a;
    const b = getHeightAt_b;
    const c = getHeightAt_c;
    const idx = getHeightAt_idx;
    this.getIndexOfPosition(x, y, idx, edgeClamp);
    let xi = idx[0];
    let yi = idx[1];

    if (edgeClamp) {
      xi = Math.min(data.length - 2, Math.max(0, xi));
      yi = Math.min(data[0].length - 2, Math.max(0, yi));
    }

    const upper = this.getTriangleAt(x, y, edgeClamp, a, b, c);
    barycentricWeights(x, y, a.x, a.y, b.x, b.y, c.x, c.y, getHeightAt_weights);
    const w = getHeightAt_weights;

    if (upper) {
      // Top triangle verts
      return data[xi + 1][yi + 1] * w.x + data[xi][yi + 1] * w.y + data[xi + 1][yi] * w.z;
    } else {
      // Top triangle verts
      return data[xi][yi] * w.x + data[xi + 1][yi] * w.y + data[xi][yi + 1] * w.z;
    }
  }

  getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle) {
    return xi + "_" + yi + "_" + (getUpperTriangle ? 1 : 0);
  }

  getCachedConvexTrianglePillar(xi, yi, getUpperTriangle) {
    return this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)];
  }

  setCachedConvexTrianglePillar(xi, yi, getUpperTriangle, convex, offset) {
    this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)] = {
      convex,
      offset
    };
  }

  clearCachedConvexTrianglePillar(xi, yi, getUpperTriangle) {
    delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)];
  }
  /**
   * Get a triangle from the heightfield
   */


  getTriangle(xi, yi, upper, a, b, c) {
    const data = this.data;
    const elementSize = this.elementSize;

    if (upper) {
      // Top triangle verts
      a.set((xi + 1) * elementSize, (yi + 1) * elementSize, data[xi + 1][yi + 1]);
      b.set(xi * elementSize, (yi + 1) * elementSize, data[xi][yi + 1]);
      c.set((xi + 1) * elementSize, yi * elementSize, data[xi + 1][yi]);
    } else {
      // Top triangle verts
      a.set(xi * elementSize, yi * elementSize, data[xi][yi]);
      b.set((xi + 1) * elementSize, yi * elementSize, data[xi + 1][yi]);
      c.set(xi * elementSize, (yi + 1) * elementSize, data[xi][yi + 1]);
    }
  }
  /**
   * Get a triangle in the terrain in the form of a triangular convex shape.
   */


  getConvexTrianglePillar(xi, yi, getUpperTriangle) {
    let result = this.pillarConvex;
    let offsetResult = this.pillarOffset;

    if (this.cacheEnabled) {
      const data = this.getCachedConvexTrianglePillar(xi, yi, getUpperTriangle);

      if (data) {
        this.pillarConvex = data.convex;
        this.pillarOffset = data.offset;
        return;
      }

      result = new ConvexPolyhedron();
      offsetResult = new Vec3();
      this.pillarConvex = result;
      this.pillarOffset = offsetResult;
    }

    const data = this.data;
    const elementSize = this.elementSize;
    const faces = result.faces; // Reuse verts if possible

    result.vertices.length = 6;

    for (let i = 0; i < 6; i++) {
      if (!result.vertices[i]) {
        result.vertices[i] = new Vec3();
      }
    } // Reuse faces if possible


    faces.length = 5;

    for (let i = 0; i < 5; i++) {
      if (!faces[i]) {
        faces[i] = [];
      }
    }

    const verts = result.vertices;
    const h = (Math.min(data[xi][yi], data[xi + 1][yi], data[xi][yi + 1], data[xi + 1][yi + 1]) - this.minValue) / 2 + this.minValue;

    if (!getUpperTriangle) {
      // Center of the triangle pillar - all polygons are given relative to this one
      offsetResult.set((xi + 0.25) * elementSize, // sort of center of a triangle
      (yi + 0.25) * elementSize, h // vertical center
      ); // Top triangle verts

      verts[0].set(-0.25 * elementSize, -0.25 * elementSize, data[xi][yi] - h);
      verts[1].set(0.75 * elementSize, -0.25 * elementSize, data[xi + 1][yi] - h);
      verts[2].set(-0.25 * elementSize, 0.75 * elementSize, data[xi][yi + 1] - h); // bottom triangle verts

      verts[3].set(-0.25 * elementSize, -0.25 * elementSize, -Math.abs(h) - 1);
      verts[4].set(0.75 * elementSize, -0.25 * elementSize, -Math.abs(h) - 1);
      verts[5].set(-0.25 * elementSize, 0.75 * elementSize, -Math.abs(h) - 1); // top triangle

      faces[0][0] = 0;
      faces[0][1] = 1;
      faces[0][2] = 2; // bottom triangle

      faces[1][0] = 5;
      faces[1][1] = 4;
      faces[1][2] = 3; // -x facing quad

      faces[2][0] = 0;
      faces[2][1] = 2;
      faces[2][2] = 5;
      faces[2][3] = 3; // -y facing quad

      faces[3][0] = 1;
      faces[3][1] = 0;
      faces[3][2] = 3;
      faces[3][3] = 4; // +xy facing quad

      faces[4][0] = 4;
      faces[4][1] = 5;
      faces[4][2] = 2;
      faces[4][3] = 1;
    } else {
      // Center of the triangle pillar - all polygons are given relative to this one
      offsetResult.set((xi + 0.75) * elementSize, // sort of center of a triangle
      (yi + 0.75) * elementSize, h // vertical center
      ); // Top triangle verts

      verts[0].set(0.25 * elementSize, 0.25 * elementSize, data[xi + 1][yi + 1] - h);
      verts[1].set(-0.75 * elementSize, 0.25 * elementSize, data[xi][yi + 1] - h);
      verts[2].set(0.25 * elementSize, -0.75 * elementSize, data[xi + 1][yi] - h); // bottom triangle verts

      verts[3].set(0.25 * elementSize, 0.25 * elementSize, -Math.abs(h) - 1);
      verts[4].set(-0.75 * elementSize, 0.25 * elementSize, -Math.abs(h) - 1);
      verts[5].set(0.25 * elementSize, -0.75 * elementSize, -Math.abs(h) - 1); // Top triangle

      faces[0][0] = 0;
      faces[0][1] = 1;
      faces[0][2] = 2; // bottom triangle

      faces[1][0] = 5;
      faces[1][1] = 4;
      faces[1][2] = 3; // +x facing quad

      faces[2][0] = 2;
      faces[2][1] = 5;
      faces[2][2] = 3;
      faces[2][3] = 0; // +y facing quad

      faces[3][0] = 3;
      faces[3][1] = 4;
      faces[3][2] = 1;
      faces[3][3] = 0; // -xy facing quad

      faces[4][0] = 1;
      faces[4][1] = 4;
      faces[4][2] = 5;
      faces[4][3] = 2;
    }

    result.computeNormals();
    result.computeEdges();
    result.updateBoundingSphereRadius();
    this.setCachedConvexTrianglePillar(xi, yi, getUpperTriangle, result, offsetResult);
  }

  calculateLocalInertia(mass, target = new Vec3()) {
    target.set(0, 0, 0);
    return target;
  }

  volume() {
    return (// The terrain is infinite
      Number.MAX_VALUE
    );
  }

  calculateWorldAABB(pos, quat, min, max) {
    /** @TODO do it properly */
    min.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    max.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
  }

  updateBoundingSphereRadius() {
    // Use the bounding box of the min/max values
    const data = this.data;
    const s = this.elementSize;
    this.boundingSphereRadius = new Vec3(data.length * s, data[0].length * s, Math.max(Math.abs(this.maxValue), Math.abs(this.minValue))).length();
  }
  /**
   * Sets the height values from an image. Currently only supported in browser.
   */


  setHeightsFromImage(image, scale) {
    const {
      x,
      z,
      y
    } = scale;
    const canvas = document.createElement('canvas');
    canvas.width = image.width;
    canvas.height = image.height;
    const context = canvas.getContext('2d');
    context.drawImage(image, 0, 0);
    const imageData = context.getImageData(0, 0, image.width, image.height);
    const matrix = this.data;
    matrix.length = 0;
    this.elementSize = Math.abs(x) / imageData.width;

    for (let i = 0; i < imageData.height; i++) {
      const row = [];

      for (let j = 0; j < imageData.width; j++) {
        const a = imageData.data[(i * imageData.height + j) * 4];
        const b = imageData.data[(i * imageData.height + j) * 4 + 1];
        const c = imageData.data[(i * imageData.height + j) * 4 + 2];
        const height = (a + b + c) / 4 / 255 * z;

        if (x < 0) {
          row.push(height);
        } else {
          row.unshift(height);
        }
      }

      if (y < 0) {
        matrix.unshift(row);
      } else {
        matrix.push(row);
      }
    }

    this.updateMaxValue();
    this.updateMinValue();
    this.update();
  }

}
const getHeightAt_idx = [];
const getHeightAt_weights = new Vec3();
const getHeightAt_a = new Vec3();
const getHeightAt_b = new Vec3();
const getHeightAt_c = new Vec3();
const getNormalAt_a = new Vec3();
const getNormalAt_b = new Vec3();
const getNormalAt_c = new Vec3();
const getNormalAt_e0 = new Vec3();
const getNormalAt_e1 = new Vec3(); // from https://en.wikipedia.org/wiki/Barycentric_coordinate_system

function barycentricWeights(x, y, ax, ay, bx, by, cx, cy, result) {
  result.x = ((by - cy) * (x - cx) + (cx - bx) * (y - cy)) / ((by - cy) * (ax - cx) + (cx - bx) * (ay - cy));
  result.y = ((cy - ay) * (x - cx) + (ax - cx) * (y - cy)) / ((by - cy) * (ax - cx) + (cx - bx) * (ay - cy));
  result.z = 1 - result.x - result.y;
}

/**
 * OctreeNode
 */
class OctreeNode {
  /** The root node */

  /** Boundary of this node */

  /** Contained data at the current node level */

  /** Children to this node */
  constructor(options = {}) {
    this.root = void 0;
    this.aabb = void 0;
    this.data = void 0;
    this.children = void 0;
    this.root = options.root || null;
    this.aabb = options.aabb ? options.aabb.clone() : new AABB();
    this.data = [];
    this.children = [];
  }
  /**
   * reset
   */


  reset() {
    this.children.length = this.data.length = 0;
  }
  /**
   * Insert data into this node
   * @return True if successful, otherwise false
   */


  insert(aabb, elementData, level = 0) {
    const nodeData = this.data; // Ignore objects that do not belong in this node

    if (!this.aabb.contains(aabb)) {
      return false; // object cannot be added
    }

    const children = this.children;
    const maxDepth = this.maxDepth || this.root.maxDepth;

    if (level < maxDepth) {
      // Subdivide if there are no children yet
      let subdivided = false;

      if (!children.length) {
        this.subdivide();
        subdivided = true;
      } // add to whichever node will accept it


      for (let i = 0; i !== 8; i++) {
        if (children[i].insert(aabb, elementData, level + 1)) {
          return true;
        }
      }

      if (subdivided) {
        // No children accepted! Might as well just remove em since they contain none
        children.length = 0;
      }
    } // Too deep, or children didnt want it. add it in current node


    nodeData.push(elementData);
    return true;
  }
  /**
   * Create 8 equally sized children nodes and put them in the `children` array.
   */


  subdivide() {
    const aabb = this.aabb;
    const l = aabb.lowerBound;
    const u = aabb.upperBound;
    const children = this.children;
    children.push(new OctreeNode({
      aabb: new AABB({
        lowerBound: new Vec3(0, 0, 0)
      })
    }), new OctreeNode({
      aabb: new AABB({
        lowerBound: new Vec3(1, 0, 0)
      })
    }), new OctreeNode({
      aabb: new AABB({
        lowerBound: new Vec3(1, 1, 0)
      })
    }), new OctreeNode({
      aabb: new AABB({
        lowerBound: new Vec3(1, 1, 1)
      })
    }), new OctreeNode({
      aabb: new AABB({
        lowerBound: new Vec3(0, 1, 1)
      })
    }), new OctreeNode({
      aabb: new AABB({
        lowerBound: new Vec3(0, 0, 1)
      })
    }), new OctreeNode({
      aabb: new AABB({
        lowerBound: new Vec3(1, 0, 1)
      })
    }), new OctreeNode({
      aabb: new AABB({
        lowerBound: new Vec3(0, 1, 0)
      })
    }));
    u.vsub(l, halfDiagonal);
    halfDiagonal.scale(0.5, halfDiagonal);
    const root = this.root || this;

    for (let i = 0; i !== 8; i++) {
      const child = children[i]; // Set current node as root

      child.root = root; // Compute bounds

      const lowerBound = child.aabb.lowerBound;
      lowerBound.x *= halfDiagonal.x;
      lowerBound.y *= halfDiagonal.y;
      lowerBound.z *= halfDiagonal.z;
      lowerBound.vadd(l, lowerBound); // Upper bound is always lower bound + halfDiagonal

      lowerBound.vadd(halfDiagonal, child.aabb.upperBound);
    }
  }
  /**
   * Get all data, potentially within an AABB
   * @return The "result" object
   */


  aabbQuery(aabb, result) {
    this.data; // abort if the range does not intersect this node
    // if (!this.aabb.overlaps(aabb)){
    //     return result;
    // }
    // Add objects at this level
    // Array.prototype.push.apply(result, nodeData);
    // Add child data
    // @todo unwrap recursion into a queue / loop, that's faster in JS

    this.children; // for (let i = 0, N = this.children.length; i !== N; i++) {
    //     children[i].aabbQuery(aabb, result);
    // }

    const queue = [this];

    while (queue.length) {
      const node = queue.pop();

      if (node.aabb.overlaps(aabb)) {
        Array.prototype.push.apply(result, node.data);
      }

      Array.prototype.push.apply(queue, node.children);
    }

    return result;
  }
  /**
   * Get all data, potentially intersected by a ray.
   * @return The "result" object
   */


  rayQuery(ray, treeTransform, result) {
    // Use aabb query for now.

    /** @todo implement real ray query which needs less lookups */
    ray.getAABB(tmpAABB);
    tmpAABB.toLocalFrame(treeTransform, tmpAABB);
    this.aabbQuery(tmpAABB, result);
    return result;
  }
  /**
   * removeEmptyNodes
   */


  removeEmptyNodes() {
    for (let i = this.children.length - 1; i >= 0; i--) {
      this.children[i].removeEmptyNodes();

      if (!this.children[i].children.length && !this.children[i].data.length) {
        this.children.splice(i, 1);
      }
    }
  }

}
/**
 * Octree
 */


class Octree extends OctreeNode {
  /**
   * Maximum subdivision depth
   * @default 8
   */

  /**
   * @param aabb The total AABB of the tree
   */
  constructor(aabb, options = {}) {
    super({
      root: null,
      aabb
    });
    this.maxDepth = void 0;
    this.maxDepth = typeof options.maxDepth !== 'undefined' ? options.maxDepth : 8;
  }

}
const halfDiagonal = new Vec3();
const tmpAABB = new AABB();

/**
 * Trimesh.
 * @example
 *     // How to make a mesh with a single triangle
 *     const vertices = [
 *         0, 0, 0, // vertex 0
 *         1, 0, 0, // vertex 1
 *         0, 1, 0  // vertex 2
 *     ]
 *     const indices = [
 *         0, 1, 2  // triangle 0
 *     ]
 *     const trimeshShape = new CANNON.Trimesh(vertices, indices)
 */
class Trimesh extends Shape {
  /**
   * vertices
   */

  /**
   * Array of integers, indicating which vertices each triangle consists of. The length of this array is thus 3 times the number of triangles.
   */

  /**
   * The normals data.
   */

  /**
   * The local AABB of the mesh.
   */

  /**
   * References to vertex pairs, making up all unique edges in the trimesh.
   */

  /**
   * Local scaling of the mesh. Use .setScale() to set it.
   */

  /**
   * The indexed triangles. Use .updateTree() to update it.
   */
  constructor(vertices, indices) {
    super({
      type: Shape.types.TRIMESH
    });
    this.vertices = void 0;
    this.indices = void 0;
    this.normals = void 0;
    this.aabb = void 0;
    this.edges = void 0;
    this.scale = void 0;
    this.tree = void 0;
    this.vertices = new Float32Array(vertices);
    this.indices = new Int16Array(indices);
    this.normals = new Float32Array(indices.length);
    this.aabb = new AABB();
    this.edges = null;
    this.scale = new Vec3(1, 1, 1);
    this.tree = new Octree();
    this.updateEdges();
    this.updateNormals();
    this.updateAABB();
    this.updateBoundingSphereRadius();
    this.updateTree();
  }
  /**
   * updateTree
   */


  updateTree() {
    const tree = this.tree;
    tree.reset();
    tree.aabb.copy(this.aabb);
    const scale = this.scale; // The local mesh AABB is scaled, but the octree AABB should be unscaled

    tree.aabb.lowerBound.x *= 1 / scale.x;
    tree.aabb.lowerBound.y *= 1 / scale.y;
    tree.aabb.lowerBound.z *= 1 / scale.z;
    tree.aabb.upperBound.x *= 1 / scale.x;
    tree.aabb.upperBound.y *= 1 / scale.y;
    tree.aabb.upperBound.z *= 1 / scale.z; // Insert all triangles

    const triangleAABB = new AABB();
    const a = new Vec3();
    const b = new Vec3();
    const c = new Vec3();
    const points = [a, b, c];

    for (let i = 0; i < this.indices.length / 3; i++) {
      //this.getTriangleVertices(i, a, b, c);
      // Get unscaled triangle verts
      const i3 = i * 3;

      this._getUnscaledVertex(this.indices[i3], a);

      this._getUnscaledVertex(this.indices[i3 + 1], b);

      this._getUnscaledVertex(this.indices[i3 + 2], c);

      triangleAABB.setFromPoints(points);
      tree.insert(triangleAABB, i);
    }

    tree.removeEmptyNodes();
  }
  /**
   * Get triangles in a local AABB from the trimesh.
   * @param result An array of integers, referencing the queried triangles.
   */


  getTrianglesInAABB(aabb, result) {
    unscaledAABB.copy(aabb); // Scale it to local

    const scale = this.scale;
    const isx = scale.x;
    const isy = scale.y;
    const isz = scale.z;
    const l = unscaledAABB.lowerBound;
    const u = unscaledAABB.upperBound;
    l.x /= isx;
    l.y /= isy;
    l.z /= isz;
    u.x /= isx;
    u.y /= isy;
    u.z /= isz;
    return this.tree.aabbQuery(unscaledAABB, result);
  }
  /**
   * setScale
   */


  setScale(scale) {
    const wasUniform = this.scale.x === this.scale.y && this.scale.y === this.scale.z;
    const isUniform = scale.x === scale.y && scale.y === scale.z;

    if (!(wasUniform && isUniform)) {
      // Non-uniform scaling. Need to update normals.
      this.updateNormals();
    }

    this.scale.copy(scale);
    this.updateAABB();
    this.updateBoundingSphereRadius();
  }
  /**
   * Compute the normals of the faces. Will save in the `.normals` array.
   */


  updateNormals() {
    const n = computeNormals_n; // Generate normals

    const normals = this.normals;

    for (let i = 0; i < this.indices.length / 3; i++) {
      const i3 = i * 3;
      const a = this.indices[i3];
      const b = this.indices[i3 + 1];
      const c = this.indices[i3 + 2];
      this.getVertex(a, va);
      this.getVertex(b, vb);
      this.getVertex(c, vc);
      Trimesh.computeNormal(vb, va, vc, n);
      normals[i3] = n.x;
      normals[i3 + 1] = n.y;
      normals[i3 + 2] = n.z;
    }
  }
  /**
   * Update the `.edges` property
   */


  updateEdges() {
    const edges = {};

    const add = (a, b) => {
      const key = a < b ? a + "_" + b : b + "_" + a;
      edges[key] = true;
    };

    for (let i = 0; i < this.indices.length / 3; i++) {
      const i3 = i * 3;
      const a = this.indices[i3];
      const b = this.indices[i3 + 1];
      const c = this.indices[i3 + 2];
      add(a, b);
      add(b, c);
      add(c, a);
    }

    const keys = Object.keys(edges);
    this.edges = new Int16Array(keys.length * 2);

    for (let i = 0; i < keys.length; i++) {
      const indices = keys[i].split('_');
      this.edges[2 * i] = parseInt(indices[0], 10);
      this.edges[2 * i + 1] = parseInt(indices[1], 10);
    }
  }
  /**
   * Get an edge vertex
   * @param firstOrSecond 0 or 1, depending on which one of the vertices you need.
   * @param vertexStore Where to store the result
   */


  getEdgeVertex(edgeIndex, firstOrSecond, vertexStore) {
    const vertexIndex = this.edges[edgeIndex * 2 + (firstOrSecond ? 1 : 0)];
    this.getVertex(vertexIndex, vertexStore);
  }
  /**
   * Get a vector along an edge.
   */


  getEdgeVector(edgeIndex, vectorStore) {
    const va = getEdgeVector_va;
    const vb = getEdgeVector_vb;
    this.getEdgeVertex(edgeIndex, 0, va);
    this.getEdgeVertex(edgeIndex, 1, vb);
    vb.vsub(va, vectorStore);
  }
  /**
   * Get face normal given 3 vertices
   */


  static computeNormal(va, vb, vc, target) {
    vb.vsub(va, ab);
    vc.vsub(vb, cb);
    cb.cross(ab, target);

    if (!target.isZero()) {
      target.normalize();
    }
  }
  /**
   * Get vertex i.
   * @return The "out" vector object
   */


  getVertex(i, out) {
    const scale = this.scale;

    this._getUnscaledVertex(i, out);

    out.x *= scale.x;
    out.y *= scale.y;
    out.z *= scale.z;
    return out;
  }
  /**
   * Get raw vertex i
   * @return The "out" vector object
   */


  _getUnscaledVertex(i, out) {
    const i3 = i * 3;
    const vertices = this.vertices;
    return out.set(vertices[i3], vertices[i3 + 1], vertices[i3 + 2]);
  }
  /**
   * Get a vertex from the trimesh,transformed by the given position and quaternion.
   * @return The "out" vector object
   */


  getWorldVertex(i, pos, quat, out) {
    this.getVertex(i, out);
    Transform.pointToWorldFrame(pos, quat, out, out);
    return out;
  }
  /**
   * Get the three vertices for triangle i.
   */


  getTriangleVertices(i, a, b, c) {
    const i3 = i * 3;
    this.getVertex(this.indices[i3], a);
    this.getVertex(this.indices[i3 + 1], b);
    this.getVertex(this.indices[i3 + 2], c);
  }
  /**
   * Compute the normal of triangle i.
   * @return The "target" vector object
   */


  getNormal(i, target) {
    const i3 = i * 3;
    return target.set(this.normals[i3], this.normals[i3 + 1], this.normals[i3 + 2]);
  }
  /**
   * @return The "target" vector object
   */


  calculateLocalInertia(mass, target) {
    // Approximate with box inertia
    // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it
    this.computeLocalAABB(cli_aabb);
    const x = cli_aabb.upperBound.x - cli_aabb.lowerBound.x;
    const y = cli_aabb.upperBound.y - cli_aabb.lowerBound.y;
    const z = cli_aabb.upperBound.z - cli_aabb.lowerBound.z;
    return target.set(1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * z * 2 * z), 1.0 / 12.0 * mass * (2 * x * 2 * x + 2 * z * 2 * z), 1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * x * 2 * x));
  }
  /**
   * Compute the local AABB for the trimesh
   */


  computeLocalAABB(aabb) {
    const l = aabb.lowerBound;
    const u = aabb.upperBound;
    const n = this.vertices.length;
    this.vertices;
    const v = computeLocalAABB_worldVert;
    this.getVertex(0, v);
    l.copy(v);
    u.copy(v);

    for (let i = 0; i !== n; i++) {
      this.getVertex(i, v);

      if (v.x < l.x) {
        l.x = v.x;
      } else if (v.x > u.x) {
        u.x = v.x;
      }

      if (v.y < l.y) {
        l.y = v.y;
      } else if (v.y > u.y) {
        u.y = v.y;
      }

      if (v.z < l.z) {
        l.z = v.z;
      } else if (v.z > u.z) {
        u.z = v.z;
      }
    }
  }
  /**
   * Update the `.aabb` property
   */


  updateAABB() {
    this.computeLocalAABB(this.aabb);
  }
  /**
   * Will update the `.boundingSphereRadius` property
   */


  updateBoundingSphereRadius() {
    // Assume points are distributed with local (0,0,0) as center
    let max2 = 0;
    const vertices = this.vertices;
    const v = new Vec3();

    for (let i = 0, N = vertices.length / 3; i !== N; i++) {
      this.getVertex(i, v);
      const norm2 = v.lengthSquared();

      if (norm2 > max2) {
        max2 = norm2;
      }
    }

    this.boundingSphereRadius = Math.sqrt(max2);
  }
  /**
   * calculateWorldAABB
   */


  calculateWorldAABB(pos, quat, min, max) {
    /*
        const n = this.vertices.length / 3,
            verts = this.vertices;
        const minx,miny,minz,maxx,maxy,maxz;
         const v = tempWorldVertex;
        for(let i=0; i<n; i++){
            this.getVertex(i, v);
            quat.vmult(v, v);
            pos.vadd(v, v);
            if (v.x < minx || minx===undefined){
                minx = v.x;
            } else if(v.x > maxx || maxx===undefined){
                maxx = v.x;
            }
             if (v.y < miny || miny===undefined){
                miny = v.y;
            } else if(v.y > maxy || maxy===undefined){
                maxy = v.y;
            }
             if (v.z < minz || minz===undefined){
                minz = v.z;
            } else if(v.z > maxz || maxz===undefined){
                maxz = v.z;
            }
        }
        min.set(minx,miny,minz);
        max.set(maxx,maxy,maxz);
        */
    // Faster approximation using local AABB
    const frame = calculateWorldAABB_frame;
    const result = calculateWorldAABB_aabb;
    frame.position = pos;
    frame.quaternion = quat;
    this.aabb.toWorldFrame(frame, result);
    min.copy(result.lowerBound);
    max.copy(result.upperBound);
  }
  /**
   * Get approximate volume
   */


  volume() {
    return 4.0 * Math.PI * this.boundingSphereRadius / 3.0;
  }
  /**
   * Create a Trimesh instance, shaped as a torus.
   */


  static createTorus(radius = 1, tube = 0.5, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2) {
    const vertices = [];
    const indices = [];

    for (let j = 0; j <= radialSegments; j++) {
      for (let i = 0; i <= tubularSegments; i++) {
        const u = i / tubularSegments * arc;
        const v = j / radialSegments * Math.PI * 2;
        const x = (radius + tube * Math.cos(v)) * Math.cos(u);
        const y = (radius + tube * Math.cos(v)) * Math.sin(u);
        const z = tube * Math.sin(v);
        vertices.push(x, y, z);
      }
    }

    for (let j = 1; j <= radialSegments; j++) {
      for (let i = 1; i <= tubularSegments; i++) {
        const a = (tubularSegments + 1) * j + i - 1;
        const b = (tubularSegments + 1) * (j - 1) + i - 1;
        const c = (tubularSegments + 1) * (j - 1) + i;
        const d = (tubularSegments + 1) * j + i;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }

    return new Trimesh(vertices, indices);
  }

}
const computeNormals_n = new Vec3();
const unscaledAABB = new AABB();
const getEdgeVector_va = new Vec3();
const getEdgeVector_vb = new Vec3();
const cb = new Vec3();
const ab = new Vec3();
const va = new Vec3();
const vb = new Vec3();
const vc = new Vec3();
const cli_aabb = new AABB();
const computeLocalAABB_worldVert = new Vec3();
const calculateWorldAABB_frame = new Transform();
const calculateWorldAABB_aabb = new AABB();

/**
 * Constraint equation solver base class.
 */
class Solver {
  /**
   * All equations to be solved
   */

  /**
   * @todo remove useless constructor
   */
  constructor() {
    this.equations = void 0;
    this.equations = [];
  }
  /**
   * Should be implemented in subclasses!
   * @todo use abstract
   * @return number of iterations performed
   */


  solve(dt, world) {
    return (// Should return the number of iterations done!
      0
    );
  }
  /**
   * Add an equation
   */


  addEquation(eq) {
    if (eq.enabled && !eq.bi.isTrigger && !eq.bj.isTrigger) {
      this.equations.push(eq);
    }
  }
  /**
   * Remove an equation
   */


  removeEquation(eq) {
    const eqs = this.equations;
    const i = eqs.indexOf(eq);

    if (i !== -1) {
      eqs.splice(i, 1);
    }
  }
  /**
   * Add all equations
   */


  removeAllEquations() {
    this.equations.length = 0;
  }

}

/**
 * Constraint equation Gauss-Seidel solver.
 * @todo The spook parameters should be specified for each constraint, not globally.
 * @see https://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf
 */
class GSSolver extends Solver {
  /**
   * The number of solver iterations determines quality of the constraints in the world.
   * The more iterations, the more correct simulation. More iterations need more computations though. If you have a large gravity force in your world, you will need more iterations.
   */

  /**
   * When tolerance is reached, the system is assumed to be converged.
   */

  /**
   * @todo remove useless constructor
   */
  constructor() {
    super();
    this.iterations = void 0;
    this.tolerance = void 0;
    this.iterations = 10;
    this.tolerance = 1e-7;
  }
  /**
   * Solve
   * @return number of iterations performed
   */


  solve(dt, world) {
    let iter = 0;
    const maxIter = this.iterations;
    const tolSquared = this.tolerance * this.tolerance;
    const equations = this.equations;
    const Neq = equations.length;
    const bodies = world.bodies;
    const Nbodies = bodies.length;
    const h = dt;
    let B;
    let invC;
    let deltalambda;
    let deltalambdaTot;
    let GWlambda;
    let lambdaj; // Update solve mass

    if (Neq !== 0) {
      for (let i = 0; i !== Nbodies; i++) {
        bodies[i].updateSolveMassProperties();
      }
    } // Things that do not change during iteration can be computed once


    const invCs = GSSolver_solve_invCs;
    const Bs = GSSolver_solve_Bs;
    const lambda = GSSolver_solve_lambda;
    invCs.length = Neq;
    Bs.length = Neq;
    lambda.length = Neq;

    for (let i = 0; i !== Neq; i++) {
      const c = equations[i];
      lambda[i] = 0.0;
      Bs[i] = c.computeB(h);
      invCs[i] = 1.0 / c.computeC();
    }

    if (Neq !== 0) {
      // Reset vlambda
      for (let i = 0; i !== Nbodies; i++) {
        const b = bodies[i];
        const vlambda = b.vlambda;
        const wlambda = b.wlambda;
        vlambda.set(0, 0, 0);
        wlambda.set(0, 0, 0);
      } // Iterate over equations


      for (iter = 0; iter !== maxIter; iter++) {
        // Accumulate the total error for each iteration.
        deltalambdaTot = 0.0;

        for (let j = 0; j !== Neq; j++) {
          const c = equations[j]; // Compute iteration

          B = Bs[j];
          invC = invCs[j];
          lambdaj = lambda[j];
          GWlambda = c.computeGWlambda();
          deltalambda = invC * (B - GWlambda - c.eps * lambdaj); // Clamp if we are not within the min/max interval

          if (lambdaj + deltalambda < c.minForce) {
            deltalambda = c.minForce - lambdaj;
          } else if (lambdaj + deltalambda > c.maxForce) {
            deltalambda = c.maxForce - lambdaj;
          }

          lambda[j] += deltalambda;
          deltalambdaTot += deltalambda > 0.0 ? deltalambda : -deltalambda; // abs(deltalambda)

          c.addToWlambda(deltalambda);
        } // If the total error is small enough - stop iterate


        if (deltalambdaTot * deltalambdaTot < tolSquared) {
          break;
        }
      } // Add result to velocity


      for (let i = 0; i !== Nbodies; i++) {
        const b = bodies[i];
        const v = b.velocity;
        const w = b.angularVelocity;
        b.vlambda.vmul(b.linearFactor, b.vlambda);
        v.vadd(b.vlambda, v);
        b.wlambda.vmul(b.angularFactor, b.wlambda);
        w.vadd(b.wlambda, w);
      } // Set the `.multiplier` property of each equation


      let l = equations.length;
      const invDt = 1 / h;

      while (l--) {
        equations[l].multiplier = lambda[l] * invDt;
      }
    }

    return iter;
  }

} // Just temporary number holders that we want to reuse each iteration.

const GSSolver_solve_lambda = [];
const GSSolver_solve_invCs = [];
const GSSolver_solve_Bs = [];

/**
 * Splits the equations into islands and solves them independently. Can improve performance.
 */
class SplitSolver extends Solver {
  /**
   * The number of solver iterations determines quality of the constraints in the world. The more iterations, the more correct simulation. More iterations need more computations though. If you have a large gravity force in your world, you will need more iterations.
   */

  /**
   * When tolerance is reached, the system is assumed to be converged.
   */

  /** subsolver */
  constructor(subsolver) {
    super();
    this.iterations = void 0;
    this.tolerance = void 0;
    this.subsolver = void 0;
    this.nodes = void 0;
    this.nodePool = void 0;
    this.iterations = 10;
    this.tolerance = 1e-7;
    this.subsolver = subsolver;
    this.nodes = [];
    this.nodePool = []; // Create needed nodes, reuse if possible

    while (this.nodePool.length < 128) {
      this.nodePool.push(this.createNode());
    }
  }
  /**
   * createNode
   */


  createNode() {
    return {
      body: null,
      children: [],
      eqs: [],
      visited: false
    };
  }
  /**
   * Solve the subsystems
   * @return number of iterations performed
   */


  solve(dt, world) {
    const nodes = SplitSolver_solve_nodes;
    const nodePool = this.nodePool;
    const bodies = world.bodies;
    const equations = this.equations;
    const Neq = equations.length;
    const Nbodies = bodies.length;
    const subsolver = this.subsolver; // Create needed nodes, reuse if possible

    while (nodePool.length < Nbodies) {
      nodePool.push(this.createNode());
    }

    nodes.length = Nbodies;

    for (let i = 0; i < Nbodies; i++) {
      nodes[i] = nodePool[i];
    } // Reset node values


    for (let i = 0; i !== Nbodies; i++) {
      const node = nodes[i];
      node.body = bodies[i];
      node.children.length = 0;
      node.eqs.length = 0;
      node.visited = false;
    }

    for (let k = 0; k !== Neq; k++) {
      const eq = equations[k];
      const i = bodies.indexOf(eq.bi);
      const j = bodies.indexOf(eq.bj);
      const ni = nodes[i];
      const nj = nodes[j];
      ni.children.push(nj);
      ni.eqs.push(eq);
      nj.children.push(ni);
      nj.eqs.push(eq);
    }

    let child;
    let n = 0;
    let eqs = SplitSolver_solve_eqs;
    subsolver.tolerance = this.tolerance;
    subsolver.iterations = this.iterations;
    const dummyWorld = SplitSolver_solve_dummyWorld;

    while (child = getUnvisitedNode(nodes)) {
      eqs.length = 0;
      dummyWorld.bodies.length = 0;
      bfs(child, visitFunc, dummyWorld.bodies, eqs);
      const Neqs = eqs.length;
      eqs = eqs.sort(sortById);

      for (let i = 0; i !== Neqs; i++) {
        subsolver.addEquation(eqs[i]);
      }

      subsolver.solve(dt, dummyWorld);
      subsolver.removeAllEquations();
      n++;
    }

    return n;
  }

} // Returns the number of subsystems

const SplitSolver_solve_nodes = []; // All allocated node objects

const SplitSolver_solve_eqs = []; // Temp array

const SplitSolver_solve_dummyWorld = {
  bodies: []
}; // Temp object

const STATIC = Body.STATIC;

function getUnvisitedNode(nodes) {
  const Nnodes = nodes.length;

  for (let i = 0; i !== Nnodes; i++) {
    const node = nodes[i];

    if (!node.visited && !(node.body.type & STATIC)) {
      return node;
    }
  }

  return false;
}

const queue = [];

function bfs(root, visitFunc, bds, eqs) {
  queue.push(root);
  root.visited = true;
  visitFunc(root, bds, eqs);

  while (queue.length) {
    const node = queue.pop(); // Loop over unvisited child nodes

    let child;

    while (child = getUnvisitedNode(node.children)) {
      child.visited = true;
      visitFunc(child, bds, eqs);
      queue.push(child);
    }
  }
}

function visitFunc(node, bds, eqs) {
  bds.push(node.body);
  const Neqs = node.eqs.length;

  for (let i = 0; i !== Neqs; i++) {
    const eq = node.eqs[i];

    if (!eqs.includes(eq)) {
      eqs.push(eq);
    }
  }
}

function sortById(a, b) {
  return b.id - a.id;
}

/**
 * For pooling objects that can be reused.
 */
class Pool {
  constructor() {
    this.objects = [];
    this.type = Object;
  }

  /**
   * Release an object after use
   */
  release(...args) {
    const Nargs = args.length;

    for (let i = 0; i !== Nargs; i++) {
      this.objects.push(args[i]);
    }

    return this;
  }
  /**
   * Get an object
   */


  get() {
    if (this.objects.length === 0) {
      return this.constructObject();
    } else {
      return this.objects.pop();
    }
  }
  /**
   * Construct an object. Should be implemented in each subclass.
   */


  constructObject() {
    throw new Error('constructObject() not implemented in this Pool subclass yet!');
  }
  /**
   * @return Self, for chaining
   */


  resize(size) {
    const objects = this.objects;

    while (objects.length > size) {
      objects.pop();
    }

    while (objects.length < size) {
      objects.push(this.constructObject());
    }

    return this;
  }

}

/**
 * Vec3Pool
 */

class Vec3Pool extends Pool {
  constructor(...args) {
    super(...args);
    this.type = Vec3;
  }

  /**
   * Construct a vector
   */
  constructObject() {
    return new Vec3();
  }

}

let _COLLISION_TYPES$sphe, _COLLISION_TYPES$sphe2, _COLLISION_TYPES$boxB, _COLLISION_TYPES$sphe3, _COLLISION_TYPES$plan, _COLLISION_TYPES$conv, _COLLISION_TYPES$sphe4, _COLLISION_TYPES$plan2, _COLLISION_TYPES$boxC, _COLLISION_TYPES$sphe5, _COLLISION_TYPES$boxH, _COLLISION_TYPES$conv2, _COLLISION_TYPES$sphe6, _COLLISION_TYPES$plan3, _COLLISION_TYPES$boxP, _COLLISION_TYPES$conv3, _COLLISION_TYPES$cyli, _COLLISION_TYPES$sphe7, _COLLISION_TYPES$plan4, _COLLISION_TYPES$boxC2, _COLLISION_TYPES$conv4, _COLLISION_TYPES$heig, _COLLISION_TYPES$part, _COLLISION_TYPES$sphe8, _COLLISION_TYPES$plan5;
// Naming rule: based of the order in SHAPE_TYPES,
// the first part of the method is formed by the
// shape type that comes before, in the second part
// there is the shape type that comes after in the SHAPE_TYPES list
const COLLISION_TYPES = {
  sphereSphere: Shape.types.SPHERE,
  spherePlane: Shape.types.SPHERE | Shape.types.PLANE,
  boxBox: Shape.types.BOX | Shape.types.BOX,
  sphereBox: Shape.types.SPHERE | Shape.types.BOX,
  planeBox: Shape.types.PLANE | Shape.types.BOX,
  convexConvex: Shape.types.CONVEXPOLYHEDRON,
  sphereConvex: Shape.types.SPHERE | Shape.types.CONVEXPOLYHEDRON,
  planeConvex: Shape.types.PLANE | Shape.types.CONVEXPOLYHEDRON,
  boxConvex: Shape.types.BOX | Shape.types.CONVEXPOLYHEDRON,
  sphereHeightfield: Shape.types.SPHERE | Shape.types.HEIGHTFIELD,
  boxHeightfield: Shape.types.BOX | Shape.types.HEIGHTFIELD,
  convexHeightfield: Shape.types.CONVEXPOLYHEDRON | Shape.types.HEIGHTFIELD,
  sphereParticle: Shape.types.PARTICLE | Shape.types.SPHERE,
  planeParticle: Shape.types.PLANE | Shape.types.PARTICLE,
  boxParticle: Shape.types.BOX | Shape.types.PARTICLE,
  convexParticle: Shape.types.PARTICLE | Shape.types.CONVEXPOLYHEDRON,
  cylinderCylinder: Shape.types.CYLINDER,
  sphereCylinder: Shape.types.SPHERE | Shape.types.CYLINDER,
  planeCylinder: Shape.types.PLANE | Shape.types.CYLINDER,
  boxCylinder: Shape.types.BOX | Shape.types.CYLINDER,
  convexCylinder: Shape.types.CONVEXPOLYHEDRON | Shape.types.CYLINDER,
  heightfieldCylinder: Shape.types.HEIGHTFIELD | Shape.types.CYLINDER,
  particleCylinder: Shape.types.PARTICLE | Shape.types.CYLINDER,
  sphereTrimesh: Shape.types.SPHERE | Shape.types.TRIMESH,
  planeTrimesh: Shape.types.PLANE | Shape.types.TRIMESH
};
_COLLISION_TYPES$sphe = COLLISION_TYPES.sphereSphere;
_COLLISION_TYPES$sphe2 = COLLISION_TYPES.spherePlane;
_COLLISION_TYPES$boxB = COLLISION_TYPES.boxBox;
_COLLISION_TYPES$sphe3 = COLLISION_TYPES.sphereBox;
_COLLISION_TYPES$plan = COLLISION_TYPES.planeBox;
_COLLISION_TYPES$conv = COLLISION_TYPES.convexConvex;
_COLLISION_TYPES$sphe4 = COLLISION_TYPES.sphereConvex;
_COLLISION_TYPES$plan2 = COLLISION_TYPES.planeConvex;
_COLLISION_TYPES$boxC = COLLISION_TYPES.boxConvex;
_COLLISION_TYPES$sphe5 = COLLISION_TYPES.sphereHeightfield;
_COLLISION_TYPES$boxH = COLLISION_TYPES.boxHeightfield;
_COLLISION_TYPES$conv2 = COLLISION_TYPES.convexHeightfield;
_COLLISION_TYPES$sphe6 = COLLISION_TYPES.sphereParticle;
_COLLISION_TYPES$plan3 = COLLISION_TYPES.planeParticle;
_COLLISION_TYPES$boxP = COLLISION_TYPES.boxParticle;
_COLLISION_TYPES$conv3 = COLLISION_TYPES.convexParticle;
_COLLISION_TYPES$cyli = COLLISION_TYPES.cylinderCylinder;
_COLLISION_TYPES$sphe7 = COLLISION_TYPES.sphereCylinder;
_COLLISION_TYPES$plan4 = COLLISION_TYPES.planeCylinder;
_COLLISION_TYPES$boxC2 = COLLISION_TYPES.boxCylinder;
_COLLISION_TYPES$conv4 = COLLISION_TYPES.convexCylinder;
_COLLISION_TYPES$heig = COLLISION_TYPES.heightfieldCylinder;
_COLLISION_TYPES$part = COLLISION_TYPES.particleCylinder;
_COLLISION_TYPES$sphe8 = COLLISION_TYPES.sphereTrimesh;
_COLLISION_TYPES$plan5 = COLLISION_TYPES.planeTrimesh;

/**
 * Helper class for the World. Generates ContactEquations.
 * @todo Sphere-ConvexPolyhedron contacts
 * @todo Contact reduction
 * @todo should move methods to prototype
 */
class Narrowphase {
  /**
   * Internal storage of pooled contact points.
   */

  /**
   * Pooled vectors.
   */
  get [_COLLISION_TYPES$sphe]() {
    return this.sphereSphere;
  }

  get [_COLLISION_TYPES$sphe2]() {
    return this.spherePlane;
  }

  get [_COLLISION_TYPES$boxB]() {
    return this.boxBox;
  }

  get [_COLLISION_TYPES$sphe3]() {
    return this.sphereBox;
  }

  get [_COLLISION_TYPES$plan]() {
    return this.planeBox;
  }

  get [_COLLISION_TYPES$conv]() {
    return this.convexConvex;
  }

  get [_COLLISION_TYPES$sphe4]() {
    return this.sphereConvex;
  }

  get [_COLLISION_TYPES$plan2]() {
    return this.planeConvex;
  }

  get [_COLLISION_TYPES$boxC]() {
    return this.boxConvex;
  }

  get [_COLLISION_TYPES$sphe5]() {
    return this.sphereHeightfield;
  }

  get [_COLLISION_TYPES$boxH]() {
    return this.boxHeightfield;
  }

  get [_COLLISION_TYPES$conv2]() {
    return this.convexHeightfield;
  }

  get [_COLLISION_TYPES$sphe6]() {
    return this.sphereParticle;
  }

  get [_COLLISION_TYPES$plan3]() {
    return this.planeParticle;
  }

  get [_COLLISION_TYPES$boxP]() {
    return this.boxParticle;
  }

  get [_COLLISION_TYPES$conv3]() {
    return this.convexParticle;
  }

  get [_COLLISION_TYPES$cyli]() {
    return this.convexConvex;
  }

  get [_COLLISION_TYPES$sphe7]() {
    return this.sphereConvex;
  }

  get [_COLLISION_TYPES$plan4]() {
    return this.planeConvex;
  }

  get [_COLLISION_TYPES$boxC2]() {
    return this.boxConvex;
  }

  get [_COLLISION_TYPES$conv4]() {
    return this.convexConvex;
  }

  get [_COLLISION_TYPES$heig]() {
    return this.heightfieldCylinder;
  }

  get [_COLLISION_TYPES$part]() {
    return this.particleCylinder;
  }

  get [_COLLISION_TYPES$sphe8]() {
    return this.sphereTrimesh;
  }

  get [_COLLISION_TYPES$plan5]() {
    return this.planeTrimesh;
  } // get [COLLISION_TYPES.convexTrimesh]() {
  //   return this.convexTrimesh
  // }


  constructor(world) {
    this.contactPointPool = void 0;
    this.frictionEquationPool = void 0;
    this.result = void 0;
    this.frictionResult = void 0;
    this.v3pool = void 0;
    this.world = void 0;
    this.currentContactMaterial = void 0;
    this.enableFrictionReduction = void 0;
    this.contactPointPool = [];
    this.frictionEquationPool = [];
    this.result = [];
    this.frictionResult = [];
    this.v3pool = new Vec3Pool();
    this.world = world;
    this.currentContactMaterial = world.defaultContactMaterial;
    this.enableFrictionReduction = false;
  }
  /**
   * Make a contact object, by using the internal pool or creating a new one.
   */


  createContactEquation(bi, bj, si, sj, overrideShapeA, overrideShapeB) {
    let c;

    if (this.contactPointPool.length) {
      c = this.contactPointPool.pop();
      c.bi = bi;
      c.bj = bj;
    } else {
      c = new ContactEquation(bi, bj);
    }

    c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;
    const cm = this.currentContactMaterial;
    c.restitution = cm.restitution;
    c.setSpookParams(cm.contactEquationStiffness, cm.contactEquationRelaxation, this.world.dt);
    const matA = si.material || bi.material;
    const matB = sj.material || bj.material;

    if (matA && matB && matA.restitution >= 0 && matB.restitution >= 0) {
      c.restitution = matA.restitution * matB.restitution;
    }

    c.si = overrideShapeA || si;
    c.sj = overrideShapeB || sj;
    return c;
  }

  createFrictionEquationsFromContact(contactEquation, outArray) {
    const bodyA = contactEquation.bi;
    const bodyB = contactEquation.bj;
    const shapeA = contactEquation.si;
    const shapeB = contactEquation.sj;
    const world = this.world;
    const cm = this.currentContactMaterial; // If friction or restitution were specified in the material, use them

    let friction = cm.friction;
    const matA = shapeA.material || bodyA.material;
    const matB = shapeB.material || bodyB.material;

    if (matA && matB && matA.friction >= 0 && matB.friction >= 0) {
      friction = matA.friction * matB.friction;
    }

    if (friction > 0) {
      // Create 2 tangent equations
      const mug = friction * world.gravity.length();
      let reducedMass = bodyA.invMass + bodyB.invMass;

      if (reducedMass > 0) {
        reducedMass = 1 / reducedMass;
      }

      const pool = this.frictionEquationPool;
      const c1 = pool.length ? pool.pop() : new FrictionEquation(bodyA, bodyB, mug * reducedMass);
      const c2 = pool.length ? pool.pop() : new FrictionEquation(bodyA, bodyB, mug * reducedMass);
      c1.bi = c2.bi = bodyA;
      c1.bj = c2.bj = bodyB;
      c1.minForce = c2.minForce = -mug * reducedMass;
      c1.maxForce = c2.maxForce = mug * reducedMass; // Copy over the relative vectors

      c1.ri.copy(contactEquation.ri);
      c1.rj.copy(contactEquation.rj);
      c2.ri.copy(contactEquation.ri);
      c2.rj.copy(contactEquation.rj); // Construct tangents

      contactEquation.ni.tangents(c1.t, c2.t); // Set spook params

      c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt);
      c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt);
      c1.enabled = c2.enabled = contactEquation.enabled;
      outArray.push(c1, c2);
      return true;
    }

    return false;
  }
  /**
   * Take the average N latest contact point on the plane.
   */


  createFrictionFromAverage(numContacts) {
    // The last contactEquation
    let c = this.result[this.result.length - 1]; // Create the result: two "average" friction equations

    if (!this.createFrictionEquationsFromContact(c, this.frictionResult) || numContacts === 1) {
      return;
    }

    const f1 = this.frictionResult[this.frictionResult.length - 2];
    const f2 = this.frictionResult[this.frictionResult.length - 1];
    averageNormal.setZero();
    averageContactPointA.setZero();
    averageContactPointB.setZero();
    const bodyA = c.bi;
    c.bj;

    for (let i = 0; i !== numContacts; i++) {
      c = this.result[this.result.length - 1 - i];

      if (c.bi !== bodyA) {
        averageNormal.vadd(c.ni, averageNormal);
        averageContactPointA.vadd(c.ri, averageContactPointA);
        averageContactPointB.vadd(c.rj, averageContactPointB);
      } else {
        averageNormal.vsub(c.ni, averageNormal);
        averageContactPointA.vadd(c.rj, averageContactPointA);
        averageContactPointB.vadd(c.ri, averageContactPointB);
      }
    }

    const invNumContacts = 1 / numContacts;
    averageContactPointA.scale(invNumContacts, f1.ri);
    averageContactPointB.scale(invNumContacts, f1.rj);
    f2.ri.copy(f1.ri); // Should be the same

    f2.rj.copy(f1.rj);
    averageNormal.normalize();
    averageNormal.tangents(f1.t, f2.t); // return eq;
  }
  /**
   * Generate all contacts between a list of body pairs
   * @param p1 Array of body indices
   * @param p2 Array of body indices
   * @param result Array to store generated contacts
   * @param oldcontacts Optional. Array of reusable contact objects
   */


  getContacts(p1, p2, world, result, oldcontacts, frictionResult, frictionPool) {
    // Save old contact objects
    this.contactPointPool = oldcontacts;
    this.frictionEquationPool = frictionPool;
    this.result = result;
    this.frictionResult = frictionResult;
    const qi = tmpQuat1;
    const qj = tmpQuat2;
    const xi = tmpVec1;
    const xj = tmpVec2;

    for (let k = 0, N = p1.length; k !== N; k++) {
      // Get current collision bodies
      const bi = p1[k];
      const bj = p2[k]; // Get contact material

      let bodyContactMaterial = null;

      if (bi.material && bj.material) {
        bodyContactMaterial = world.getContactMaterial(bi.material, bj.material) || null;
      }

      const justTest = bi.type & Body.KINEMATIC && bj.type & Body.STATIC || bi.type & Body.STATIC && bj.type & Body.KINEMATIC || bi.type & Body.KINEMATIC && bj.type & Body.KINEMATIC;

      for (let i = 0; i < bi.shapes.length; i++) {
        bi.quaternion.mult(bi.shapeOrientations[i], qi);
        bi.quaternion.vmult(bi.shapeOffsets[i], xi);
        xi.vadd(bi.position, xi);
        const si = bi.shapes[i];

        for (let j = 0; j < bj.shapes.length; j++) {
          // Compute world transform of shapes
          bj.quaternion.mult(bj.shapeOrientations[j], qj);
          bj.quaternion.vmult(bj.shapeOffsets[j], xj);
          xj.vadd(bj.position, xj);
          const sj = bj.shapes[j];

          if (!(si.collisionFilterMask & sj.collisionFilterGroup && sj.collisionFilterMask & si.collisionFilterGroup)) {
            continue;
          }

          if (xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius) {
            continue;
          } // Get collision material


          let shapeContactMaterial = null;

          if (si.material && sj.material) {
            shapeContactMaterial = world.getContactMaterial(si.material, sj.material) || null;
          }

          this.currentContactMaterial = shapeContactMaterial || bodyContactMaterial || world.defaultContactMaterial; // Get contacts

          const resolverIndex = si.type | sj.type;
          const resolver = this[resolverIndex];

          if (resolver) {
            let retval = false; // TO DO: investigate why sphereParticle and convexParticle
            // resolvers expect si and sj shapes to be in reverse order
            // (i.e. larger integer value type first instead of smaller first)

            if (si.type < sj.type) {
              retval = resolver.call(this, si, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);
            } else {
              retval = resolver.call(this, sj, si, xj, xi, qj, qi, bj, bi, si, sj, justTest);
            }

            if (retval && justTest) {
              // Register overlap
              world.shapeOverlapKeeper.set(si.id, sj.id);
              world.bodyOverlapKeeper.set(bi.id, bj.id);
            }
          }
        }
      }
    }
  }

  sphereSphere(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    if (justTest) {
      return xi.distanceSquared(xj) < (si.radius + sj.radius) ** 2;
    } // We will have only one contact in this case


    const contactEq = this.createContactEquation(bi, bj, si, sj, rsi, rsj); // Contact normal

    xj.vsub(xi, contactEq.ni);
    contactEq.ni.normalize(); // Contact point locations

    contactEq.ri.copy(contactEq.ni);
    contactEq.rj.copy(contactEq.ni);
    contactEq.ri.scale(si.radius, contactEq.ri);
    contactEq.rj.scale(-sj.radius, contactEq.rj);
    contactEq.ri.vadd(xi, contactEq.ri);
    contactEq.ri.vsub(bi.position, contactEq.ri);
    contactEq.rj.vadd(xj, contactEq.rj);
    contactEq.rj.vsub(bj.position, contactEq.rj);
    this.result.push(contactEq);
    this.createFrictionEquationsFromContact(contactEq, this.frictionResult);
  }

  spherePlane(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    // We will have one contact in this case
    const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj); // Contact normal

    r.ni.set(0, 0, 1);
    qj.vmult(r.ni, r.ni);
    r.ni.negate(r.ni); // body i is the sphere, flip normal

    r.ni.normalize(); // Needed?
    // Vector from sphere center to contact point

    r.ni.scale(si.radius, r.ri); // Project down sphere on plane

    xi.vsub(xj, point_on_plane_to_sphere);
    r.ni.scale(r.ni.dot(point_on_plane_to_sphere), plane_to_sphere_ortho);
    point_on_plane_to_sphere.vsub(plane_to_sphere_ortho, r.rj); // The sphere position projected to plane

    if (-point_on_plane_to_sphere.dot(r.ni) <= si.radius) {
      if (justTest) {
        return true;
      } // Make it relative to the body


      const ri = r.ri;
      const rj = r.rj;
      ri.vadd(xi, ri);
      ri.vsub(bi.position, ri);
      rj.vadd(xj, rj);
      rj.vsub(bj.position, rj);
      this.result.push(r);
      this.createFrictionEquationsFromContact(r, this.frictionResult);
    }
  }

  boxBox(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    si.convexPolyhedronRepresentation.material = si.material;
    sj.convexPolyhedronRepresentation.material = sj.material;
    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
    sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;
    return this.convexConvex(si.convexPolyhedronRepresentation, sj.convexPolyhedronRepresentation, xi, xj, qi, qj, bi, bj, si, sj, justTest);
  }

  sphereBox(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    const v3pool = this.v3pool; // we refer to the box as body j

    const sides = sphereBox_sides;
    xi.vsub(xj, box_to_sphere);
    sj.getSideNormals(sides, qj);
    const R = si.radius;

    let found = false; // Store the resulting side penetration info

    const side_ns = sphereBox_side_ns;
    const side_ns1 = sphereBox_side_ns1;
    const side_ns2 = sphereBox_side_ns2;
    let side_h = null;
    let side_penetrations = 0;
    let side_dot1 = 0;
    let side_dot2 = 0;
    let side_distance = null;

    for (let idx = 0, nsides = sides.length; idx !== nsides && found === false; idx++) {
      // Get the plane side normal (ns)
      const ns = sphereBox_ns;
      ns.copy(sides[idx]);
      const h = ns.length();
      ns.normalize(); // The normal/distance dot product tells which side of the plane we are

      const dot = box_to_sphere.dot(ns);

      if (dot < h + R && dot > 0) {
        // Intersects plane. Now check the other two dimensions
        const ns1 = sphereBox_ns1;
        const ns2 = sphereBox_ns2;
        ns1.copy(sides[(idx + 1) % 3]);
        ns2.copy(sides[(idx + 2) % 3]);
        const h1 = ns1.length();
        const h2 = ns2.length();
        ns1.normalize();
        ns2.normalize();
        const dot1 = box_to_sphere.dot(ns1);
        const dot2 = box_to_sphere.dot(ns2);

        if (dot1 < h1 && dot1 > -h1 && dot2 < h2 && dot2 > -h2) {
          const dist = Math.abs(dot - h - R);

          if (side_distance === null || dist < side_distance) {
            side_distance = dist;
            side_dot1 = dot1;
            side_dot2 = dot2;
            side_h = h;
            side_ns.copy(ns);
            side_ns1.copy(ns1);
            side_ns2.copy(ns2);
            side_penetrations++;

            if (justTest) {
              return true;
            }
          }
        }
      }
    }

    if (side_penetrations) {
      found = true;
      const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
      side_ns.scale(-R, r.ri); // Sphere r

      r.ni.copy(side_ns);
      r.ni.negate(r.ni); // Normal should be out of sphere

      side_ns.scale(side_h, side_ns);
      side_ns1.scale(side_dot1, side_ns1);
      side_ns.vadd(side_ns1, side_ns);
      side_ns2.scale(side_dot2, side_ns2);
      side_ns.vadd(side_ns2, r.rj); // Make relative to bodies

      r.ri.vadd(xi, r.ri);
      r.ri.vsub(bi.position, r.ri);
      r.rj.vadd(xj, r.rj);
      r.rj.vsub(bj.position, r.rj);
      this.result.push(r);
      this.createFrictionEquationsFromContact(r, this.frictionResult);
    } // Check corners


    let rj = v3pool.get();
    const sphere_to_corner = sphereBox_sphere_to_corner;

    for (let j = 0; j !== 2 && !found; j++) {
      for (let k = 0; k !== 2 && !found; k++) {
        for (let l = 0; l !== 2 && !found; l++) {
          rj.set(0, 0, 0);

          if (j) {
            rj.vadd(sides[0], rj);
          } else {
            rj.vsub(sides[0], rj);
          }

          if (k) {
            rj.vadd(sides[1], rj);
          } else {
            rj.vsub(sides[1], rj);
          }

          if (l) {
            rj.vadd(sides[2], rj);
          } else {
            rj.vsub(sides[2], rj);
          } // World position of corner


          xj.vadd(rj, sphere_to_corner);
          sphere_to_corner.vsub(xi, sphere_to_corner);

          if (sphere_to_corner.lengthSquared() < R * R) {
            if (justTest) {
              return true;
            }

            found = true;
            const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
            r.ri.copy(sphere_to_corner);
            r.ri.normalize();
            r.ni.copy(r.ri);
            r.ri.scale(R, r.ri);
            r.rj.copy(rj); // Make relative to bodies

            r.ri.vadd(xi, r.ri);
            r.ri.vsub(bi.position, r.ri);
            r.rj.vadd(xj, r.rj);
            r.rj.vsub(bj.position, r.rj);
            this.result.push(r);
            this.createFrictionEquationsFromContact(r, this.frictionResult);
          }
        }
      }
    }

    v3pool.release(rj);
    rj = null; // Check edges

    const edgeTangent = v3pool.get();
    const edgeCenter = v3pool.get();
    const r = v3pool.get(); // r = edge center to sphere center

    const orthogonal = v3pool.get();
    const dist = v3pool.get();
    const Nsides = sides.length;

    for (let j = 0; j !== Nsides && !found; j++) {
      for (let k = 0; k !== Nsides && !found; k++) {
        if (j % 3 !== k % 3) {
          // Get edge tangent
          sides[k].cross(sides[j], edgeTangent);
          edgeTangent.normalize();
          sides[j].vadd(sides[k], edgeCenter);
          r.copy(xi);
          r.vsub(edgeCenter, r);
          r.vsub(xj, r);
          const orthonorm = r.dot(edgeTangent); // distance from edge center to sphere center in the tangent direction

          edgeTangent.scale(orthonorm, orthogonal); // Vector from edge center to sphere center in the tangent direction
          // Find the third side orthogonal to this one

          let l = 0;

          while (l === j % 3 || l === k % 3) {
            l++;
          } // vec from edge center to sphere projected to the plane orthogonal to the edge tangent


          dist.copy(xi);
          dist.vsub(orthogonal, dist);
          dist.vsub(edgeCenter, dist);
          dist.vsub(xj, dist); // Distances in tangent direction and distance in the plane orthogonal to it

          const tdist = Math.abs(orthonorm);
          const ndist = dist.length();

          if (tdist < sides[l].length() && ndist < R) {
            if (justTest) {
              return true;
            }

            found = true;
            const res = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
            edgeCenter.vadd(orthogonal, res.rj); // box rj

            res.rj.copy(res.rj);
            dist.negate(res.ni);
            res.ni.normalize();
            res.ri.copy(res.rj);
            res.ri.vadd(xj, res.ri);
            res.ri.vsub(xi, res.ri);
            res.ri.normalize();
            res.ri.scale(R, res.ri); // Make relative to bodies

            res.ri.vadd(xi, res.ri);
            res.ri.vsub(bi.position, res.ri);
            res.rj.vadd(xj, res.rj);
            res.rj.vsub(bj.position, res.rj);
            this.result.push(res);
            this.createFrictionEquationsFromContact(res, this.frictionResult);
          }
        }
      }
    }

    v3pool.release(edgeTangent, edgeCenter, r, orthogonal, dist);
  }

  planeBox(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    sj.convexPolyhedronRepresentation.material = sj.material;
    sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;
    sj.convexPolyhedronRepresentation.id = sj.id;
    return this.planeConvex(si, sj.convexPolyhedronRepresentation, xi, xj, qi, qj, bi, bj, si, sj, justTest);
  }

  convexConvex(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest, faceListA, faceListB) {
    const sepAxis = convexConvex_sepAxis;

    if (xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius) {
      return;
    }

    if (si.findSeparatingAxis(sj, xi, qi, xj, qj, sepAxis, faceListA, faceListB)) {
      const res = [];
      const q = convexConvex_q;
      si.clipAgainstHull(xi, qi, sj, xj, qj, sepAxis, -100, 100, res);
      let numContacts = 0;

      for (let j = 0; j !== res.length; j++) {
        if (justTest) {
          return true;
        }

        const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
        const ri = r.ri;
        const rj = r.rj;
        sepAxis.negate(r.ni);
        res[j].normal.negate(q);
        q.scale(res[j].depth, q);
        res[j].point.vadd(q, ri);
        rj.copy(res[j].point); // Contact points are in world coordinates. Transform back to relative

        ri.vsub(xi, ri);
        rj.vsub(xj, rj); // Make relative to bodies

        ri.vadd(xi, ri);
        ri.vsub(bi.position, ri);
        rj.vadd(xj, rj);
        rj.vsub(bj.position, rj);
        this.result.push(r);
        numContacts++;

        if (!this.enableFrictionReduction) {
          this.createFrictionEquationsFromContact(r, this.frictionResult);
        }
      }

      if (this.enableFrictionReduction && numContacts) {
        this.createFrictionFromAverage(numContacts);
      }
    }
  }

  sphereConvex(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    const v3pool = this.v3pool;
    xi.vsub(xj, convex_to_sphere);
    const normals = sj.faceNormals;
    const faces = sj.faces;
    const verts = sj.vertices;
    const R = si.radius;
    //     return;
    // }

    let found = false; // Check corners

    for (let i = 0; i !== verts.length; i++) {
      const v = verts[i]; // World position of corner

      const worldCorner = sphereConvex_worldCorner;
      qj.vmult(v, worldCorner);
      xj.vadd(worldCorner, worldCorner);
      const sphere_to_corner = sphereConvex_sphereToCorner;
      worldCorner.vsub(xi, sphere_to_corner);

      if (sphere_to_corner.lengthSquared() < R * R) {
        if (justTest) {
          return true;
        }

        found = true;
        const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
        r.ri.copy(sphere_to_corner);
        r.ri.normalize();
        r.ni.copy(r.ri);
        r.ri.scale(R, r.ri);
        worldCorner.vsub(xj, r.rj); // Should be relative to the body.

        r.ri.vadd(xi, r.ri);
        r.ri.vsub(bi.position, r.ri); // Should be relative to the body.

        r.rj.vadd(xj, r.rj);
        r.rj.vsub(bj.position, r.rj);
        this.result.push(r);
        this.createFrictionEquationsFromContact(r, this.frictionResult);
        return;
      }
    } // Check side (plane) intersections


    for (let i = 0, nfaces = faces.length; i !== nfaces && found === false; i++) {
      const normal = normals[i];
      const face = faces[i]; // Get world-transformed normal of the face

      const worldNormal = sphereConvex_worldNormal;
      qj.vmult(normal, worldNormal); // Get a world vertex from the face

      const worldPoint = sphereConvex_worldPoint;
      qj.vmult(verts[face[0]], worldPoint);
      worldPoint.vadd(xj, worldPoint); // Get a point on the sphere, closest to the face normal

      const worldSpherePointClosestToPlane = sphereConvex_worldSpherePointClosestToPlane;
      worldNormal.scale(-R, worldSpherePointClosestToPlane);
      xi.vadd(worldSpherePointClosestToPlane, worldSpherePointClosestToPlane); // Vector from a face point to the closest point on the sphere

      const penetrationVec = sphereConvex_penetrationVec;
      worldSpherePointClosestToPlane.vsub(worldPoint, penetrationVec); // The penetration. Negative value means overlap.

      const penetration = penetrationVec.dot(worldNormal);
      const worldPointToSphere = sphereConvex_sphereToWorldPoint;
      xi.vsub(worldPoint, worldPointToSphere);

      if (penetration < 0 && worldPointToSphere.dot(worldNormal) > 0) {
        // Intersects plane. Now check if the sphere is inside the face polygon
        const faceVerts = []; // Face vertices, in world coords

        for (let j = 0, Nverts = face.length; j !== Nverts; j++) {
          const worldVertex = v3pool.get();
          qj.vmult(verts[face[j]], worldVertex);
          xj.vadd(worldVertex, worldVertex);
          faceVerts.push(worldVertex);
        }

        if (pointInPolygon(faceVerts, worldNormal, xi)) {
          // Is the sphere center in the face polygon?
          if (justTest) {
            return true;
          }

          found = true;
          const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
          worldNormal.scale(-R, r.ri); // Contact offset, from sphere center to contact

          worldNormal.negate(r.ni); // Normal pointing out of sphere

          const penetrationVec2 = v3pool.get();
          worldNormal.scale(-penetration, penetrationVec2);
          const penetrationSpherePoint = v3pool.get();
          worldNormal.scale(-R, penetrationSpherePoint); //xi.vsub(xj).vadd(penetrationSpherePoint).vadd(penetrationVec2 , r.rj);

          xi.vsub(xj, r.rj);
          r.rj.vadd(penetrationSpherePoint, r.rj);
          r.rj.vadd(penetrationVec2, r.rj); // Should be relative to the body.

          r.rj.vadd(xj, r.rj);
          r.rj.vsub(bj.position, r.rj); // Should be relative to the body.

          r.ri.vadd(xi, r.ri);
          r.ri.vsub(bi.position, r.ri);
          v3pool.release(penetrationVec2);
          v3pool.release(penetrationSpherePoint);
          this.result.push(r);
          this.createFrictionEquationsFromContact(r, this.frictionResult); // Release world vertices

          for (let j = 0, Nfaceverts = faceVerts.length; j !== Nfaceverts; j++) {
            v3pool.release(faceVerts[j]);
          }

          return; // We only expect *one* face contact
        } else {
          // Edge?
          for (let j = 0; j !== face.length; j++) {
            // Get two world transformed vertices
            const v1 = v3pool.get();
            const v2 = v3pool.get();
            qj.vmult(verts[face[(j + 1) % face.length]], v1);
            qj.vmult(verts[face[(j + 2) % face.length]], v2);
            xj.vadd(v1, v1);
            xj.vadd(v2, v2); // Construct edge vector

            const edge = sphereConvex_edge;
            v2.vsub(v1, edge); // Construct the same vector, but normalized

            const edgeUnit = sphereConvex_edgeUnit;
            edge.unit(edgeUnit); // p is xi projected onto the edge

            const p = v3pool.get();
            const v1_to_xi = v3pool.get();
            xi.vsub(v1, v1_to_xi);
            const dot = v1_to_xi.dot(edgeUnit);
            edgeUnit.scale(dot, p);
            p.vadd(v1, p); // Compute a vector from p to the center of the sphere

            const xi_to_p = v3pool.get();
            p.vsub(xi, xi_to_p); // Collision if the edge-sphere distance is less than the radius
            // AND if p is in between v1 and v2

            if (dot > 0 && dot * dot < edge.lengthSquared() && xi_to_p.lengthSquared() < R * R) {
              // Collision if the edge-sphere distance is less than the radius
              // Edge contact!
              if (justTest) {
                return true;
              }

              const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
              p.vsub(xj, r.rj);
              p.vsub(xi, r.ni);
              r.ni.normalize();
              r.ni.scale(R, r.ri); // Should be relative to the body.

              r.rj.vadd(xj, r.rj);
              r.rj.vsub(bj.position, r.rj); // Should be relative to the body.

              r.ri.vadd(xi, r.ri);
              r.ri.vsub(bi.position, r.ri);
              this.result.push(r);
              this.createFrictionEquationsFromContact(r, this.frictionResult); // Release world vertices

              for (let j = 0, Nfaceverts = faceVerts.length; j !== Nfaceverts; j++) {
                v3pool.release(faceVerts[j]);
              }

              v3pool.release(v1);
              v3pool.release(v2);
              v3pool.release(p);
              v3pool.release(xi_to_p);
              v3pool.release(v1_to_xi);
              return;
            }

            v3pool.release(v1);
            v3pool.release(v2);
            v3pool.release(p);
            v3pool.release(xi_to_p);
            v3pool.release(v1_to_xi);
          }
        } // Release world vertices


        for (let j = 0, Nfaceverts = faceVerts.length; j !== Nfaceverts; j++) {
          v3pool.release(faceVerts[j]);
        }
      }
    }
  }

  planeConvex(planeShape, convexShape, planePosition, convexPosition, planeQuat, convexQuat, planeBody, convexBody, si, sj, justTest) {
    // Simply return the points behind the plane.
    const worldVertex = planeConvex_v;
    const worldNormal = planeConvex_normal;
    worldNormal.set(0, 0, 1);
    planeQuat.vmult(worldNormal, worldNormal); // Turn normal according to plane orientation

    let numContacts = 0;
    const relpos = planeConvex_relpos;

    for (let i = 0; i !== convexShape.vertices.length; i++) {
      // Get world convex vertex
      worldVertex.copy(convexShape.vertices[i]);
      convexQuat.vmult(worldVertex, worldVertex);
      convexPosition.vadd(worldVertex, worldVertex);
      worldVertex.vsub(planePosition, relpos);
      const dot = worldNormal.dot(relpos);

      if (dot <= 0.0) {
        if (justTest) {
          return true;
        }

        const r = this.createContactEquation(planeBody, convexBody, planeShape, convexShape, si, sj); // Get vertex position projected on plane

        const projected = planeConvex_projected;
        worldNormal.scale(worldNormal.dot(relpos), projected);
        worldVertex.vsub(projected, projected);
        projected.vsub(planePosition, r.ri); // From plane to vertex projected on plane

        r.ni.copy(worldNormal); // Contact normal is the plane normal out from plane
        // rj is now just the vector from the convex center to the vertex

        worldVertex.vsub(convexPosition, r.rj); // Make it relative to the body

        r.ri.vadd(planePosition, r.ri);
        r.ri.vsub(planeBody.position, r.ri);
        r.rj.vadd(convexPosition, r.rj);
        r.rj.vsub(convexBody.position, r.rj);
        this.result.push(r);
        numContacts++;

        if (!this.enableFrictionReduction) {
          this.createFrictionEquationsFromContact(r, this.frictionResult);
        }
      }
    }

    if (this.enableFrictionReduction && numContacts) {
      this.createFrictionFromAverage(numContacts);
    }
  }

  boxConvex(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    si.convexPolyhedronRepresentation.material = si.material;
    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
    return this.convexConvex(si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);
  }

  sphereHeightfield(sphereShape, hfShape, spherePos, hfPos, sphereQuat, hfQuat, sphereBody, hfBody, rsi, rsj, justTest) {
    const data = hfShape.data;
    const radius = sphereShape.radius;
    const w = hfShape.elementSize;
    const worldPillarOffset = sphereHeightfield_tmp2; // Get sphere position to heightfield local!

    const localSpherePos = sphereHeightfield_tmp1;
    Transform.pointToLocalFrame(hfPos, hfQuat, spherePos, localSpherePos); // Get the index of the data points to test against

    let iMinX = Math.floor((localSpherePos.x - radius) / w) - 1;
    let iMaxX = Math.ceil((localSpherePos.x + radius) / w) + 1;
    let iMinY = Math.floor((localSpherePos.y - radius) / w) - 1;
    let iMaxY = Math.ceil((localSpherePos.y + radius) / w) + 1; // Bail out if we are out of the terrain

    if (iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMinY > data[0].length) {
      return;
    } // Clamp index to edges


    if (iMinX < 0) {
      iMinX = 0;
    }

    if (iMaxX < 0) {
      iMaxX = 0;
    }

    if (iMinY < 0) {
      iMinY = 0;
    }

    if (iMaxY < 0) {
      iMaxY = 0;
    }

    if (iMinX >= data.length) {
      iMinX = data.length - 1;
    }

    if (iMaxX >= data.length) {
      iMaxX = data.length - 1;
    }

    if (iMaxY >= data[0].length) {
      iMaxY = data[0].length - 1;
    }

    if (iMinY >= data[0].length) {
      iMinY = data[0].length - 1;
    }

    const minMax = [];
    hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
    const min = minMax[0];
    const max = minMax[1]; // Bail out if we can't touch the bounding height box

    if (localSpherePos.z - radius > max || localSpherePos.z + radius < min) {
      return;
    }

    const result = this.result;

    for (let i = iMinX; i < iMaxX; i++) {
      for (let j = iMinY; j < iMaxY; j++) {
        const numContactsBefore = result.length;
        let intersecting = false; // Lower triangle

        hfShape.getConvexTrianglePillar(i, j, false);
        Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);

        if (spherePos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius) {
          intersecting = this.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody, sphereShape, hfShape, justTest);
        }

        if (justTest && intersecting) {
          return true;
        } // Upper triangle


        hfShape.getConvexTrianglePillar(i, j, true);
        Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);

        if (spherePos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius) {
          intersecting = this.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody, sphereShape, hfShape, justTest);
        }

        if (justTest && intersecting) {
          return true;
        }

        const numContacts = result.length - numContactsBefore;

        if (numContacts > 2) {
          return;
        }
        /*
          // Skip all but 1
          for (let k = 0; k < numContacts - 1; k++) {
              result.pop();
          }
        */

      }
    }
  }

  boxHeightfield(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    si.convexPolyhedronRepresentation.material = si.material;
    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
    return this.convexHeightfield(si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);
  }

  convexHeightfield(convexShape, hfShape, convexPos, hfPos, convexQuat, hfQuat, convexBody, hfBody, rsi, rsj, justTest) {
    const data = hfShape.data;
    const w = hfShape.elementSize;
    const radius = convexShape.boundingSphereRadius;
    const worldPillarOffset = convexHeightfield_tmp2;
    const faceList = convexHeightfield_faceList; // Get sphere position to heightfield local!

    const localConvexPos = convexHeightfield_tmp1;
    Transform.pointToLocalFrame(hfPos, hfQuat, convexPos, localConvexPos); // Get the index of the data points to test against

    let iMinX = Math.floor((localConvexPos.x - radius) / w) - 1;
    let iMaxX = Math.ceil((localConvexPos.x + radius) / w) + 1;
    let iMinY = Math.floor((localConvexPos.y - radius) / w) - 1;
    let iMaxY = Math.ceil((localConvexPos.y + radius) / w) + 1; // Bail out if we are out of the terrain

    if (iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMinY > data[0].length) {
      return;
    } // Clamp index to edges


    if (iMinX < 0) {
      iMinX = 0;
    }

    if (iMaxX < 0) {
      iMaxX = 0;
    }

    if (iMinY < 0) {
      iMinY = 0;
    }

    if (iMaxY < 0) {
      iMaxY = 0;
    }

    if (iMinX >= data.length) {
      iMinX = data.length - 1;
    }

    if (iMaxX >= data.length) {
      iMaxX = data.length - 1;
    }

    if (iMaxY >= data[0].length) {
      iMaxY = data[0].length - 1;
    }

    if (iMinY >= data[0].length) {
      iMinY = data[0].length - 1;
    }

    const minMax = [];
    hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
    const min = minMax[0];
    const max = minMax[1]; // Bail out if we're cant touch the bounding height box

    if (localConvexPos.z - radius > max || localConvexPos.z + radius < min) {
      return;
    }

    for (let i = iMinX; i < iMaxX; i++) {
      for (let j = iMinY; j < iMaxY; j++) {
        let intersecting = false; // Lower triangle

        hfShape.getConvexTrianglePillar(i, j, false);
        Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);

        if (convexPos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius) {
          intersecting = this.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, null, null, justTest, faceList, null);
        }

        if (justTest && intersecting) {
          return true;
        } // Upper triangle


        hfShape.getConvexTrianglePillar(i, j, true);
        Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);

        if (convexPos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius) {
          intersecting = this.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, null, null, justTest, faceList, null);
        }

        if (justTest && intersecting) {
          return true;
        }
      }
    }
  }

  sphereParticle(sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest) {
    // The normal is the unit vector from sphere center to particle center
    const normal = particleSphere_normal;
    normal.set(0, 0, 1);
    xi.vsub(xj, normal);
    const lengthSquared = normal.lengthSquared();

    if (lengthSquared <= sj.radius * sj.radius) {
      if (justTest) {
        return true;
      }

      const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
      normal.normalize();
      r.rj.copy(normal);
      r.rj.scale(sj.radius, r.rj);
      r.ni.copy(normal); // Contact normal

      r.ni.negate(r.ni);
      r.ri.set(0, 0, 0); // Center of particle

      this.result.push(r);
      this.createFrictionEquationsFromContact(r, this.frictionResult);
    }
  }

  planeParticle(sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest) {
    const normal = particlePlane_normal;
    normal.set(0, 0, 1);
    bj.quaternion.vmult(normal, normal); // Turn normal according to plane orientation

    const relpos = particlePlane_relpos;
    xi.vsub(bj.position, relpos);
    const dot = normal.dot(relpos);

    if (dot <= 0.0) {
      if (justTest) {
        return true;
      }

      const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
      r.ni.copy(normal); // Contact normal is the plane normal

      r.ni.negate(r.ni);
      r.ri.set(0, 0, 0); // Center of particle
      // Get particle position projected on plane

      const projected = particlePlane_projected;
      normal.scale(normal.dot(xi), projected);
      xi.vsub(projected, projected); //projected.vadd(bj.position,projected);
      // rj is now the projected world position minus plane position

      r.rj.copy(projected);
      this.result.push(r);
      this.createFrictionEquationsFromContact(r, this.frictionResult);
    }
  }

  boxParticle(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    si.convexPolyhedronRepresentation.material = si.material;
    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
    return this.convexParticle(si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);
  }

  convexParticle(sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest) {
    let penetratedFaceIndex = -1;
    const penetratedFaceNormal = convexParticle_penetratedFaceNormal;
    const worldPenetrationVec = convexParticle_worldPenetrationVec;
    let minPenetration = null;

    const local = convexParticle_local;
    local.copy(xi);
    local.vsub(xj, local); // Convert position to relative the convex origin

    qj.conjugate(cqj);
    cqj.vmult(local, local);

    if (sj.pointIsInside(local)) {
      if (sj.worldVerticesNeedsUpdate) {
        sj.computeWorldVertices(xj, qj);
      }

      if (sj.worldFaceNormalsNeedsUpdate) {
        sj.computeWorldFaceNormals(qj);
      } // For each world polygon in the polyhedra


      for (let i = 0, nfaces = sj.faces.length; i !== nfaces; i++) {
        // Construct world face vertices
        const verts = [sj.worldVertices[sj.faces[i][0]]];
        const normal = sj.worldFaceNormals[i]; // Check how much the particle penetrates the polygon plane.

        xi.vsub(verts[0], convexParticle_vertexToParticle);
        const penetration = -normal.dot(convexParticle_vertexToParticle);

        if (minPenetration === null || Math.abs(penetration) < Math.abs(minPenetration)) {
          if (justTest) {
            return true;
          }

          minPenetration = penetration;
          penetratedFaceIndex = i;
          penetratedFaceNormal.copy(normal);
        }
      }

      if (penetratedFaceIndex !== -1) {
        // Setup contact
        const r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
        penetratedFaceNormal.scale(minPenetration, worldPenetrationVec); // rj is the particle position projected to the face

        worldPenetrationVec.vadd(xi, worldPenetrationVec);
        worldPenetrationVec.vsub(xj, worldPenetrationVec);
        r.rj.copy(worldPenetrationVec); //const projectedToFace = xi.vsub(xj).vadd(worldPenetrationVec);
        //projectedToFace.copy(r.rj);
        //qj.vmult(r.rj,r.rj);

        penetratedFaceNormal.negate(r.ni); // Contact normal

        r.ri.set(0, 0, 0); // Center of particle

        const ri = r.ri;
        const rj = r.rj; // Make relative to bodies

        ri.vadd(xi, ri);
        ri.vsub(bi.position, ri);
        rj.vadd(xj, rj);
        rj.vsub(bj.position, rj);
        this.result.push(r);
        this.createFrictionEquationsFromContact(r, this.frictionResult);
      } else {
        console.warn('Point found inside convex, but did not find penetrating face!');
      }
    }
  }

  heightfieldCylinder(hfShape, convexShape, hfPos, convexPos, hfQuat, convexQuat, hfBody, convexBody, rsi, rsj, justTest) {
    return this.convexHeightfield(convexShape, hfShape, convexPos, hfPos, convexQuat, hfQuat, convexBody, hfBody, rsi, rsj, justTest);
  }

  particleCylinder(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
    return this.convexParticle(sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest);
  }

  sphereTrimesh(sphereShape, trimeshShape, spherePos, trimeshPos, sphereQuat, trimeshQuat, sphereBody, trimeshBody, rsi, rsj, justTest) {
    const edgeVertexA = sphereTrimesh_edgeVertexA;
    const edgeVertexB = sphereTrimesh_edgeVertexB;
    const edgeVector = sphereTrimesh_edgeVector;
    const edgeVectorUnit = sphereTrimesh_edgeVectorUnit;
    const localSpherePos = sphereTrimesh_localSpherePos;
    const tmp = sphereTrimesh_tmp;
    const localSphereAABB = sphereTrimesh_localSphereAABB;
    const v2 = sphereTrimesh_v2;
    const relpos = sphereTrimesh_relpos;
    const triangles = sphereTrimesh_triangles; // Convert sphere position to local in the trimesh

    Transform.pointToLocalFrame(trimeshPos, trimeshQuat, spherePos, localSpherePos); // Get the aabb of the sphere locally in the trimesh

    const sphereRadius = sphereShape.radius;
    localSphereAABB.lowerBound.set(localSpherePos.x - sphereRadius, localSpherePos.y - sphereRadius, localSpherePos.z - sphereRadius);
    localSphereAABB.upperBound.set(localSpherePos.x + sphereRadius, localSpherePos.y + sphereRadius, localSpherePos.z + sphereRadius);
    trimeshShape.getTrianglesInAABB(localSphereAABB, triangles); //for (let i = 0; i < trimeshShape.indices.length / 3; i++) triangles.push(i); // All
    // Vertices

    const v = sphereTrimesh_v;
    const radiusSquared = sphereShape.radius * sphereShape.radius;

    for (let i = 0; i < triangles.length; i++) {
      for (let j = 0; j < 3; j++) {
        trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + j], v); // Check vertex overlap in sphere

        v.vsub(localSpherePos, relpos);

        if (relpos.lengthSquared() <= radiusSquared) {
          // Safe up
          v2.copy(v);
          Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v);
          v.vsub(spherePos, relpos);

          if (justTest) {
            return true;
          }

          let r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape, rsi, rsj);
          r.ni.copy(relpos);
          r.ni.normalize(); // ri is the vector from sphere center to the sphere surface

          r.ri.copy(r.ni);
          r.ri.scale(sphereShape.radius, r.ri);
          r.ri.vadd(spherePos, r.ri);
          r.ri.vsub(sphereBody.position, r.ri);
          r.rj.copy(v);
          r.rj.vsub(trimeshBody.position, r.rj); // Store result

          this.result.push(r);
          this.createFrictionEquationsFromContact(r, this.frictionResult);
        }
      }
    } // Check all edges


    for (let i = 0; i < triangles.length; i++) {
      for (let j = 0; j < 3; j++) {
        trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + j], edgeVertexA);
        trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + (j + 1) % 3], edgeVertexB);
        edgeVertexB.vsub(edgeVertexA, edgeVector); // Project sphere position to the edge

        localSpherePos.vsub(edgeVertexB, tmp);
        const positionAlongEdgeB = tmp.dot(edgeVector);
        localSpherePos.vsub(edgeVertexA, tmp);
        let positionAlongEdgeA = tmp.dot(edgeVector);

        if (positionAlongEdgeA > 0 && positionAlongEdgeB < 0) {
          // Now check the orthogonal distance from edge to sphere center
          localSpherePos.vsub(edgeVertexA, tmp);
          edgeVectorUnit.copy(edgeVector);
          edgeVectorUnit.normalize();
          positionAlongEdgeA = tmp.dot(edgeVectorUnit);
          edgeVectorUnit.scale(positionAlongEdgeA, tmp);
          tmp.vadd(edgeVertexA, tmp); // tmp is now the sphere center position projected to the edge, defined locally in the trimesh frame

          const dist = tmp.distanceTo(localSpherePos);

          if (dist < sphereShape.radius) {
            if (justTest) {
              return true;
            }

            const r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape, rsi, rsj);
            tmp.vsub(localSpherePos, r.ni);
            r.ni.normalize();
            r.ni.scale(sphereShape.radius, r.ri);
            r.ri.vadd(spherePos, r.ri);
            r.ri.vsub(sphereBody.position, r.ri);
            Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp, tmp);
            tmp.vsub(trimeshBody.position, r.rj);
            Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);
            Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);
            this.result.push(r);
            this.createFrictionEquationsFromContact(r, this.frictionResult);
          }
        }
      }
    } // Triangle faces


    const va = sphereTrimesh_va;
    const vb = sphereTrimesh_vb;
    const vc = sphereTrimesh_vc;
    const normal = sphereTrimesh_normal;

    for (let i = 0, N = triangles.length; i !== N; i++) {
      trimeshShape.getTriangleVertices(triangles[i], va, vb, vc);
      trimeshShape.getNormal(triangles[i], normal);
      localSpherePos.vsub(va, tmp);
      let dist = tmp.dot(normal);
      normal.scale(dist, tmp);
      localSpherePos.vsub(tmp, tmp); // tmp is now the sphere position projected to the triangle plane

      dist = tmp.distanceTo(localSpherePos);

      if (Ray.pointInTriangle(tmp, va, vb, vc) && dist < sphereShape.radius) {
        if (justTest) {
          return true;
        }

        let r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape, rsi, rsj);
        tmp.vsub(localSpherePos, r.ni);
        r.ni.normalize();
        r.ni.scale(sphereShape.radius, r.ri);
        r.ri.vadd(spherePos, r.ri);
        r.ri.vsub(sphereBody.position, r.ri);
        Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp, tmp);
        tmp.vsub(trimeshBody.position, r.rj);
        Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);
        Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);
        this.result.push(r);
        this.createFrictionEquationsFromContact(r, this.frictionResult);
      }
    }

    triangles.length = 0;
  }

  planeTrimesh(planeShape, trimeshShape, planePos, trimeshPos, planeQuat, trimeshQuat, planeBody, trimeshBody, rsi, rsj, justTest) {
    // Make contacts!
    const v = new Vec3();
    const normal = planeTrimesh_normal;
    normal.set(0, 0, 1);
    planeQuat.vmult(normal, normal); // Turn normal according to plane

    for (let i = 0; i < trimeshShape.vertices.length / 3; i++) {
      // Get world vertex from trimesh
      trimeshShape.getVertex(i, v); // Safe up

      const v2 = new Vec3();
      v2.copy(v);
      Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v); // Check plane side

      const relpos = planeTrimesh_relpos;
      v.vsub(planePos, relpos);
      const dot = normal.dot(relpos);

      if (dot <= 0.0) {
        if (justTest) {
          return true;
        }

        const r = this.createContactEquation(planeBody, trimeshBody, planeShape, trimeshShape, rsi, rsj);
        r.ni.copy(normal); // Contact normal is the plane normal
        // Get vertex position projected on plane

        const projected = planeTrimesh_projected;
        normal.scale(relpos.dot(normal), projected);
        v.vsub(projected, projected); // ri is the projected world position minus plane position

        r.ri.copy(projected);
        r.ri.vsub(planeBody.position, r.ri);
        r.rj.copy(v);
        r.rj.vsub(trimeshBody.position, r.rj); // Store result

        this.result.push(r);
        this.createFrictionEquationsFromContact(r, this.frictionResult);
      }
    }
  } // convexTrimesh(
  //   si: ConvexPolyhedron, sj: Trimesh, xi: Vec3, xj: Vec3, qi: Quaternion, qj: Quaternion,
  //   bi: Body, bj: Body, rsi?: Shape | null, rsj?: Shape | null,
  //   faceListA?: number[] | null, faceListB?: number[] | null,
  // ) {
  //   const sepAxis = convexConvex_sepAxis;
  //   if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){
  //       return;
  //   }
  //   // Construct a temp hull for each triangle
  //   const hullB = new ConvexPolyhedron();
  //   hullB.faces = [[0,1,2]];
  //   const va = new Vec3();
  //   const vb = new Vec3();
  //   const vc = new Vec3();
  //   hullB.vertices = [
  //       va,
  //       vb,
  //       vc
  //   ];
  //   for (let i = 0; i < sj.indices.length / 3; i++) {
  //       const triangleNormal = new Vec3();
  //       sj.getNormal(i, triangleNormal);
  //       hullB.faceNormals = [triangleNormal];
  //       sj.getTriangleVertices(i, va, vb, vc);
  //       let d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);
  //       if(!d){
  //           triangleNormal.scale(-1, triangleNormal);
  //           d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);
  //           if(!d){
  //               continue;
  //           }
  //       }
  //       const res: ConvexPolyhedronContactPoint[] = [];
  //       const q = convexConvex_q;
  //       si.clipAgainstHull(xi,qi,hullB,xj,qj,triangleNormal,-100,100,res);
  //       for(let j = 0; j !== res.length; j++){
  //           const r = this.createContactEquation(bi,bj,si,sj,rsi,rsj),
  //               ri = r.ri,
  //               rj = r.rj;
  //           r.ni.copy(triangleNormal);
  //           r.ni.negate(r.ni);
  //           res[j].normal.negate(q);
  //           q.mult(res[j].depth, q);
  //           res[j].point.vadd(q, ri);
  //           rj.copy(res[j].point);
  //           // Contact points are in world coordinates. Transform back to relative
  //           ri.vsub(xi,ri);
  //           rj.vsub(xj,rj);
  //           // Make relative to bodies
  //           ri.vadd(xi, ri);
  //           ri.vsub(bi.position, ri);
  //           rj.vadd(xj, rj);
  //           rj.vsub(bj.position, rj);
  //           result.push(r);
  //       }
  //   }
  // }


}
const averageNormal = new Vec3();
const averageContactPointA = new Vec3();
const averageContactPointB = new Vec3();
const tmpVec1 = new Vec3();
const tmpVec2 = new Vec3();
const tmpQuat1 = new Quaternion();
const tmpQuat2 = new Quaternion();

const planeTrimesh_normal = new Vec3();
const planeTrimesh_relpos = new Vec3();
const planeTrimesh_projected = new Vec3();
const sphereTrimesh_normal = new Vec3();
const sphereTrimesh_relpos = new Vec3();
const sphereTrimesh_v = new Vec3();
const sphereTrimesh_v2 = new Vec3();
const sphereTrimesh_edgeVertexA = new Vec3();
const sphereTrimesh_edgeVertexB = new Vec3();
const sphereTrimesh_edgeVector = new Vec3();
const sphereTrimesh_edgeVectorUnit = new Vec3();
const sphereTrimesh_localSpherePos = new Vec3();
const sphereTrimesh_tmp = new Vec3();
const sphereTrimesh_va = new Vec3();
const sphereTrimesh_vb = new Vec3();
const sphereTrimesh_vc = new Vec3();
const sphereTrimesh_localSphereAABB = new AABB();
const sphereTrimesh_triangles = [];
const point_on_plane_to_sphere = new Vec3();
const plane_to_sphere_ortho = new Vec3(); // See http://bulletphysics.com/Bullet/BulletFull/SphereTriangleDetector_8cpp_source.html

const pointInPolygon_edge = new Vec3();
const pointInPolygon_edge_x_normal = new Vec3();
const pointInPolygon_vtp = new Vec3();

function pointInPolygon(verts, normal, p) {
  let positiveResult = null;
  const N = verts.length;

  for (let i = 0; i !== N; i++) {
    const v = verts[i]; // Get edge to the next vertex

    const edge = pointInPolygon_edge;
    verts[(i + 1) % N].vsub(v, edge); // Get cross product between polygon normal and the edge

    const edge_x_normal = pointInPolygon_edge_x_normal; //const edge_x_normal = new Vec3();

    edge.cross(normal, edge_x_normal); // Get vector between point and current vertex

    const vertex_to_p = pointInPolygon_vtp;
    p.vsub(v, vertex_to_p); // This dot product determines which side of the edge the point is

    const r = edge_x_normal.dot(vertex_to_p); // If all such dot products have same sign, we are inside the polygon.

    if (positiveResult === null || r > 0 && positiveResult === true || r <= 0 && positiveResult === false) {
      if (positiveResult === null) {
        positiveResult = r > 0;
      }

      continue;
    } else {
      return false; // Encountered some other sign. Exit.
    }
  } // If we got here, all dot products were of the same sign.


  return true;
}

const box_to_sphere = new Vec3();
const sphereBox_ns = new Vec3();
const sphereBox_ns1 = new Vec3();
const sphereBox_ns2 = new Vec3();
const sphereBox_sides = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];
const sphereBox_sphere_to_corner = new Vec3();
const sphereBox_side_ns = new Vec3();
const sphereBox_side_ns1 = new Vec3();
const sphereBox_side_ns2 = new Vec3();
const convex_to_sphere = new Vec3();
const sphereConvex_edge = new Vec3();
const sphereConvex_edgeUnit = new Vec3();
const sphereConvex_sphereToCorner = new Vec3();
const sphereConvex_worldCorner = new Vec3();
const sphereConvex_worldNormal = new Vec3();
const sphereConvex_worldPoint = new Vec3();
const sphereConvex_worldSpherePointClosestToPlane = new Vec3();
const sphereConvex_penetrationVec = new Vec3();
const sphereConvex_sphereToWorldPoint = new Vec3();
const planeConvex_v = new Vec3();
const planeConvex_normal = new Vec3();
const planeConvex_relpos = new Vec3();
const planeConvex_projected = new Vec3();
const convexConvex_sepAxis = new Vec3();
const convexConvex_q = new Vec3();
const particlePlane_normal = new Vec3();
const particlePlane_relpos = new Vec3();
const particlePlane_projected = new Vec3();
const particleSphere_normal = new Vec3(); // WIP

const cqj = new Quaternion();
const convexParticle_local = new Vec3();
const convexParticle_penetratedFaceNormal = new Vec3();
const convexParticle_vertexToParticle = new Vec3();
const convexParticle_worldPenetrationVec = new Vec3();
const convexHeightfield_tmp1 = new Vec3();
const convexHeightfield_tmp2 = new Vec3();
const convexHeightfield_faceList = [0];
const sphereHeightfield_tmp1 = new Vec3();
const sphereHeightfield_tmp2 = new Vec3();

class OverlapKeeper {
  /**
   * @todo Remove useless constructor
   */
  constructor() {
    this.current = void 0;
    this.previous = void 0;
    this.current = [];
    this.previous = [];
  }
  /**
   * getKey
   */


  getKey(i, j) {
    if (j < i) {
      const temp = j;
      j = i;
      i = temp;
    }

    return i << 16 | j;
  }
  /**
   * set
   */


  set(i, j) {
    // Insertion sort. This way the diff will have linear complexity.
    const key = this.getKey(i, j);
    const current = this.current;
    let index = 0;

    while (key > current[index]) {
      index++;
    }

    if (key === current[index]) {
      return; // Pair was already added
    }

    for (let j = current.length - 1; j >= index; j--) {
      current[j + 1] = current[j];
    }

    current[index] = key;
  }
  /**
   * tick
   */


  tick() {
    const tmp = this.current;
    this.current = this.previous;
    this.previous = tmp;
    this.current.length = 0;
  }
  /**
   * getDiff
   */


  getDiff(additions, removals) {
    const a = this.current;
    const b = this.previous;
    const al = a.length;
    const bl = b.length;
    let j = 0;

    for (let i = 0; i < al; i++) {
      let found = false;
      const keyA = a[i];

      while (keyA > b[j]) {
        j++;
      }

      found = keyA === b[j];

      if (!found) {
        unpackAndPush(additions, keyA);
      }
    }

    j = 0;

    for (let i = 0; i < bl; i++) {
      let found = false;
      const keyB = b[i];

      while (keyB > a[j]) {
        j++;
      }

      found = a[j] === keyB;

      if (!found) {
        unpackAndPush(removals, keyB);
      }
    }
  }

}

function unpackAndPush(array, key) {
  array.push((key & 0xffff0000) >> 16, key & 0x0000ffff);
}

/**
 * TupleDictionary
 */
class TupleDictionary {
  constructor() {
    this.data = {
      keys: []
    };
  }

  /** get */
  get(i, j) {
    if (i > j) {
      // swap
      const temp = j;
      j = i;
      i = temp;
    }

    return this.data[i + "-" + j];
  }
  /** set */


  set(i, j, value) {
    if (i > j) {
      const temp = j;
      j = i;
      i = temp;
    }

    const key = i + "-" + j; // Check if key already exists

    if (!this.get(i, j)) {
      this.data.keys.push(key);
    }

    this.data[key] = value;
  }
  /** reset */


  reset() {
    const data = this.data;
    const keys = data.keys;

    while (keys.length > 0) {
      const key = keys.pop();
      delete data[key];
    }
  }

}

/**
 * The physics world
 */
class World extends EventTarget {
  /**
   * Currently / last used timestep. Is set to -1 if not available. This value is updated before each internal step, which means that it is "fresh" inside event callbacks.
   */

  /**
   * Makes bodies go to sleep when they've been inactive.
   * @default false
   */

  /**
   * All the current contacts (instances of ContactEquation) in the world.
   */

  /**
   * How often to normalize quaternions. Set to 0 for every step, 1 for every second etc.. A larger value increases performance. If bodies tend to explode, set to a smaller value (zero to be sure nothing can go wrong).
   * @default 0
   */

  /**
   * Set to true to use fast quaternion normalization. It is often enough accurate to use.
   * If bodies tend to explode, set to false.
   * @default false
   */

  /**
   * The wall-clock time since simulation start.
   */

  /**
   * Number of timesteps taken since start.
   */

  /**
   * Default and last timestep sizes.
   */

  /**
   * The gravity of the world.
   */

  /**
   * The broadphase algorithm to use.
   * @default NaiveBroadphase
   */

  /**
   * All bodies in this world
   */

  /**
   * True if any bodies are not sleeping, false if every body is sleeping.
   */

  /**
   * The solver algorithm to use.
   * @default GSSolver
   */

  /**
   * collisionMatrix
   */

  /**
   * CollisionMatrix from the previous step.
   */

  /**
   * All added materials.
   * @deprecated
   * @todo Remove
   */

  /**
   * All added contactmaterials.
   */

  /**
   * Used to look up a ContactMaterial given two instances of Material.
   */

  /**
   * The default material of the bodies.
   */

  /**
   * This contact material is used if no suitable contactmaterial is found for a contact.
   */

  /**
   * Time accumulator for interpolation.
   * @see https://gafferongames.com/game-physics/fix-your-timestep/
   */

  /**
   * Dispatched after a body has been added to the world.
   */

  /**
   * Dispatched after a body has been removed from the world.
   */
  constructor(options = {}) {
    super();
    this.dt = void 0;
    this.allowSleep = void 0;
    this.contacts = void 0;
    this.frictionEquations = void 0;
    this.quatNormalizeSkip = void 0;
    this.quatNormalizeFast = void 0;
    this.time = void 0;
    this.stepnumber = void 0;
    this.default_dt = void 0;
    this.nextId = void 0;
    this.gravity = void 0;
    this.broadphase = void 0;
    this.bodies = void 0;
    this.hasActiveBodies = void 0;
    this.solver = void 0;
    this.constraints = void 0;
    this.narrowphase = void 0;
    this.collisionMatrix = void 0;
    this.collisionMatrixPrevious = void 0;
    this.bodyOverlapKeeper = void 0;
    this.shapeOverlapKeeper = void 0;
    this.materials = void 0;
    this.contactmaterials = void 0;
    this.contactMaterialTable = void 0;
    this.defaultMaterial = void 0;
    this.defaultContactMaterial = void 0;
    this.doProfiling = void 0;
    this.profile = void 0;
    this.accumulator = void 0;
    this.subsystems = void 0;
    this.addBodyEvent = void 0;
    this.removeBodyEvent = void 0;
    this.idToBodyMap = void 0;
    this.dt = -1;
    this.allowSleep = !!options.allowSleep;
    this.contacts = [];
    this.frictionEquations = [];
    this.quatNormalizeSkip = options.quatNormalizeSkip !== undefined ? options.quatNormalizeSkip : 0;
    this.quatNormalizeFast = options.quatNormalizeFast !== undefined ? options.quatNormalizeFast : false;
    this.time = 0.0;
    this.stepnumber = 0;
    this.default_dt = 1 / 60;
    this.nextId = 0;
    this.gravity = new Vec3();

    if (options.gravity) {
      this.gravity.copy(options.gravity);
    }

    this.broadphase = options.broadphase !== undefined ? options.broadphase : new NaiveBroadphase();
    this.bodies = [];
    this.hasActiveBodies = false;
    this.solver = options.solver !== undefined ? options.solver : new GSSolver();
    this.constraints = [];
    this.narrowphase = new Narrowphase(this);
    this.collisionMatrix = new ArrayCollisionMatrix();
    this.collisionMatrixPrevious = new ArrayCollisionMatrix();
    this.bodyOverlapKeeper = new OverlapKeeper();
    this.shapeOverlapKeeper = new OverlapKeeper();
    this.materials = [];
    this.contactmaterials = [];
    this.contactMaterialTable = new TupleDictionary();
    this.defaultMaterial = new Material('default');
    this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial, this.defaultMaterial, {
      friction: 0.3,
      restitution: 0.0
    });
    this.doProfiling = false;
    this.profile = {
      solve: 0,
      makeContactConstraints: 0,
      broadphase: 0,
      integrate: 0,
      narrowphase: 0
    };
    this.accumulator = 0;
    this.subsystems = [];
    this.addBodyEvent = {
      type: 'addBody',
      body: null
    };
    this.removeBodyEvent = {
      type: 'removeBody',
      body: null
    };
    this.idToBodyMap = {};
    this.broadphase.setWorld(this);
  }
  /**
   * Get the contact material between materials m1 and m2
   * @return The contact material if it was found.
   */


  getContactMaterial(m1, m2) {
    return this.contactMaterialTable.get(m1.id, m2.id);
  }
  /**
   * Get number of objects in the world.
   * @deprecated
   */


  numObjects() {
    return this.bodies.length;
  }
  /**
   * Store old collision state info
   */


  collisionMatrixTick() {
    const temp = this.collisionMatrixPrevious;
    this.collisionMatrixPrevious = this.collisionMatrix;
    this.collisionMatrix = temp;
    this.collisionMatrix.reset();
    this.bodyOverlapKeeper.tick();
    this.shapeOverlapKeeper.tick();
  }
  /**
   * Add a constraint to the simulation.
   */


  addConstraint(c) {
    this.constraints.push(c);
  }
  /**
   * Removes a constraint
   */


  removeConstraint(c) {
    const idx = this.constraints.indexOf(c);

    if (idx !== -1) {
      this.constraints.splice(idx, 1);
    }
  }
  /**
   * Raycast test
   * @deprecated Use .raycastAll, .raycastClosest or .raycastAny instead.
   */


  rayTest(from, to, result) {
    if (result instanceof RaycastResult) {
      // Do raycastClosest
      this.raycastClosest(from, to, {
        skipBackfaces: true
      }, result);
    } else {
      // Do raycastAll
      this.raycastAll(from, to, {
        skipBackfaces: true
      }, result);
    }
  }
  /**
   * Ray cast against all bodies. The provided callback will be executed for each hit with a RaycastResult as single argument.
   * @return True if any body was hit.
   */


  raycastAll(from, to, options = {}, callback) {
    options.mode = Ray.ALL;
    options.from = from;
    options.to = to;
    options.callback = callback;
    return tmpRay.intersectWorld(this, options);
  }
  /**
   * Ray cast, and stop at the first result. Note that the order is random - but the method is fast.
   * @return True if any body was hit.
   */


  raycastAny(from, to, options = {}, result) {
    options.mode = Ray.ANY;
    options.from = from;
    options.to = to;
    options.result = result;
    return tmpRay.intersectWorld(this, options);
  }
  /**
   * Ray cast, and return information of the closest hit.
   * @return True if any body was hit.
   */


  raycastClosest(from, to, options = {}, result) {
    options.mode = Ray.CLOSEST;
    options.from = from;
    options.to = to;
    options.result = result;
    return tmpRay.intersectWorld(this, options);
  }
  /**
   * Add a rigid body to the simulation.
   * @todo If the simulation has not yet started, why recrete and copy arrays for each body? Accumulate in dynamic arrays in this case.
   * @todo Adding an array of bodies should be possible. This would save some loops too
   */


  addBody(body) {
    if (this.bodies.includes(body)) {
      return;
    }

    body.index = this.bodies.length;
    this.bodies.push(body);
    body.world = this;
    body.initPosition.copy(body.position);
    body.initVelocity.copy(body.velocity);
    body.timeLastSleepy = this.time;

    if (body instanceof Body) {
      body.initAngularVelocity.copy(body.angularVelocity);
      body.initQuaternion.copy(body.quaternion);
    }

    this.collisionMatrix.setNumObjects(this.bodies.length);
    this.addBodyEvent.body = body;
    this.idToBodyMap[body.id] = body;
    this.dispatchEvent(this.addBodyEvent);
  }
  /**
   * Remove a rigid body from the simulation.
   */


  removeBody(body) {
    body.world = null;
    const n = this.bodies.length - 1;
    const bodies = this.bodies;
    const idx = bodies.indexOf(body);

    if (idx !== -1) {
      bodies.splice(idx, 1); // Todo: should use a garbage free method
      // Recompute index

      for (let i = 0; i !== bodies.length; i++) {
        bodies[i].index = i;
      }

      this.collisionMatrix.setNumObjects(n);
      this.removeBodyEvent.body = body;
      delete this.idToBodyMap[body.id];
      this.dispatchEvent(this.removeBodyEvent);
    }
  }

  getBodyById(id) {
    return this.idToBodyMap[id];
  }
  /**
   * @todo Make a faster map
   */


  getShapeById(id) {
    const bodies = this.bodies;

    for (let i = 0; i < bodies.length; i++) {
      const shapes = bodies[i].shapes;

      for (let j = 0; j < shapes.length; j++) {
        const shape = shapes[j];

        if (shape.id === id) {
          return shape;
        }
      }
    }

    return null;
  }
  /**
   * Adds a material to the World.
   * @deprecated
   * @todo Remove
   */


  addMaterial(m) {
    this.materials.push(m);
  }
  /**
   * Adds a contact material to the World
   */


  addContactMaterial(cmat) {
    // Add contact material
    this.contactmaterials.push(cmat); // Add current contact material to the material table

    this.contactMaterialTable.set(cmat.materials[0].id, cmat.materials[1].id, cmat);
  }
  /**
   * Step the physics world forward in time.
   *
   * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.
   *
   * @param dt The fixed time step size to use.
   * @param timeSinceLastCalled The time elapsed since the function was last called.
   * @param maxSubSteps Maximum number of fixed steps to take per function call.
   * @see https://web.archive.org/web/20180426154531/http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World#What_do_the_parameters_to_btDynamicsWorld::stepSimulation_mean.3F
   * @example
   *     // fixed timestepping without interpolation
   *     world.step(1 / 60)
   */


  step(dt, timeSinceLastCalled, maxSubSteps = 10) {
    if (timeSinceLastCalled === undefined) {
      // Fixed, simple stepping
      this.internalStep(dt); // Increment time

      this.time += dt;
    } else {
      this.accumulator += timeSinceLastCalled;
      const t0 = performance.now();
      let substeps = 0;

      while (this.accumulator >= dt && substeps < maxSubSteps) {
        // Do fixed steps to catch up
        this.internalStep(dt);
        this.accumulator -= dt;
        substeps++;

        if (performance.now() - t0 > dt * 1000) {
          // The framerate is not interactive anymore.
          // We are below the target framerate.
          // Better bail out.
          break;
        }
      } // Remove the excess accumulator, since we may not
      // have had enough substeps available to catch up


      this.accumulator = this.accumulator % dt;
      const t = this.accumulator / dt;

      for (let j = 0; j !== this.bodies.length; j++) {
        const b = this.bodies[j];
        b.previousPosition.lerp(b.position, t, b.interpolatedPosition);
        b.previousQuaternion.slerp(b.quaternion, t, b.interpolatedQuaternion);
        b.previousQuaternion.normalize();
      }

      this.time += timeSinceLastCalled;
    }
  }

  internalStep(dt) {
    this.dt = dt;
    const contacts = this.contacts;
    const p1 = World_step_p1;
    const p2 = World_step_p2;
    const N = this.numObjects();
    const bodies = this.bodies;
    const solver = this.solver;
    const gravity = this.gravity;
    const doProfiling = this.doProfiling;
    const profile = this.profile;
    const DYNAMIC = Body.DYNAMIC;
    let profilingStart = -Infinity;
    const constraints = this.constraints;
    const frictionEquationPool = World_step_frictionEquationPool;
    gravity.length();
    const gx = gravity.x;
    const gy = gravity.y;
    const gz = gravity.z;
    let i = 0;

    if (doProfiling) {
      profilingStart = performance.now();
    } // Add gravity to all objects


    for (i = 0; i !== N; i++) {
      const bi = bodies[i];

      if (bi.type === DYNAMIC) {
        // Only for dynamic bodies
        const f = bi.force;
        const m = bi.mass;
        f.x += m * gx;
        f.y += m * gy;
        f.z += m * gz;
      }
    } // Update subsystems


    for (let i = 0, Nsubsystems = this.subsystems.length; i !== Nsubsystems; i++) {
      this.subsystems[i].update();
    } // Collision detection


    if (doProfiling) {
      profilingStart = performance.now();
    }

    p1.length = 0; // Clean up pair arrays from last step

    p2.length = 0;
    this.broadphase.collisionPairs(this, p1, p2);

    if (doProfiling) {
      profile.broadphase = performance.now() - profilingStart;
    } // Remove constrained pairs with collideConnected == false


    let Nconstraints = constraints.length;

    for (i = 0; i !== Nconstraints; i++) {
      const c = constraints[i];

      if (!c.collideConnected) {
        for (let j = p1.length - 1; j >= 0; j -= 1) {
          if (c.bodyA === p1[j] && c.bodyB === p2[j] || c.bodyB === p1[j] && c.bodyA === p2[j]) {
            p1.splice(j, 1);
            p2.splice(j, 1);
          }
        }
      }
    }

    this.collisionMatrixTick(); // Generate contacts

    if (doProfiling) {
      profilingStart = performance.now();
    }

    const oldcontacts = World_step_oldContacts;
    const NoldContacts = contacts.length;

    for (i = 0; i !== NoldContacts; i++) {
      oldcontacts.push(contacts[i]);
    }

    contacts.length = 0; // Transfer FrictionEquation from current list to the pool for reuse

    const NoldFrictionEquations = this.frictionEquations.length;

    for (i = 0; i !== NoldFrictionEquations; i++) {
      frictionEquationPool.push(this.frictionEquations[i]);
    }

    this.frictionEquations.length = 0;
    this.narrowphase.getContacts(p1, p2, this, contacts, oldcontacts, // To be reused
    this.frictionEquations, frictionEquationPool);

    if (doProfiling) {
      profile.narrowphase = performance.now() - profilingStart;
    } // Loop over all collisions


    if (doProfiling) {
      profilingStart = performance.now();
    } // Add all friction eqs


    for (i = 0; i < this.frictionEquations.length; i++) {
      solver.addEquation(this.frictionEquations[i]);
    }

    const ncontacts = contacts.length;

    for (let k = 0; k !== ncontacts; k++) {
      // Current contact
      const c = contacts[k]; // Get current collision indeces

      const bi = c.bi;
      const bj = c.bj;
      const si = c.si;
      const sj = c.sj; // Get collision properties

      let cm;

      if (bi.material && bj.material) {
        cm = this.getContactMaterial(bi.material, bj.material) || this.defaultContactMaterial;
      } else {
        cm = this.defaultContactMaterial;
      } // c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;


      cm.friction; // c.restitution = cm.restitution;
      // If friction or restitution were specified in the material, use them

      if (bi.material && bj.material) {
        if (bi.material.friction >= 0 && bj.material.friction >= 0) {
          bi.material.friction * bj.material.friction;
        }

        if (bi.material.restitution >= 0 && bj.material.restitution >= 0) {
          c.restitution = bi.material.restitution * bj.material.restitution;
        }
      } // c.setSpookParams(
      //           cm.contactEquationStiffness,
      //           cm.contactEquationRelaxation,
      //           dt
      //       );


      solver.addEquation(c); // // Add friction constraint equation
      // if(mu > 0){
      // 	// Create 2 tangent equations
      // 	const mug = mu * gnorm;
      // 	const reducedMass = (bi.invMass + bj.invMass);
      // 	if(reducedMass > 0){
      // 		reducedMass = 1/reducedMass;
      // 	}
      // 	const pool = frictionEquationPool;
      // 	const c1 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);
      // 	const c2 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);
      // 	this.frictionEquations.push(c1, c2);
      // 	c1.bi = c2.bi = bi;
      // 	c1.bj = c2.bj = bj;
      // 	c1.minForce = c2.minForce = -mug*reducedMass;
      // 	c1.maxForce = c2.maxForce = mug*reducedMass;
      // 	// Copy over the relative vectors
      // 	c1.ri.copy(c.ri);
      // 	c1.rj.copy(c.rj);
      // 	c2.ri.copy(c.ri);
      // 	c2.rj.copy(c.rj);
      // 	// Construct tangents
      // 	c.ni.tangents(c1.t, c2.t);
      //           // Set spook params
      //           c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);
      //           c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);
      //           c1.enabled = c2.enabled = c.enabled;
      // 	// Add equations to solver
      // 	solver.addEquation(c1);
      // 	solver.addEquation(c2);
      // }

      if (bi.allowSleep && bi.type === Body.DYNAMIC && bi.sleepState === Body.SLEEPING && bj.sleepState === Body.AWAKE && bj.type !== Body.STATIC) {
        const speedSquaredB = bj.velocity.lengthSquared() + bj.angularVelocity.lengthSquared();
        const speedLimitSquaredB = bj.sleepSpeedLimit ** 2;

        if (speedSquaredB >= speedLimitSquaredB * 2) {
          bi.wakeUpAfterNarrowphase = true;
        }
      }

      if (bj.allowSleep && bj.type === Body.DYNAMIC && bj.sleepState === Body.SLEEPING && bi.sleepState === Body.AWAKE && bi.type !== Body.STATIC) {
        const speedSquaredA = bi.velocity.lengthSquared() + bi.angularVelocity.lengthSquared();
        const speedLimitSquaredA = bi.sleepSpeedLimit ** 2;

        if (speedSquaredA >= speedLimitSquaredA * 2) {
          bj.wakeUpAfterNarrowphase = true;
        }
      } // Now we know that i and j are in contact. Set collision matrix state


      this.collisionMatrix.set(bi, bj, true);

      if (!this.collisionMatrixPrevious.get(bi, bj)) {
        // First contact!
        // We reuse the collideEvent object, otherwise we will end up creating new objects for each new contact, even if there's no event listener attached.
        World_step_collideEvent.body = bj;
        World_step_collideEvent.contact = c;
        bi.dispatchEvent(World_step_collideEvent);
        World_step_collideEvent.body = bi;
        bj.dispatchEvent(World_step_collideEvent);
      }

      this.bodyOverlapKeeper.set(bi.id, bj.id);
      this.shapeOverlapKeeper.set(si.id, sj.id);
    }

    this.emitContactEvents();

    if (doProfiling) {
      profile.makeContactConstraints = performance.now() - profilingStart;
      profilingStart = performance.now();
    } // Wake up bodies


    for (i = 0; i !== N; i++) {
      const bi = bodies[i];

      if (bi.wakeUpAfterNarrowphase) {
        bi.wakeUp();
        bi.wakeUpAfterNarrowphase = false;
      }
    } // Add user-added constraints


    Nconstraints = constraints.length;

    for (i = 0; i !== Nconstraints; i++) {
      const c = constraints[i];
      c.update();

      for (let j = 0, Neq = c.equations.length; j !== Neq; j++) {
        const eq = c.equations[j];
        solver.addEquation(eq);
      }
    } // Solve the constrained system


    solver.solve(dt, this);

    if (doProfiling) {
      profile.solve = performance.now() - profilingStart;
    } // Remove all contacts from solver


    solver.removeAllEquations(); // Apply damping, see http://code.google.com/p/bullet/issues/detail?id=74 for details

    const pow = Math.pow;

    for (i = 0; i !== N; i++) {
      const bi = bodies[i];

      if (bi.type & DYNAMIC) {
        // Only for dynamic bodies
        const ld = pow(1.0 - bi.linearDamping, dt);
        const v = bi.velocity;
        v.scale(ld, v);
        const av = bi.angularVelocity;

        if (av) {
          const ad = pow(1.0 - bi.angularDamping, dt);
          av.scale(ad, av);
        }
      }
    }

    this.dispatchEvent(World_step_preStepEvent); // Invoke pre-step callbacks

    for (i = 0; i !== N; i++) {
      const bi = bodies[i];

      if (bi.preStep) {
        bi.preStep.call(bi);
      }
    } // Leap frog
    // vnew = v + h*f/m
    // xnew = x + h*vnew


    if (doProfiling) {
      profilingStart = performance.now();
    }

    const stepnumber = this.stepnumber;
    const quatNormalize = stepnumber % (this.quatNormalizeSkip + 1) === 0;
    const quatNormalizeFast = this.quatNormalizeFast;

    for (i = 0; i !== N; i++) {
      bodies[i].integrate(dt, quatNormalize, quatNormalizeFast);
    }

    this.clearForces();
    this.broadphase.dirty = true;

    if (doProfiling) {
      profile.integrate = performance.now() - profilingStart;
    } // Update step number


    this.stepnumber += 1;
    this.dispatchEvent(World_step_postStepEvent); // Invoke post-step callbacks

    for (i = 0; i !== N; i++) {
      const bi = bodies[i];
      const postStep = bi.postStep;

      if (postStep) {
        postStep.call(bi);
      }
    } // Sleeping update


    let hasActiveBodies = true;

    if (this.allowSleep) {
      hasActiveBodies = false;

      for (i = 0; i !== N; i++) {
        const bi = bodies[i];
        bi.sleepTick(this.time);

        if (bi.sleepState !== Body.SLEEPING) {
          hasActiveBodies = true;
        }
      }
    }

    this.hasActiveBodies = hasActiveBodies;
  }

  emitContactEvents() {
    const hasBeginContact = this.hasAnyEventListener('beginContact');
    const hasEndContact = this.hasAnyEventListener('endContact');

    if (hasBeginContact || hasEndContact) {
      this.bodyOverlapKeeper.getDiff(additions, removals);
    }

    if (hasBeginContact) {
      for (let i = 0, l = additions.length; i < l; i += 2) {
        beginContactEvent.bodyA = this.getBodyById(additions[i]);
        beginContactEvent.bodyB = this.getBodyById(additions[i + 1]);
        this.dispatchEvent(beginContactEvent);
      }

      beginContactEvent.bodyA = beginContactEvent.bodyB = null;
    }

    if (hasEndContact) {
      for (let i = 0, l = removals.length; i < l; i += 2) {
        endContactEvent.bodyA = this.getBodyById(removals[i]);
        endContactEvent.bodyB = this.getBodyById(removals[i + 1]);
        this.dispatchEvent(endContactEvent);
      }

      endContactEvent.bodyA = endContactEvent.bodyB = null;
    }

    additions.length = removals.length = 0;
    const hasBeginShapeContact = this.hasAnyEventListener('beginShapeContact');
    const hasEndShapeContact = this.hasAnyEventListener('endShapeContact');

    if (hasBeginShapeContact || hasEndShapeContact) {
      this.shapeOverlapKeeper.getDiff(additions, removals);
    }

    if (hasBeginShapeContact) {
      for (let i = 0, l = additions.length; i < l; i += 2) {
        const shapeA = this.getShapeById(additions[i]);
        const shapeB = this.getShapeById(additions[i + 1]);
        beginShapeContactEvent.shapeA = shapeA;
        beginShapeContactEvent.shapeB = shapeB;
        if (shapeA) beginShapeContactEvent.bodyA = shapeA.body;
        if (shapeB) beginShapeContactEvent.bodyB = shapeB.body;
        this.dispatchEvent(beginShapeContactEvent);
      }

      beginShapeContactEvent.bodyA = beginShapeContactEvent.bodyB = beginShapeContactEvent.shapeA = beginShapeContactEvent.shapeB = null;
    }

    if (hasEndShapeContact) {
      for (let i = 0, l = removals.length; i < l; i += 2) {
        const shapeA = this.getShapeById(removals[i]);
        const shapeB = this.getShapeById(removals[i + 1]);
        endShapeContactEvent.shapeA = shapeA;
        endShapeContactEvent.shapeB = shapeB;
        if (shapeA) endShapeContactEvent.bodyA = shapeA.body;
        if (shapeB) endShapeContactEvent.bodyB = shapeB.body;
        this.dispatchEvent(endShapeContactEvent);
      }

      endShapeContactEvent.bodyA = endShapeContactEvent.bodyB = endShapeContactEvent.shapeA = endShapeContactEvent.shapeB = null;
    }
  }
  /**
   * Sets all body forces in the world to zero.
   */


  clearForces() {
    const bodies = this.bodies;
    const N = bodies.length;

    for (let i = 0; i !== N; i++) {
      const b = bodies[i];
      b.force;
      b.torque;
      b.force.set(0, 0, 0);
      b.torque.set(0, 0, 0);
    }
  }

} // Temp stuff

new AABB();
const tmpRay = new Ray(); // performance.now() fallback on Date.now()

const performance = globalThis.performance || {};

if (!performance.now) {
  let nowOffset = Date.now();

  if (performance.timing && performance.timing.navigationStart) {
    nowOffset = performance.timing.navigationStart;
  }

  performance.now = () => Date.now() - nowOffset;
}
// Reusable event objects to save memory.

const World_step_postStepEvent = {
  type: 'postStep'
}; // Dispatched before the world steps forward in time.

const World_step_preStepEvent = {
  type: 'preStep'
};
const World_step_collideEvent = {
  type: Body.COLLIDE_EVENT_NAME,
  body: null,
  contact: null
}; // Pools for unused objects

const World_step_oldContacts = [];
const World_step_frictionEquationPool = []; // Reusable arrays for collision pairs

const World_step_p1 = [];
const World_step_p2 = []; // Stuff for emitContactEvents

const additions = [];
const removals = [];
const beginContactEvent = {
  type: 'beginContact',
  bodyA: null,
  bodyB: null
};
const endContactEvent = {
  type: 'endContact',
  bodyA: null,
  bodyB: null
};
const beginShapeContactEvent = {
  type: 'beginShapeContact',
  bodyA: null,
  bodyB: null,
  shapeA: null,
  shapeB: null
};
const endShapeContactEvent = {
  type: 'endShapeContact',
  bodyA: null,
  bodyB: null,
  shapeA: null,
  shapeB: null
};




/***/ }),

/***/ "./Assets/Components/BasketballController.re.ts":
/*!******************************************************!*\
  !*** ./Assets/Components/BasketballController.re.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BasketballController)
/* harmony export */ });
/* harmony import */ var Assets_rogue_packages_rogue_cannon_Components_CannonBody_re__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Assets/rogue_packages/rogue-cannon/Components/CannonBody.re */ "./Assets/rogue_packages/rogue-cannon/Components/CannonBody.re.ts");
/* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js");
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rogue-engine */ "rogue-engine");
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(rogue_engine__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ "three");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _ProjectileObject_re__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ProjectileObject.re */ "./Assets/Components/ProjectileObject.re.ts");
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};





const { Prop } = rogue_engine__WEBPACK_IMPORTED_MODULE_1__;
class BasketballController extends rogue_engine__WEBPACK_IMPORTED_MODULE_1__.Component {
  constructor() {
    super(...arguments);
    this.isOutOfRange = false;
  }
  awake() {
    this.cannonBody = rogue_engine__WEBPACK_IMPORTED_MODULE_1__.getComponent(Assets_rogue_packages_rogue_cannon_Components_CannonBody_re__WEBPACK_IMPORTED_MODULE_0__["default"], this.object3d);
    this.projectileController = rogue_engine__WEBPACK_IMPORTED_MODULE_1__.getComponent(_ProjectileObject_re__WEBPACK_IMPORTED_MODULE_3__["default"], this.object3d);
  }
  start() {
  }
  isOutOfBoundaries() {
    const position = this.cannonBody.body.position;
    return position.x > this.maxBoundaries.x || position.x < this.minBoundaries.x || position.y > this.maxBoundaries.y || position.y < this.minBoundaries.y || position.z > this.maxBoundaries.z || position.z < this.minBoundaries.z;
  }
  resetPosition() {
    this.projectileController.setMassEnabled(false);
    this.cannonBody.body.velocity.setZero();
    const newPos = this.getNewPosition();
    this.cannonBody.body.position = newPos;
    this.cannonBody.body.angularVelocity.setZero();
    this.cannonBody.body.quaternion.set(0, 0, 0, 1);
    this.cannonBody.body.initQuaternion.set(0, 0, 0, 1);
    this.cannonBody.body.previousQuaternion.set(0, 0, 0, 1);
    this.cannonBody.body.interpolatedQuaternion.set(0, 0, 0, 1);
    this.projectileController.isDragEnabled = true;
    this.isOutOfRange = false;
  }
  getNewPosition() {
    const newX = three__WEBPACK_IMPORTED_MODULE_2__.MathUtils.randFloat(this.minInitPosition.x, this.maxInitPosition.x);
    const newY = three__WEBPACK_IMPORTED_MODULE_2__.MathUtils.randFloat(this.minInitPosition.y, this.maxInitPosition.y);
    const newZ = three__WEBPACK_IMPORTED_MODULE_2__.MathUtils.randFloat(this.minInitPosition.z, this.maxInitPosition.z);
    return new cannon_es__WEBPACK_IMPORTED_MODULE_4__.Vec3(newX, newY, newZ);
  }
  update() {
    if (this.isOutOfBoundaries() && !this.isOutOfRange) {
      this.isOutOfRange = true;
      setTimeout(() => {
        this.resetPosition();
      }, 1e3);
    }
  }
}
__name(BasketballController, "BasketballController");
__decorateClass([
  Prop("Vector3")
], BasketballController.prototype, "maxBoundaries", 2);
__decorateClass([
  Prop("Vector3")
], BasketballController.prototype, "minBoundaries", 2);
__decorateClass([
  Prop("Vector3")
], BasketballController.prototype, "maxInitPosition", 2);
__decorateClass([
  Prop("Vector3")
], BasketballController.prototype, "minInitPosition", 2);
rogue_engine__WEBPACK_IMPORTED_MODULE_1__.registerComponent(BasketballController);


/***/ }),

/***/ "./Assets/Components/Bomb.re.ts":
/*!**************************************!*\
  !*** ./Assets/Components/Bomb.re.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Bomb)
/* harmony export */ });
/* harmony import */ var Assets_rogue_packages_rogue_cannon_Components_CannonBody_re__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Assets/rogue_packages/rogue-cannon/Components/CannonBody.re */ "./Assets/rogue_packages/rogue-cannon/Components/CannonBody.re.ts");
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rogue-engine */ "rogue-engine");
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(rogue_engine__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _BombTimer_re__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BombTimer.re */ "./Assets/Components/BombTimer.re.ts");
/* harmony import */ var _Explodable_re__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Explodable.re */ "./Assets/Components/Explodable.re.ts");
/* harmony import */ var _ProjectileObject_re__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ProjectileObject.re */ "./Assets/Components/ProjectileObject.re.ts");
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};





const { Prop } = rogue_engine__WEBPACK_IMPORTED_MODULE_1__;
class Bomb extends rogue_engine__WEBPACK_IMPORTED_MODULE_1__.Component {
  constructor() {
    super(...arguments);
    this.explosionForce = 100;
  }
  awake() {
    this.bombBody = rogue_engine__WEBPACK_IMPORTED_MODULE_1__.getComponent(Assets_rogue_packages_rogue_cannon_Components_CannonBody_re__WEBPACK_IMPORTED_MODULE_0__["default"], this.object3d);
    this.projectileController = rogue_engine__WEBPACK_IMPORTED_MODULE_1__.getComponent(_ProjectileObject_re__WEBPACK_IMPORTED_MODULE_4__["default"], this.object3d);
  }
  start() {
    this.bombTimer = this.bombTimerPrefab.instantiate();
    this.bombTimerController = rogue_engine__WEBPACK_IMPORTED_MODULE_1__.getComponent(_BombTimer_re__WEBPACK_IMPORTED_MODULE_2__["default"], this.bombTimer);
    this.bombTimerController.onTimerEnds(() => {
      _Explodable_re__WEBPACK_IMPORTED_MODULE_3__["default"].addForce(this.bombBody.body.position, this.explosionForce);
      this.object3d.parent?.remove(this.object3d);
      this.bombTimer.parent?.remove(this.bombTimer);
    });
    this.projectileController.onLaunch(() => {
      this.bombTimerController.startCount();
    });
  }
  update() {
    if (this.bombTimer)
      this.bombTimer.position.copy(this.object3d.position);
  }
}
__name(Bomb, "Bomb");
__decorateClass([
  Prop("Prefab")
], Bomb.prototype, "bombTimerPrefab", 2);
__decorateClass([
  Prop("Number")
], Bomb.prototype, "explosionForce", 2);
rogue_engine__WEBPACK_IMPORTED_MODULE_1__.registerComponent(Bomb);


/***/ }),

/***/ "./Assets/Components/BombTimer.re.ts":
/*!*******************************************!*\
  !*** ./Assets/Components/BombTimer.re.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BombTimer)
/* harmony export */ });
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rogue-engine */ "rogue-engine");
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rogue_engine__WEBPACK_IMPORTED_MODULE_0__);
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};

const { Prop } = rogue_engine__WEBPACK_IMPORTED_MODULE_0__;
class BombTimer extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor() {
    super(...arguments);
    this.timerStarted = false;
    this.onTimerEndCallbacks = [];
  }
  awake() {
    this.object3d.visible = false;
  }
  startCount() {
    this.object3d.visible = true;
    this.endTime = rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Runtime.clock.elapsedTime + this.duration;
    this.timerStarted = true;
  }
  update() {
    if (this.timerStarted) {
      const now = rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Runtime.clock.elapsedTime;
      if (now > this.endTime) {
        this.timerStarted = false;
        this.runTimeEndCallbacks();
      } else {
        const w = (this.endTime - now) / this.duration;
        this.timerProgress.position.setX(-0.5 + w * 0.5);
        this.timerProgress.scale.setX(w);
      }
    }
  }
  onTimerEnds(callback) {
    this.onTimerEndCallbacks.push(callback);
  }
  runTimeEndCallbacks() {
    for (const callback of this.onTimerEndCallbacks) {
      callback();
    }
  }
}
__name(BombTimer, "BombTimer");
__decorateClass([
  Prop("Object3D")
], BombTimer.prototype, "timerProgress", 2);
__decorateClass([
  Prop("Number")
], BombTimer.prototype, "duration", 2);
rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(BombTimer);


/***/ }),

/***/ "./Assets/Components/CameraController.re.ts":
/*!**************************************************!*\
  !*** ./Assets/Components/CameraController.re.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CameraController)
/* harmony export */ });
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rogue-engine */ "rogue-engine");
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rogue_engine__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ "three");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_1__);
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};


const { Prop } = rogue_engine__WEBPACK_IMPORTED_MODULE_0__;
class CameraController extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor() {
    super(...arguments);
    this.offset = 1;
    this.smooth = 0.1;
    this.limitZ = 1;
    this.maxCameraX = 1.6;
    this.minCameraX = 0.16;
  }
  update() {
    if (this.target) {
      const newX = this.target.position.x + this.offset;
      const smoothX = three__WEBPACK_IMPORTED_MODULE_1__.MathUtils.lerp(this.target.position.x, newX, this.smooth);
      const clampedX = three__WEBPACK_IMPORTED_MODULE_1__.MathUtils.clamp(smoothX, this.minCameraX, this.maxCameraX);
      this.object3d.position.x = clampedX;
    }
  }
}
__name(CameraController, "CameraController");
__decorateClass([
  Prop("Object3D")
], CameraController.prototype, "target", 2);
__decorateClass([
  Prop("Number")
], CameraController.prototype, "offset", 2);
__decorateClass([
  Prop("Number")
], CameraController.prototype, "smooth", 2);
__decorateClass([
  Prop("Number")
], CameraController.prototype, "limitZ", 2);
__decorateClass([
  Prop("Number")
], CameraController.prototype, "maxCameraX", 2);
__decorateClass([
  Prop("Number")
], CameraController.prototype, "minCameraX", 2);
rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(CameraController);


/***/ }),

/***/ "./Assets/Components/Explodable.re.ts":
/*!********************************************!*\
  !*** ./Assets/Components/Explodable.re.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Explodable)
/* harmony export */ });
/* harmony import */ var Assets_rogue_packages_rogue_cannon_Components_CannonBody_re__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Assets/rogue_packages/rogue-cannon/Components/CannonBody.re */ "./Assets/rogue_packages/rogue-cannon/Components/CannonBody.re.ts");
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rogue-engine */ "rogue-engine");
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(rogue_engine__WEBPACK_IMPORTED_MODULE_1__);
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};


const { Prop } = rogue_engine__WEBPACK_IMPORTED_MODULE_1__;
const _Explodable = class extends rogue_engine__WEBPACK_IMPORTED_MODULE_1__.Component {
  constructor() {
    super(...arguments);
    this.enableMassWhenExplodes = true;
  }
  awake() {
    this.cannonBody = rogue_engine__WEBPACK_IMPORTED_MODULE_1__.getComponent(Assets_rogue_packages_rogue_cannon_Components_CannonBody_re__WEBPACK_IMPORTED_MODULE_0__["default"], this.object3d);
    this._mass = this.cannonBody.mass;
    this.cannonBody.mass = 0;
  }
  start() {
    _Explodable.explodables.push(this);
    if (!this.enableMassWhenExplodes) {
      setTimeout(() => {
        this.enableMass();
      }, 2500);
    }
  }
  enableMass() {
    this.cannonBody.mass = this._mass;
  }
  addForce(vector, force) {
    const impulseDirection = this.cannonBody.body.position.vsub(vector);
    const distanceFromForceVector = this.cannonBody.body.position.distanceTo(vector);
    const scaleImpulse = 1 / (distanceFromForceVector * distanceFromForceVector);
    const vImpulse = impulseDirection.scale(scaleImpulse).scale(force);
    this.enableMassWhenExplodes && this.enableMass();
    this.cannonBody.body.applyForce(vImpulse);
  }
};
let Explodable = _Explodable;
__name(Explodable, "Explodable");
Explodable.layerCollision = 3;
Explodable.explodables = [];
Explodable.addForce = /* @__PURE__ */ __name((vector, force) => {
  for (let i = 0, l = _Explodable.explodables.length; i < l; i++) {
    _Explodable.explodables[i].addForce(vector, force);
  }
}, "addForce");
__decorateClass([
  Prop("Boolean")
], Explodable.prototype, "enableMassWhenExplodes", 2);

rogue_engine__WEBPACK_IMPORTED_MODULE_1__.registerComponent(Explodable);


/***/ }),

/***/ "./Assets/Components/FixColdStart.re.ts":
/*!**********************************************!*\
  !*** ./Assets/Components/FixColdStart.re.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FixColdStart)
/* harmony export */ });
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rogue-engine */ "rogue-engine");
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rogue_engine__WEBPACK_IMPORTED_MODULE_0__);
var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

class FixColdStart extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
  awake() {
    rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Runtime.pause();
  }
  start() {
    setTimeout(() => {
      rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Runtime.play(rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Runtime.scene);
    }, 1e3);
  }
}
__name(FixColdStart, "FixColdStart");
rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(FixColdStart);


/***/ }),

/***/ "./Assets/Components/ProjectileObject.re.ts":
/*!**************************************************!*\
  !*** ./Assets/Components/ProjectileObject.re.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ProjectileObject)
/* harmony export */ });
/* harmony import */ var Assets_rogue_packages_rogue_cannon_Components_CannonBody_re__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Assets/rogue_packages/rogue-cannon/Components/CannonBody.re */ "./Assets/rogue_packages/rogue-cannon/Components/CannonBody.re.ts");
/* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js");
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rogue-engine */ "rogue-engine");
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(rogue_engine__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ "three");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _Static_DeviceUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Static/DeviceUtils */ "./Assets/Components/Static/DeviceUtils.ts");
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};





const { Prop } = rogue_engine__WEBPACK_IMPORTED_MODULE_1__;
class ProjectileObject extends rogue_engine__WEBPACK_IMPORTED_MODULE_1__.Component {
  constructor() {
    super(...arguments);
    this.numPoints = 10;
    this.launchForce = 0.05;
    this.targetName = "";
    this.dragOnTouchScreen = false;
    this.target = new three__WEBPACK_IMPORTED_MODULE_2__.Vector2(0, 0);
    this.useTouches = false;
    this.inputCoordinates = new three__WEBPACK_IMPORTED_MODULE_2__.Vector2(0, 0);
    this.startInputCoords = new three__WEBPACK_IMPORTED_MODULE_2__.Vector2();
    this.isValidTouch = false;
    this.isTouched = false;
    this.trajectoryPoints = [];
    this.onLaunchCB = [];
    this._mass = 1;
    this.isDragEnabled = true;
  }
  awake() {
    this.useTouches = _Static_DeviceUtils__WEBPACK_IMPORTED_MODULE_3__["default"].isMobile();
    this.body = rogue_engine__WEBPACK_IMPORTED_MODULE_1__.getComponent(Assets_rogue_packages_rogue_cannon_Components_CannonBody_re__WEBPACK_IMPORTED_MODULE_0__["default"], this.object3d);
    this._mass = this.body.mass;
    this.setMassEnabled(false);
  }
  start() {
    for (let i = 0; i < this.numPoints; i++) {
      const point = this.pointPrefab.instantiate(this.object3d);
      this.trajectoryPoints.push(point);
    }
    this.raycaster = new three__WEBPACK_IMPORTED_MODULE_2__.Raycaster();
    this.rogueDOMrect = rogue_engine__WEBPACK_IMPORTED_MODULE_1__.Runtime.rogueDOMContainer.getBoundingClientRect();
    _Static_DeviceUtils__WEBPACK_IMPORTED_MODULE_3__["default"].onResizeComplete(() => {
      this.resizeWindowRect();
    });
  }
  resizeWindowRect() {
    this.rogueDOMrect = rogue_engine__WEBPACK_IMPORTED_MODULE_1__.Runtime.rogueDOMContainer.getBoundingClientRect();
  }
  setInputCoordinates() {
    if (this.useTouches) {
      if (rogue_engine__WEBPACK_IMPORTED_MODULE_1__.Input.touch.touches.length > 0)
        this.inputCoordinates.set(rogue_engine__WEBPACK_IMPORTED_MODULE_1__.Input.touch.touches[0].x, rogue_engine__WEBPACK_IMPORTED_MODULE_1__.Input.touch.touches[0].y);
    } else {
      this.inputCoordinates.set(rogue_engine__WEBPACK_IMPORTED_MODULE_1__.Input.mouse.x, rogue_engine__WEBPACK_IMPORTED_MODULE_1__.Input.mouse.y);
    }
  }
  resetPoints() {
    for (let i = 0, l = this.trajectoryPoints.length; i < l; i++) {
      this.trajectoryPoints[i].position.set(0, 0, 0);
    }
  }
  isKeyPressed() {
    return this.useTouches ? rogue_engine__WEBPACK_IMPORTED_MODULE_1__.Input.touch.startTouches.length > 0 : rogue_engine__WEBPACK_IMPORTED_MODULE_1__.Input.mouse.isLeftButtonDown;
  }
  isKeyReleased() {
    return this.useTouches ? rogue_engine__WEBPACK_IMPORTED_MODULE_1__.Input.touch.touches.length == 0 : rogue_engine__WEBPACK_IMPORTED_MODULE_1__.Input.mouse.isLeftButtonUp;
  }
  setMassEnabled(enabled) {
    this.body.mass = enabled ? this._mass : 0;
  }
  update() {
    if (!this.isDragEnabled)
      return;
    this.setInputCoordinates();
    this.isValidTouch = this.dragOnTouchScreen ? true : this.isOverTarget(this.inputCoordinates.x, this.inputCoordinates.y);
    if (this.isValidTouch && this.isKeyPressed()) {
      this.isTouched = true;
      this.startInputCoords.copy(this.inputCoordinates);
    }
    if (this.isTouched) {
      this.moveTrajectory();
    }
    if (this.isTouched && this.isKeyReleased()) {
      this.isTouched = false;
      this.isValidTouch = false;
      this.resetPoints();
      this.launch();
    }
  }
  moveTrajectory() {
    const force = this.startInputCoords.distanceTo(this.inputCoordinates) * this.launchForce;
    const angle = three__WEBPACK_IMPORTED_MODULE_2__.MathUtils.radToDeg(Math.atan2(this.inputCoordinates.y - this.startInputCoords.y, this.inputCoordinates.x - this.startInputCoords.x));
    const spacing = 0.1;
    for (let i = 0, l = this.trajectoryPoints.length; i < l; i++) {
      const element = this.trajectoryPoints[i];
      const spacingElement = spacing * i;
      const x = force * Math.cos(Math.PI / 180 * angle) * spacingElement;
      const y = force * Math.sin(Math.PI / 180 * angle) * spacingElement - 0.5 * 10 * (spacingElement * spacingElement);
      const posPoint = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(-x, y, 0);
      element.position.copy(posPoint);
    }
  }
  launch() {
    const vectorImpulse = this.inputCoordinates.sub(this.startInputCoords);
    this.setMassEnabled(true);
    const vec3Impulse = new cannon_es__WEBPACK_IMPORTED_MODULE_4__.Vec3(-vectorImpulse.x, vectorImpulse.y, 0).scale(this.body.mass * this.launchForce);
    this.body.body.applyImpulse(vec3Impulse);
    this.isDragEnabled = false;
    this.runOnLaunchCallbacks();
  }
  isOverTarget(x, y) {
    this.target.set((x - this.rogueDOMrect.left) / this.rogueDOMrect.width * 2 - 1, -((y - this.rogueDOMrect.top) / this.rogueDOMrect.height) * 2 + 1);
    this.raycaster.setFromCamera(this.target, rogue_engine__WEBPACK_IMPORTED_MODULE_1__.Runtime.camera);
    var intersects = this.raycaster.intersectObjects(rogue_engine__WEBPACK_IMPORTED_MODULE_1__.Runtime.scene.children);
    if (intersects.length == 0)
      return false;
    let isIntersecting = false;
    intersects.forEach((element) => {
      if (element.object.name == this.targetName) {
        isIntersecting = true;
      }
    });
    return isIntersecting;
  }
  onLaunch(callback) {
    this.onLaunchCB.push(callback);
  }
  runOnLaunchCallbacks() {
    for (const callback of this.onLaunchCB) {
      callback();
    }
  }
}
__name(ProjectileObject, "ProjectileObject");
__decorateClass([
  Prop("Prefab")
], ProjectileObject.prototype, "pointPrefab", 2);
__decorateClass([
  Prop("Number")
], ProjectileObject.prototype, "numPoints", 2);
__decorateClass([
  Prop("Number")
], ProjectileObject.prototype, "launchForce", 2);
__decorateClass([
  Prop("String")
], ProjectileObject.prototype, "targetName", 2);
__decorateClass([
  Prop("Boolean")
], ProjectileObject.prototype, "dragOnTouchScreen", 2);
rogue_engine__WEBPACK_IMPORTED_MODULE_1__.registerComponent(ProjectileObject);


/***/ }),

/***/ "./Assets/Components/SceneManager.re.ts":
/*!**********************************************!*\
  !*** ./Assets/Components/SceneManager.re.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SceneManager)
/* harmony export */ });
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rogue-engine */ "rogue-engine");
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rogue_engine__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Static_DeviceUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Static/DeviceUtils */ "./Assets/Components/Static/DeviceUtils.ts");
/* harmony import */ var _UiManager_re__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./UiManager.re */ "./Assets/Components/UiManager.re.ts");
var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });



class SceneManager extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
  start() {
    const uiManager = rogue_engine__WEBPACK_IMPORTED_MODULE_0__.getComponent(_UiManager_re__WEBPACK_IMPORTED_MODULE_2__["default"]);
    uiManager.onUILoaded(() => {
      this.reloadBtn = document.getElementById("reload-button");
      this.reloadBtn.addEventListener(_Static_DeviceUtils__WEBPACK_IMPORTED_MODULE_1__["default"].getClickEventName(), (event) => {
        event.stopPropagation();
        const indexScene = rogue_engine__WEBPACK_IMPORTED_MODULE_0__.App.scenes.map(function(e) {
          return e.uuid;
        }).indexOf(rogue_engine__WEBPACK_IMPORTED_MODULE_0__.App.currentScene.uuid);
        rogue_engine__WEBPACK_IMPORTED_MODULE_0__.App.loadScene(indexScene);
      });
      this.nextSceneBtn = document.getElementById("next-button");
      this.nextSceneBtn.addEventListener(_Static_DeviceUtils__WEBPACK_IMPORTED_MODULE_1__["default"].getClickEventName(), (event) => {
        event.stopPropagation();
        const indexScene = rogue_engine__WEBPACK_IMPORTED_MODULE_0__.App.scenes.map(function(e) {
          return e.uuid;
        }).indexOf(rogue_engine__WEBPACK_IMPORTED_MODULE_0__.App.currentScene.uuid);
        const newSceneIndex = indexScene < rogue_engine__WEBPACK_IMPORTED_MODULE_0__.App.scenes.length - 1 ? indexScene + 1 : 0;
        rogue_engine__WEBPACK_IMPORTED_MODULE_0__.App.loadScene(newSceneIndex);
      });
    });
  }
}
__name(SceneManager, "SceneManager");
rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(SceneManager);


/***/ }),

/***/ "./Assets/Components/Static/DeviceUtils.ts":
/*!*************************************************!*\
  !*** ./Assets/Components/Static/DeviceUtils.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DeviceUtils)
/* harmony export */ });
var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
const _DeviceUtils = class {
  static onResizeComplete(cb) {
    this.onResizeCompleteCb.push(cb);
    if (this.onResizeCompleteCb.length == 1) {
      window.addEventListener("resize", () => {
        this.rtime = new Date();
        if (this.timeout === false) {
          this.timeout = true;
          setTimeout(() => {
            this.resizeend();
          }, this.delta);
        }
      });
    }
  }
  static resizeend() {
    const newTime = new Date();
    const diff = newTime.getTime() - this.rtime.getTime();
    if (diff < this.delta) {
      setTimeout(() => {
        this.resizeend();
      }, this.delta);
    } else {
      this.timeout = false;
      for (let i = 0; i < this.onResizeCompleteCb.length; i++) {
        this.onResizeCompleteCb[i]();
      }
    }
  }
  static isPortrait() {
    return window.innerWidth <= window.innerHeight;
  }
  static isLandscape() {
    return window.innerWidth > window.innerHeight;
  }
  static isMobile() {
    let check = false;
    (function(a) {
      if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4)))
        check = true;
    })(navigator.userAgent || navigator.vendor);
    return check;
  }
  static getRogueCanvas() {
    return document.getElementById("rogue-ui");
  }
  static getAspectRatio() {
    return window.innerWidth / window.innerHeight;
  }
  static getClickEventName() {
    return _DeviceUtils.isMobile() ? "touchstart" : "click";
  }
  static isNavigator(browser) {
    return navigator.userAgent.indexOf(browser) > -1;
  }
  static isSafariMobile() {
    return !this.isNavigator("Chrome") && this.isNavigator("Safari") && this.isMobile();
  }
  static isRogueEditor() {
    return this.isNavigator("RogueEngine");
  }
  static isiOS() {
    return [
      "iPad Simulator",
      "iPhone Simulator",
      "iPod Simulator",
      "iPad",
      "iPhone",
      "iPod"
    ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
  }
  static isValidBrowser() {
    var isChromeOnDesktop = this.isNavigator("Chrome") && !this.isMobile();
    var isFirefoxOnDesktop = this.isNavigator("Firefox") && !this.isMobile();
    var isOperaOnDesktop = this.isNavigator("OPR") && !this.isMobile();
    var isEdgeOnDesktop = this.isNavigator("Edg") && !this.isMobile();
    return isChromeOnDesktop || isFirefoxOnDesktop || isOperaOnDesktop || isEdgeOnDesktop;
  }
};
let DeviceUtils = _DeviceUtils;
__name(DeviceUtils, "DeviceUtils");
DeviceUtils.clickEventName = _DeviceUtils.isMobile() ? "touchstart" : "click";
DeviceUtils.timeout = false;
DeviceUtils.delta = 600;
DeviceUtils.onResizeCompleteCb = [];



/***/ }),

/***/ "./Assets/Components/UiManager.re.ts":
/*!*******************************************!*\
  !*** ./Assets/Components/UiManager.re.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ UiManager)
/* harmony export */ });
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rogue-engine */ "rogue-engine");
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rogue_engine__WEBPACK_IMPORTED_MODULE_0__);
var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

class UiManager extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor() {
    super(...arguments);
    this.onUILoadedCallbacks = [];
  }
  awake() {
    this.initUI();
  }
  async initUI() {
    const htmlPath = rogue_engine__WEBPACK_IMPORTED_MODULE_0__.getStaticPath("ui.html");
    rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Runtime.uiContainer.innerHTML = await (await fetch(htmlPath)).text();
    this.runOnUILoadedCallbacks();
  }
  start() {
  }
  onUILoaded(callback) {
    this.onUILoadedCallbacks.push(callback);
  }
  runOnUILoadedCallbacks() {
    for (const callback of this.onUILoadedCallbacks) {
      callback();
    }
  }
}
__name(UiManager, "UiManager");
rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(UiManager);


/***/ }),

/***/ "./Assets/Components/WebcamController.re.ts":
/*!**************************************************!*\
  !*** ./Assets/Components/WebcamController.re.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebcamController)
/* harmony export */ });
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rogue-engine */ "rogue-engine");
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rogue_engine__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _UiManager_re__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./UiManager.re */ "./Assets/Components/UiManager.re.ts");
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};


const { Prop } = rogue_engine__WEBPACK_IMPORTED_MODULE_0__;
class WebcamController extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor() {
    super(...arguments);
    this.videoFallback = "";
    this.onWebcamReadyCb = [];
  }
  awake() {
    const uiManager = rogue_engine__WEBPACK_IMPORTED_MODULE_0__.getComponent(_UiManager_re__WEBPACK_IMPORTED_MODULE_1__["default"]);
    uiManager.onUILoaded(() => {
      this.setupWebcamTexture();
    });
  }
  setupWebcamTexture() {
    const video = document.getElementById("video");
    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
        video.srcObject = stream;
        video.addEventListener("loadeddata", () => {
          this.runEnabledCallbacks();
        }, false);
        video.play();
      }).catch((err) => {
        if (this.videoFallback != "") {
          video.src = this.videoFallback;
          video.crossOrigin = "anonymous";
          video.load();
          video.addEventListener("loadeddata", () => {
            this.runEnabledCallbacks();
          }, false);
          video.play();
        }
      });
    }
  }
  onWebcamReady(callback) {
    this.onWebcamReadyCb.push(callback);
  }
  runEnabledCallbacks() {
    for (const callback of this.onWebcamReadyCb) {
      callback();
    }
  }
}
__name(WebcamController, "WebcamController");
__decorateClass([
  Prop("String")
], WebcamController.prototype, "videoFallback", 2);
rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(WebcamController);


/***/ }),

/***/ "./Assets/Components/WebcamTexture.re.ts":
/*!***********************************************!*\
  !*** ./Assets/Components/WebcamTexture.re.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebcamTexture)
/* harmony export */ });
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rogue-engine */ "rogue-engine");
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rogue_engine__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ "three");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _WebcamController_re__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WebcamController.re */ "./Assets/Components/WebcamController.re.ts");
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};



const { Prop } = rogue_engine__WEBPACK_IMPORTED_MODULE_0__;
class WebcamTexture extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor() {
    super(...arguments);
    this.offset = new three__WEBPACK_IMPORTED_MODULE_1__.Vector2(0, 0);
    this.repeat = new three__WEBPACK_IMPORTED_MODULE_1__.Vector2(0.25, 0.33);
  }
  awake() {
    this.webcamController = rogue_engine__WEBPACK_IMPORTED_MODULE_0__.getComponent(_WebcamController_re__WEBPACK_IMPORTED_MODULE_2__["default"]);
  }
  start() {
    this.webcamController.onWebcamReady(() => {
      this.setWebcamTexture();
    });
  }
  setWebcamTexture() {
    const video = document.getElementById("video");
    const texture = new three__WEBPACK_IMPORTED_MODULE_1__.VideoTexture(video);
    texture.minFilter = three__WEBPACK_IMPORTED_MODULE_1__.LinearFilter;
    texture.magFilter = three__WEBPACK_IMPORTED_MODULE_1__.LinearFilter;
    texture.repeat = this.repeat;
    texture.center = this.offset;
    texture.format = three__WEBPACK_IMPORTED_MODULE_1__.RGBFormat;
    texture.generateMipmaps = false;
    texture.needsUpdate = true;
    const parameters = { color: 16777215, map: texture };
    const material_base = new three__WEBPACK_IMPORTED_MODULE_1__.MeshLambertMaterial(parameters);
    if (this.object3d instanceof three__WEBPACK_IMPORTED_MODULE_1__.Mesh) {
      this.object3d.material = material_base;
    }
  }
  update() {
  }
}
__name(WebcamTexture, "WebcamTexture");
__decorateClass([
  Prop("Vector2")
], WebcamTexture.prototype, "offset", 2);
rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(WebcamTexture);


/***/ }),

/***/ "./Assets/rogue_packages/rogue-cannon/Components/CannonBody.re.ts":
/*!************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/CannonBody.re.ts ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CannonBody)
/* harmony export */ });
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rogue-engine */ "rogue-engine");
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rogue_engine__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ "three");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Lib/RogueCannon */ "./Assets/rogue_packages/rogue-cannon/Lib/RogueCannon.ts");
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};




const _CannonBody = class extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor() {
    super(...arguments);
    this._isTrigger = false;
    this._angularDamping = 0;
    this._linearDamping = 0;
    this._angularFactor = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(1, 1, 1);
    this._linearFactor = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(1, 1, 1);
    this._mass = 1;
    this._useDefaultMass = true;
    this._type = 0;
    this.typeOptions = [
      "Dynamic",
      "Static",
      "Kinematic"
    ];
    this.worldPos = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
    this.worldRot = new three__WEBPACK_IMPORTED_MODULE_1__.Quaternion();
    this.newBodyPos = new cannon_es__WEBPACK_IMPORTED_MODULE_3__.Vec3();
    this.newBodyRot = new cannon_es__WEBPACK_IMPORTED_MODULE_3__.Quaternion();
    this.newPos = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
    this.newRot = new three__WEBPACK_IMPORTED_MODULE_1__.Quaternion();
    this.matrixA = new three__WEBPACK_IMPORTED_MODULE_1__.Matrix4();
    this.matrixB = new three__WEBPACK_IMPORTED_MODULE_1__.Matrix4();
    this.matrixC = new three__WEBPACK_IMPORTED_MODULE_1__.Matrix4();
    this.handleOnCollide = /* @__PURE__ */ __name((event) => {
      const bj = event.contact.bj;
      const bi = event.contact.bi;
      const collision = {
        other: bj !== this.body ? bj : bi,
        contact: event.contact
      };
      this.triggerCollision = collision;
    }, "handleOnCollide");
  }
  get type() {
    return this._type;
  }
  set type(value) {
    this._type = value;
    let type = 1;
    if (value === 0)
      type = 1;
    if (value === 1)
      type = 2;
    if (value === 2)
      type = 4;
    this.body && (this.body.type = type);
  }
  get angularDamping() {
    return this._angularDamping;
  }
  set angularDamping(value) {
    this._angularDamping = value;
    this.body && (this.body.angularDamping = value);
  }
  get linearDamping() {
    return this._linearDamping;
  }
  set linearDamping(value) {
    this._linearDamping = value;
    this.body && (this.body.linearDamping = value);
  }
  get mass() {
    return this._mass;
  }
  set mass(value) {
    this._mass = value;
    this.body && (this.body.mass = value);
    this.body && this.body.updateMassProperties();
  }
  get linearFactor() {
    return this._linearFactor;
  }
  set linearFactor(value) {
    this._linearFactor = value;
    this.body && this.body.linearFactor.set(value.x, value.y, value.z);
  }
  get angularFactor() {
    return this._angularFactor;
  }
  set angularFactor(value) {
    this._angularFactor = value;
    this.body && this.body.angularFactor.set(value.x, value.y, value.z);
  }
  get isTrigger() {
    return this._isTrigger;
  }
  set isTrigger(value) {
    this._isTrigger = value;
    this.body && (this.body.isTrigger = value);
  }
  static findByBody(body) {
    let bodyComponent;
    rogue_engine__WEBPACK_IMPORTED_MODULE_0__.traverseComponents((component) => {
      if (bodyComponent)
        return;
      if (component instanceof _CannonBody && component.body === body) {
        bodyComponent = component;
      }
    });
    return bodyComponent;
  }
  awake() {
    this.createBody();
    rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Runtime.onStop(() => {
      this.handleOnCollide && this.body.removeEventListener("collide", this.handleOnCollide);
    });
  }
  start() {
    _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__.getWorld().addBody(this.body);
    this.copyObjectTransform();
  }
  update() {
    if (this.body.mass !== this._mass) {
      this.mass = this._mass;
    }
    this.body && (this.body.type = this.getBodyType());
    this.body.type !== cannon_es__WEBPACK_IMPORTED_MODULE_3__.BODY_TYPES.STATIC && this.updatePhysics();
  }
  afterUpdate() {
    if (this.triggerCollision !== void 0 && this.onCollideCB) {
      this.onCollideCB(this.triggerCollision);
      this.triggerCollision = void 0;
    }
  }
  onBeforeRemoved() {
    _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__.getWorld().removeBody(this.body);
  }
  onCollide(callback) {
    this.onCollideCB = callback;
    this.body.removeEventListener("collide", this.handleOnCollide);
    this.body.addEventListener("collide", this.handleOnCollide);
  }
  getBodyType() {
    let type = 1;
    if (this._type === 0)
      type = 1;
    if (this._type === 1)
      type = 2;
    if (this._type === 2)
      type = 4;
    return type;
  }
  createBody() {
    this.body = new cannon_es__WEBPACK_IMPORTED_MODULE_3__.Body({
      type: this.getBodyType(),
      angularDamping: this.angularDamping,
      linearDamping: this.linearDamping,
      linearFactor: new cannon_es__WEBPACK_IMPORTED_MODULE_3__.Vec3(this.linearFactor.x, this.linearFactor.y, this.linearFactor.z),
      angularFactor: new cannon_es__WEBPACK_IMPORTED_MODULE_3__.Vec3(this.angularFactor.x, this.angularFactor.y, this.angularFactor.z),
      isTrigger: this.isTrigger,
      mass: this._mass
    });
    this.copyObjectTransform();
  }
  createShape() {
  }
  copyObjectTransform() {
    this.object3d.parent?.updateMatrixWorld(true);
    this.object3d.getWorldPosition(this.worldPos);
    this.object3d.getWorldQuaternion(this.worldRot);
    this.newBodyPos.set(this.worldPos.x, this.worldPos.y, this.worldPos.z);
    this.newBodyRot.set(this.worldRot.x, this.worldRot.y, this.worldRot.z, this.worldRot.w);
    this.body.quaternion.copy(this.newBodyRot);
    this.body.position.copy(this.newBodyPos);
  }
  copyBodyTransform() {
    this.copyBodyPosition();
    this.copyBodyRotation();
  }
  copyBodyPosition() {
    this.newPos.set(this.body.position.x, this.body.position.y, this.body.position.z);
    if (!this.object3d.parent)
      return;
    this.object3d.parent?.worldToLocal(this.newPos);
    this.object3d.position.copy(this.newPos);
  }
  copyBodyRotation() {
    this.newRot.set(this.body.quaternion.x, this.body.quaternion.y, this.body.quaternion.z, this.body.quaternion.w);
    this.matrixA.makeRotationFromQuaternion(this.newRot);
    this.object3d.updateMatrixWorld();
    this.matrixB.copy(this.object3d.parent.matrixWorld).invert();
    this.matrixC.extractRotation(this.matrixB);
    this.matrixA.premultiply(this.matrixC);
    this.object3d.quaternion.setFromRotationMatrix(this.matrixA);
  }
  updatePhysics() {
    this.copyBodyTransform();
  }
};
let CannonBody = _CannonBody;
__name(CannonBody, "CannonBody");
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Select")
], CannonBody.prototype, "type", 1);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonBody.prototype, "angularDamping", 1);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonBody.prototype, "linearDamping", 1);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonBody.prototype, "mass", 1);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Vector3")
], CannonBody.prototype, "linearFactor", 1);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Vector3")
], CannonBody.prototype, "angularFactor", 1);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Boolean")
], CannonBody.prototype, "isTrigger", 1);

rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(CannonBody);


/***/ }),

/***/ "./Assets/rogue_packages/rogue-cannon/Components/CannonConfig.re.ts":
/*!**************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/CannonConfig.re.ts ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CannonConfig)
/* harmony export */ });
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rogue-engine */ "rogue-engine");
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rogue_engine__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ "three");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Lib/RogueCannon */ "./Assets/rogue_packages/rogue-cannon/Lib/RogueCannon.ts");
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};




class CannonConfig extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor() {
    super(...arguments);
    this._defaultFriction = 0.01;
    this._defaultRestitution = 0;
    this.maxSubSteps = 1;
    this.gravity = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, -9.82, 0);
  }
  get defaultFriction() {
    return this._defaultFriction;
  }
  set defaultFriction(value) {
    this._defaultFriction = value;
    _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__.getWorld().defaultContactMaterial.friction = value;
  }
  get defaultRestitution() {
    return this._defaultRestitution;
  }
  set defaultRestitution(value) {
    this._defaultRestitution = value;
    _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__.getWorld().defaultContactMaterial.restitution = value;
  }
  awake() {
    _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__.setWorld(new cannon_es__WEBPACK_IMPORTED_MODULE_3__.World());
    _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__.getWorld().gravity.set(this.gravity.x, this.gravity.y, this.gravity.z);
    _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__.getWorld().broadphase = new cannon_es__WEBPACK_IMPORTED_MODULE_3__.NaiveBroadphase();
    _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__.getWorld().defaultContactMaterial.friction = this.defaultFriction;
    _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__.getWorld().defaultContactMaterial.restitution = this.defaultRestitution;
  }
  beforeUpdate() {
    _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__.getWorld().step(rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Runtime.deltaTime, rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Runtime.deltaTime, this.maxSubSteps || 1);
  }
}
__name(CannonConfig, "CannonConfig");
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonConfig.prototype, "maxSubSteps", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonConfig.prototype, "defaultFriction", 1);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonConfig.prototype, "defaultRestitution", 1);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Vector3")
], CannonConfig.prototype, "gravity", 2);
rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(CannonConfig);


/***/ }),

/***/ "./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonConstraint.ts":
/*!***************************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonConstraint.ts ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CannonConstraint)
/* harmony export */ });
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rogue-engine */ "rogue-engine");
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rogue_engine__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _CannonBody_re__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../CannonBody.re */ "./Assets/rogue_packages/rogue-cannon/Components/CannonBody.re.ts");
/* harmony import */ var _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Lib/RogueCannon */ "./Assets/rogue_packages/rogue-cannon/Lib/RogueCannon.ts");
var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });



class CannonConstraint extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
  start() {
    this.createConstraint();
  }
  getCannonBodyComponent(object3d) {
    const cannonBody = rogue_engine__WEBPACK_IMPORTED_MODULE_0__.getComponent(_CannonBody_re__WEBPACK_IMPORTED_MODULE_1__["default"], object3d);
    if (!cannonBody) {
      throw "CannonHinge targets must have a Cannon Body Component";
    }
    return cannonBody;
  }
  createConstraint() {
  }
  onRemoved() {
    _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__.getWorld().removeConstraint(this.constraint);
  }
}
__name(CannonConstraint, "CannonConstraint");


/***/ }),

/***/ "./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonDistanceConstraint.re.ts":
/*!**************************************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonDistanceConstraint.re.ts ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CannonDistanceConstraint)
/* harmony export */ });
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rogue-engine */ "rogue-engine");
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rogue_engine__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js");
/* harmony import */ var _CannonConstraint__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CannonConstraint */ "./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonConstraint.ts");
/* harmony import */ var _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Lib/RogueCannon */ "./Assets/rogue_packages/rogue-cannon/Lib/RogueCannon.ts");
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};




class CannonDistanceConstraint extends _CannonConstraint__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor() {
    super(...arguments);
    this.distance = 1;
    this.maxForce = 1e6;
  }
  createConstraint() {
    if (!this.target)
      throw "CannonHinge requires a target";
    const bodyA = this.getCannonBodyComponent(this.object3d).body;
    const bodyB = this.getCannonBodyComponent(this.target).body;
    this.constraint = new cannon_es__WEBPACK_IMPORTED_MODULE_3__.DistanceConstraint(bodyA, bodyB, this.distance, this.maxForce);
    _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__.getWorld().addConstraint(this.constraint);
  }
}
__name(CannonDistanceConstraint, "CannonDistanceConstraint");
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Object3D")
], CannonDistanceConstraint.prototype, "target", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonDistanceConstraint.prototype, "distance", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonDistanceConstraint.prototype, "maxForce", 2);
rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(CannonDistanceConstraint);


/***/ }),

/***/ "./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonHingeConstraint.re.ts":
/*!***********************************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonHingeConstraint.re.ts ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CannonHingeConstraint)
/* harmony export */ });
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rogue-engine */ "rogue-engine");
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rogue_engine__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ "three");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js");
/* harmony import */ var _CannonConstraint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CannonConstraint */ "./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonConstraint.ts");
/* harmony import */ var _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Lib/RogueCannon */ "./Assets/rogue_packages/rogue-cannon/Lib/RogueCannon.ts");
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};





class CannonHingeConstraint extends _CannonConstraint__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor() {
    super(...arguments);
    this.pivotA = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(0.1, 0, 0);
    this.axisA = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 1, 0);
    this.pivotB = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(-1, 0, 0);
    this.axisB = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 1, 0);
    this.maxForce = 1e6;
  }
  createConstraint() {
    if (!this.target)
      throw "CannonHinge requires a target";
    const bodyA = this.getCannonBodyComponent(this.object3d).body;
    const bodyB = this.getCannonBodyComponent(this.target).body;
    this.constraint = new cannon_es__WEBPACK_IMPORTED_MODULE_4__.HingeConstraint(bodyA, bodyB, {
      pivotA: new cannon_es__WEBPACK_IMPORTED_MODULE_4__.Vec3(this.pivotA.x, this.pivotA.y, this.pivotA.z),
      axisA: new cannon_es__WEBPACK_IMPORTED_MODULE_4__.Vec3(this.axisA.x, this.axisA.y, this.axisA.z),
      pivotB: new cannon_es__WEBPACK_IMPORTED_MODULE_4__.Vec3(this.pivotB.x, this.pivotB.y, this.pivotB.z),
      axisB: new cannon_es__WEBPACK_IMPORTED_MODULE_4__.Vec3(this.axisB.x, this.axisB.y, this.axisB.z),
      collideConnected: this.collideConnected,
      maxForce: this.maxForce
    });
    _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_3__.getWorld().addConstraint(this.constraint);
  }
}
__name(CannonHingeConstraint, "CannonHingeConstraint");
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Object3D")
], CannonHingeConstraint.prototype, "target", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Vector3")
], CannonHingeConstraint.prototype, "pivotA", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Vector3")
], CannonHingeConstraint.prototype, "axisA", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Vector3")
], CannonHingeConstraint.prototype, "pivotB", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Vector3")
], CannonHingeConstraint.prototype, "axisB", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Boolean")
], CannonHingeConstraint.prototype, "collideConnected", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonHingeConstraint.prototype, "maxForce", 2);
rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(CannonHingeConstraint);


/***/ }),

/***/ "./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonLockConstraint.re.ts":
/*!**********************************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonLockConstraint.re.ts ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CannonLockConstraint)
/* harmony export */ });
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rogue-engine */ "rogue-engine");
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rogue_engine__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js");
/* harmony import */ var _CannonConstraint__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CannonConstraint */ "./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonConstraint.ts");
/* harmony import */ var _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Lib/RogueCannon */ "./Assets/rogue_packages/rogue-cannon/Lib/RogueCannon.ts");
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};




class CannonLockConstraint extends _CannonConstraint__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor() {
    super(...arguments);
    this.maxForce = 1e6;
  }
  createConstraint() {
    if (!this.target)
      throw "CannonHinge requires a target";
    const bodyA = this.getCannonBodyComponent(this.object3d).body;
    const bodyB = this.getCannonBodyComponent(this.target).body;
    this.constraint = new cannon_es__WEBPACK_IMPORTED_MODULE_3__.LockConstraint(bodyA, bodyB, {
      maxForce: this.maxForce
    });
    _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__.getWorld().addConstraint(this.constraint);
  }
}
__name(CannonLockConstraint, "CannonLockConstraint");
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Object3D")
], CannonLockConstraint.prototype, "target", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonLockConstraint.prototype, "maxForce", 2);
rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(CannonLockConstraint);


/***/ }),

/***/ "./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonPointToPointConstraint.re.ts":
/*!******************************************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonPointToPointConstraint.re.ts ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CannonPointToPointConstraint)
/* harmony export */ });
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rogue-engine */ "rogue-engine");
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rogue_engine__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ "three");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js");
/* harmony import */ var _CannonConstraint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CannonConstraint */ "./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonConstraint.ts");
/* harmony import */ var _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Lib/RogueCannon */ "./Assets/rogue_packages/rogue-cannon/Lib/RogueCannon.ts");
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};





class CannonPointToPointConstraint extends _CannonConstraint__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor() {
    super(...arguments);
    this.privotA = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
    this.privotB = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
    this.maxForce = 1e6;
  }
  createConstraint() {
    if (!this.target)
      throw "CannonHinge requires a target";
    const bodyA = this.getCannonBodyComponent(this.object3d).body;
    const bodyB = this.getCannonBodyComponent(this.target).body;
    this.constraint = new cannon_es__WEBPACK_IMPORTED_MODULE_4__.PointToPointConstraint(bodyA, new cannon_es__WEBPACK_IMPORTED_MODULE_4__.Vec3(this.privotA.x, this.privotA.y, this.privotA.z), bodyB, new cannon_es__WEBPACK_IMPORTED_MODULE_4__.Vec3(this.privotB.x, this.privotB.y, this.privotB.z), this.maxForce);
    _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_3__.getWorld().addConstraint(this.constraint);
  }
}
__name(CannonPointToPointConstraint, "CannonPointToPointConstraint");
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Object3D")
], CannonPointToPointConstraint.prototype, "target", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Vector3")
], CannonPointToPointConstraint.prototype, "privotA", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Vector3")
], CannonPointToPointConstraint.prototype, "privotB", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonPointToPointConstraint.prototype, "maxForce", 2);
rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(CannonPointToPointConstraint);


/***/ }),

/***/ "./Assets/rogue_packages/rogue-cannon/Components/Controllers/CannonSimpleCharacterController.re.ts":
/*!*********************************************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/Controllers/CannonSimpleCharacterController.re.ts ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CannonSimpleCharacterController)
/* harmony export */ });
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rogue-engine */ "rogue-engine");
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rogue_engine__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js");
/* harmony import */ var _CannonBody_re__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../CannonBody.re */ "./Assets/rogue_packages/rogue-cannon/Components/CannonBody.re.ts");
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};



class CannonSimpleCharacterController extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor() {
    super(...arguments);
    this.fwdSpeed = 3;
    this.jumpSpeed = 5;
    this.canJump = false;
    this.contactNormal = new cannon_es__WEBPACK_IMPORTED_MODULE_2__.Vec3();
    this.upAxis = new cannon_es__WEBPACK_IMPORTED_MODULE_2__.Vec3(0, 1, 0);
    this.inputAngularVelocity = new cannon_es__WEBPACK_IMPORTED_MODULE_2__.Vec3();
    this.inputVelocity = new cannon_es__WEBPACK_IMPORTED_MODULE_2__.Vec3();
  }
  awake() {
    this.rigidbody = rogue_engine__WEBPACK_IMPORTED_MODULE_0__.getComponent(_CannonBody_re__WEBPACK_IMPORTED_MODULE_1__["default"], this.object3d);
    this.rigidbody?.onCollide((event) => {
      event.contact.ni.negate(this.contactNormal);
      if (this.contactNormal.dot(this.upAxis) > 0.5) {
        this.canJump = true;
      }
    });
    if (!this.rigidbody)
      return;
    this.rigidbody.body.type = cannon_es__WEBPACK_IMPORTED_MODULE_2__.Body.DYNAMIC;
  }
  update() {
    if (!this.rigidbody)
      return;
    this.inputVelocity.setZero();
    if (rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Input.keyboard.getKeyPressed("KeyW")) {
      this.inputVelocity.z = -1;
    } else if (rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Input.keyboard.getKeyPressed("KeyS")) {
      this.inputVelocity.z = 1;
    } else {
      this.inputVelocity.z = 0;
    }
    if (rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Input.keyboard.getKeyPressed("KeyA")) {
      this.inputVelocity.x = -1;
    } else if (rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Input.keyboard.getKeyPressed("KeyD")) {
      this.inputVelocity.x = 1;
    } else {
      this.inputVelocity.x = 0;
    }
    this.inputVelocity.normalize();
    this.inputVelocity.scale(this.fwdSpeed, this.inputVelocity);
    if (this.canJump && rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Input.keyboard.getKeyDown("Space")) {
      this.rigidbody.body.velocity.y = this.jumpSpeed;
      this.canJump = false;
    }
    this.rigidbody.body.angularVelocity.y = this.inputAngularVelocity.y;
    this.rigidbody.body.vectorToWorldFrame(this.inputVelocity, this.inputVelocity);
    if (!this.canJump)
      return;
    this.rigidbody.body.velocity.x = this.inputVelocity.x;
    this.rigidbody.body.velocity.z = this.inputVelocity.z;
  }
}
__name(CannonSimpleCharacterController, "CannonSimpleCharacterController");
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonSimpleCharacterController.prototype, "fwdSpeed", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonSimpleCharacterController.prototype, "jumpSpeed", 2);
rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(CannonSimpleCharacterController);


/***/ }),

/***/ "./Assets/rogue_packages/rogue-cannon/Components/Controllers/CannonVehicleController.re.ts":
/*!*************************************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/Controllers/CannonVehicleController.re.ts ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CannonVehicleController)
/* harmony export */ });
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rogue-engine */ "rogue-engine");
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rogue_engine__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Objects_CannonRaycastVehicle_re__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Objects/CannonRaycastVehicle.re */ "./Assets/rogue_packages/rogue-cannon/Components/Objects/CannonRaycastVehicle.re.ts");
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};


class CannonVehicleController extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor() {
    super(...arguments);
    this.maxForce = 200;
    this.reverseForce = 50;
    this.breakForce = 250;
    this.maxSteering = 0.5;
  }
  start() {
    this.raycastVehicle = rogue_engine__WEBPACK_IMPORTED_MODULE_0__.getComponentByName("CannonRaycastVehicle", this.object3d);
  }
  update() {
    if (!(this.raycastVehicle instanceof _Objects_CannonRaycastVehicle_re__WEBPACK_IMPORTED_MODULE_1__["default"]))
      return;
    if (rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Input.keyboard.getKeyPressed("KeyW")) {
      this.releaseBreaks();
      this.raycastVehicle.vehicle.applyEngineForce(this.maxForce, 2);
      this.raycastVehicle.vehicle.applyEngineForce(this.maxForce, 3);
    }
    if (rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Input.keyboard.getKeyPressed("KeyS")) {
      const speed = -this.raycastVehicle.vehicle.currentVehicleSpeedKmHour;
      if (speed <= 0) {
        this.releaseBreaks();
        this.raycastVehicle.vehicle.applyEngineForce(-this.reverseForce, 2);
        this.raycastVehicle.vehicle.applyEngineForce(-this.reverseForce, 3);
      } else if (speed > 0.05) {
        this.raycastVehicle.vehicle.applyEngineForce(-this.maxForce, 2);
        this.raycastVehicle.vehicle.applyEngineForce(-this.maxForce, 3);
      }
    }
    if (rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Input.keyboard.getKeyUp("KeyW")) {
      this.raycastVehicle.vehicle.applyEngineForce(0, 2);
      this.raycastVehicle.vehicle.applyEngineForce(0, 3);
    }
    if (rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Input.keyboard.getKeyUp("KeyS")) {
      const speed = Math.abs(this.raycastVehicle.vehicle.currentVehicleSpeedKmHour);
      this.raycastVehicle.vehicle.applyEngineForce(0, 2);
      this.raycastVehicle.vehicle.applyEngineForce(0, 3);
      if (speed < 1) {
        this.break();
      } else {
        this.releaseBreaks();
      }
    }
    if (rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Input.keyboard.getKeyPressed("KeyA")) {
      this.raycastVehicle.vehicle.setSteeringValue(this.maxSteering, 0);
      this.raycastVehicle.vehicle.setSteeringValue(this.maxSteering, 1);
    }
    if (rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Input.keyboard.getKeyPressed("KeyD")) {
      this.raycastVehicle.vehicle.setSteeringValue(-this.maxSteering, 0);
      this.raycastVehicle.vehicle.setSteeringValue(-this.maxSteering, 1);
    }
    if (rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Input.keyboard.getKeyUp("KeyA")) {
      this.raycastVehicle.vehicle.setSteeringValue(0, 0);
      this.raycastVehicle.vehicle.setSteeringValue(0, 1);
    }
    if (rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Input.keyboard.getKeyUp("KeyD")) {
      this.raycastVehicle.vehicle.setSteeringValue(0, 0);
      this.raycastVehicle.vehicle.setSteeringValue(0, 1);
    }
  }
  break() {
    this.raycastVehicle.vehicle.setBrake(this.breakForce, 0);
    this.raycastVehicle.vehicle.setBrake(this.breakForce, 1);
    this.raycastVehicle.vehicle.setBrake(this.breakForce, 2);
    this.raycastVehicle.vehicle.setBrake(this.breakForce, 3);
  }
  releaseBreaks() {
    this.raycastVehicle.vehicle.setBrake(0, 0);
    this.raycastVehicle.vehicle.setBrake(0, 1);
    this.raycastVehicle.vehicle.setBrake(0, 2);
    this.raycastVehicle.vehicle.setBrake(0, 3);
  }
}
__name(CannonVehicleController, "CannonVehicleController");
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonVehicleController.prototype, "maxForce", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonVehicleController.prototype, "reverseForce", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonVehicleController.prototype, "breakForce", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonVehicleController.prototype, "maxSteering", 2);
rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(CannonVehicleController);


/***/ }),

/***/ "./Assets/rogue_packages/rogue-cannon/Components/Material/CannonContactMaterial.re.ts":
/*!********************************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/Material/CannonContactMaterial.re.ts ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CannonContactMaterial)
/* harmony export */ });
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rogue-engine */ "rogue-engine");
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rogue_engine__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js");
/* harmony import */ var _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Lib/RogueCannon */ "./Assets/rogue_packages/rogue-cannon/Lib/RogueCannon.ts");
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};



class CannonContactMaterial extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
  start() {
    this.createContactMaterial();
  }
  getMaterial(materialName) {
    return _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_1__.getWorld().materials.find((material) => material.name === materialName);
  }
  createContactMaterial() {
    const cannonMaterialA = this.getMaterial(this.materialA);
    const cannonMaterialB = this.getMaterial(this.materialB);
    if (!cannonMaterialA || !cannonMaterialB)
      return;
    this.contactMaterial = new cannon_es__WEBPACK_IMPORTED_MODULE_2__.ContactMaterial(cannonMaterialA, cannonMaterialB, {
      friction: this.friction,
      restitution: this.restitution
    });
    this.contactMaterial.friction = this.friction;
    this.contactMaterial.restitution = this.restitution;
    _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_1__.getWorld().addContactMaterial(this.contactMaterial);
  }
}
__name(CannonContactMaterial, "CannonContactMaterial");
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("String")
], CannonContactMaterial.prototype, "materialA", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("String")
], CannonContactMaterial.prototype, "materialB", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonContactMaterial.prototype, "friction", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonContactMaterial.prototype, "restitution", 2);
rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(CannonContactMaterial);


/***/ }),

/***/ "./Assets/rogue_packages/rogue-cannon/Components/Material/CannonMaterial.re.ts":
/*!*************************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/Material/CannonMaterial.re.ts ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CannonMaterial)
/* harmony export */ });
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rogue-engine */ "rogue-engine");
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rogue_engine__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js");
/* harmony import */ var _CannonBody_re__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../CannonBody.re */ "./Assets/rogue_packages/rogue-cannon/Components/CannonBody.re.ts");
/* harmony import */ var _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Lib/RogueCannon */ "./Assets/rogue_packages/rogue-cannon/Lib/RogueCannon.ts");
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};




class CannonMaterial extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
  awake() {
    this.createMaterial();
  }
  start() {
    this.setMaterial();
  }
  createMaterial() {
    this.material = new cannon_es__WEBPACK_IMPORTED_MODULE_3__.Material(this.name);
    this.material.friction = this.friction;
    this.material.restitution = this.restitution;
    _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__.getWorld().addMaterial(this.material);
  }
  setMaterial() {
    const cannonBody = rogue_engine__WEBPACK_IMPORTED_MODULE_0__.getComponent(_CannonBody_re__WEBPACK_IMPORTED_MODULE_1__["default"], this.object3d);
    if (cannonBody) {
      cannonBody.body.shapes.forEach((shape) => shape.material = this.material);
    }
  }
}
__name(CannonMaterial, "CannonMaterial");
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonMaterial.prototype, "friction", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonMaterial.prototype, "restitution", 2);
rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(CannonMaterial);


/***/ }),

/***/ "./Assets/rogue_packages/rogue-cannon/Components/Material/SetCannonMaterial.re.ts":
/*!****************************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/Material/SetCannonMaterial.re.ts ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SetCannonMaterial)
/* harmony export */ });
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rogue-engine */ "rogue-engine");
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rogue_engine__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _CannonBody_re__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../CannonBody.re */ "./Assets/rogue_packages/rogue-cannon/Components/CannonBody.re.ts");
/* harmony import */ var _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Lib/RogueCannon */ "./Assets/rogue_packages/rogue-cannon/Lib/RogueCannon.ts");
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};



class SetCannonMaterial extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
  start() {
    this.setMaterial();
  }
  getMaterial() {
    return _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__.getWorld().materials.find((material) => material.name === this.materialName);
  }
  setMaterial() {
    const material = this.getMaterial();
    if (!material)
      return;
    this.material = material;
    const cannonBody = rogue_engine__WEBPACK_IMPORTED_MODULE_0__.getComponent(_CannonBody_re__WEBPACK_IMPORTED_MODULE_1__["default"], this.object3d);
    if (cannonBody) {
      cannonBody.body.shapes.forEach((shape) => shape.material = this.material);
    }
  }
}
__name(SetCannonMaterial, "SetCannonMaterial");
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("String")
], SetCannonMaterial.prototype, "materialName", 2);
rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(SetCannonMaterial);


/***/ }),

/***/ "./Assets/rogue_packages/rogue-cannon/Components/Objects/CannonRaycastVehicle.re.ts":
/*!******************************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/Objects/CannonRaycastVehicle.re.ts ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CannonRaycastVehicle)
/* harmony export */ });
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rogue-engine */ "rogue-engine");
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rogue_engine__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js");
/* harmony import */ var _CannonBody_re__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../CannonBody.re */ "./Assets/rogue_packages/rogue-cannon/Components/CannonBody.re.ts");
/* harmony import */ var _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Lib/RogueCannon */ "./Assets/rogue_packages/rogue-cannon/Lib/RogueCannon.ts");
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};




class CannonRaycastVehicle extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor() {
    super(...arguments);
    this.mass = 500;
    this.suspensionStiffness = 30;
    this.suspensionRestLength = 0.1;
    this.frictionSlip = 0.7;
    this.maxSuspensionTravel = 0.2;
    this.customSlidingRotationalSpeed = -30;
    this.useCustomSlidingRotationalSpeed = true;
  }
  start() {
    if (!_Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__.getWorld())
      return;
    let body = rogue_engine__WEBPACK_IMPORTED_MODULE_0__.getComponent(_CannonBody_re__WEBPACK_IMPORTED_MODULE_1__["default"], this.object3d);
    if (!body) {
      body = new _CannonBody_re__WEBPACK_IMPORTED_MODULE_1__["default"]("CarBody", this.object3d);
      body.mass = this.mass;
      rogue_engine__WEBPACK_IMPORTED_MODULE_0__.addComponent(body);
    }
    if (!this.chasis)
      return;
    const chassisBody = rogue_engine__WEBPACK_IMPORTED_MODULE_0__.getComponent(_CannonBody_re__WEBPACK_IMPORTED_MODULE_1__["default"], this.chasis);
    if (!(chassisBody instanceof _CannonBody_re__WEBPACK_IMPORTED_MODULE_1__["default"]))
      return;
    this.vehicle = new cannon_es__WEBPACK_IMPORTED_MODULE_3__.RaycastVehicle({
      chassisBody: body.body,
      indexForwardAxis: 2,
      indexUpAxis: 1,
      indexRightAxis: 0
    });
    this.vehicle.addToWorld(_Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_2__.getWorld());
  }
}
__name(CannonRaycastVehicle, "CannonRaycastVehicle");
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Object3D")
], CannonRaycastVehicle.prototype, "chasis", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonRaycastVehicle.prototype, "mass", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonRaycastVehicle.prototype, "suspensionStiffness", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonRaycastVehicle.prototype, "suspensionRestLength", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonRaycastVehicle.prototype, "frictionSlip", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonRaycastVehicle.prototype, "dampingRelaxation", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonRaycastVehicle.prototype, "dampingCompression", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonRaycastVehicle.prototype, "maxSuspensionForce", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonRaycastVehicle.prototype, "rollInfluence", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonRaycastVehicle.prototype, "maxSuspensionTravel", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonRaycastVehicle.prototype, "customSlidingRotationalSpeed", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Boolean")
], CannonRaycastVehicle.prototype, "useCustomSlidingRotationalSpeed", 2);
rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(CannonRaycastVehicle);


/***/ }),

/***/ "./Assets/rogue_packages/rogue-cannon/Components/Objects/CannonSpring.re.ts":
/*!**********************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/Objects/CannonSpring.re.ts ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CannonSpring)
/* harmony export */ });
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rogue-engine */ "rogue-engine");
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rogue_engine__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ "three");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js");
/* harmony import */ var _CannonBody_re__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../CannonBody.re */ "./Assets/rogue_packages/rogue-cannon/Components/CannonBody.re.ts");
/* harmony import */ var _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Lib/RogueCannon */ "./Assets/rogue_packages/rogue-cannon/Lib/RogueCannon.ts");
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};





class CannonSpring extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor() {
    super(...arguments);
    this.anchorA = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
    this.anchorB = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
    this.restLength = 0;
    this.stiffness = 50;
    this.damping = 1;
    this.applyForce = /* @__PURE__ */ __name(() => {
      this.spring.applyForce();
    }, "applyForce");
  }
  start() {
    this.createSpring();
  }
  getCannonBodyComponent(object3d) {
    const cannonBody = rogue_engine__WEBPACK_IMPORTED_MODULE_0__.getComponent(_CannonBody_re__WEBPACK_IMPORTED_MODULE_2__["default"], object3d);
    if (!cannonBody) {
      throw "CannonSpring targets must have a Cannon Body Component";
    }
    return cannonBody;
  }
  createSpring() {
    if (!this.target)
      throw "CannonSpring requires a target";
    const bodyA = this.getCannonBodyComponent(this.object3d).body;
    const bodyB = this.getCannonBodyComponent(this.target).body;
    this.spring = new cannon_es__WEBPACK_IMPORTED_MODULE_4__.Spring(bodyA, bodyB, {
      localAnchorA: new cannon_es__WEBPACK_IMPORTED_MODULE_4__.Vec3(this.anchorA.x, this.anchorA.y, this.anchorA.z),
      localAnchorB: new cannon_es__WEBPACK_IMPORTED_MODULE_4__.Vec3(this.anchorB.x, this.anchorB.y, this.anchorB.z),
      restLength: this.restLength,
      stiffness: this.stiffness,
      damping: this.damping
    });
    _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_3__.getWorld().addEventListener("postStep", this.applyForce);
  }
  onBeforeRemoved() {
    _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_3__.getWorld().removeEventListener("postStep", this.applyForce);
  }
}
__name(CannonSpring, "CannonSpring");
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Object3D")
], CannonSpring.prototype, "target", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Vector3")
], CannonSpring.prototype, "anchorA", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Vector3")
], CannonSpring.prototype, "anchorB", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonSpring.prototype, "restLength", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonSpring.prototype, "stiffness", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonSpring.prototype, "damping", 2);
rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(CannonSpring);


/***/ }),

/***/ "./Assets/rogue_packages/rogue-cannon/Components/Objects/CannonWheel.re.ts":
/*!*********************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/Objects/CannonWheel.re.ts ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CannonWheel)
/* harmony export */ });
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rogue-engine */ "rogue-engine");
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rogue_engine__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ "three");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js");
/* harmony import */ var _CannonRaycastVehicle_re__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CannonRaycastVehicle.re */ "./Assets/rogue_packages/rogue-cannon/Components/Objects/CannonRaycastVehicle.re.ts");
/* harmony import */ var _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Lib/RogueCannon */ "./Assets/rogue_packages/rogue-cannon/Lib/RogueCannon.ts");
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};





class CannonWheel extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor() {
    super(...arguments);
    this.connectionPoint = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0);
    this.matrixA = new three__WEBPACK_IMPORTED_MODULE_1__.Matrix4();
    this.matrixB = new three__WEBPACK_IMPORTED_MODULE_1__.Matrix4();
    this.matrixC = new three__WEBPACK_IMPORTED_MODULE_1__.Matrix4();
    this.postStep = /* @__PURE__ */ __name(() => {
      if (!this.wheel)
        return;
      const wheel = this.wheelInfo;
      if (!wheel)
        return;
      const pos = wheel.worldTransform.position;
      const rot = wheel.worldTransform.quaternion;
      this.wheel.position.set(pos.x, pos.y, pos.z);
      this.wheel.parent?.worldToLocal(this.wheel.position);
      this.wheel.quaternion.set(rot.x, rot.y, rot.z, rot.w);
      this.matrixA.makeRotationFromQuaternion(this.wheel.quaternion);
      this.wheel.updateMatrixWorld();
      this.matrixB.copy(this.wheel.parent.matrixWorld).invert();
      this.matrixC.extractRotation(this.matrixB);
      this.matrixA.premultiply(this.matrixC);
      this.wheel.quaternion.setFromRotationMatrix(this.matrixA);
    }, "postStep");
  }
  start() {
    this.raycastVehicle = rogue_engine__WEBPACK_IMPORTED_MODULE_0__.getComponent(_CannonRaycastVehicle_re__WEBPACK_IMPORTED_MODULE_2__["default"], this.object3d);
    if (!(this.raycastVehicle instanceof _CannonRaycastVehicle_re__WEBPACK_IMPORTED_MODULE_2__["default"]))
      return;
    let radius = 0.3;
    if (this.wheel) {
      this.connectionPoint.copy(this.wheel.position);
      const bbox = new three__WEBPACK_IMPORTED_MODULE_1__.Box3().setFromObject(this.wheel);
      radius = bbox.max.x - bbox.min.x;
    }
    this.wheelInfo = new cannon_es__WEBPACK_IMPORTED_MODULE_4__.WheelInfo({
      radius,
      directionLocal: new cannon_es__WEBPACK_IMPORTED_MODULE_4__.Vec3(0, -1, 0),
      suspensionStiffness: this.raycastVehicle.suspensionStiffness,
      suspensionRestLength: this.raycastVehicle.suspensionRestLength,
      frictionSlip: this.raycastVehicle.frictionSlip,
      dampingRelaxation: this.raycastVehicle.dampingRelaxation,
      dampingCompression: this.raycastVehicle.dampingCompression,
      maxSuspensionForce: this.raycastVehicle.maxSuspensionForce,
      rollInfluence: this.raycastVehicle.rollInfluence,
      axleLocal: new cannon_es__WEBPACK_IMPORTED_MODULE_4__.Vec3(-1, 0, 0),
      chassisConnectionPointLocal: new cannon_es__WEBPACK_IMPORTED_MODULE_4__.Vec3(this.connectionPoint.x, this.connectionPoint.y, this.connectionPoint.z),
      maxSuspensionTravel: this.raycastVehicle.maxSuspensionTravel,
      customSlidingRotationalSpeed: this.raycastVehicle.customSlidingRotationalSpeed,
      useCustomSlidingRotationalSpeed: this.raycastVehicle.useCustomSlidingRotationalSpeed
    });
    this.raycastVehicle.vehicle.wheelInfos.push(this.wheelInfo);
    if (!this.wheel)
      return;
    if (!_Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_3__.getWorld())
      return;
    _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_3__.getWorld().addEventListener("postStep", this.postStep);
  }
  onBeforeRemoved() {
    _Lib_RogueCannon__WEBPACK_IMPORTED_MODULE_3__.getWorld().removeEventListener("postStep", this.postStep);
  }
}
__name(CannonWheel, "CannonWheel");
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Object3D")
], CannonWheel.prototype, "wheel", 2);
rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(CannonWheel);


/***/ }),

/***/ "./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonBox.re.ts":
/*!******************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonBox.re.ts ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CannonBox)
/* harmony export */ });
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rogue-engine */ "rogue-engine");
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rogue_engine__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ "three");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js");
/* harmony import */ var _CannonShape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CannonShape */ "./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonShape.ts");
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};




class CannonBox extends _CannonShape__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor() {
    super(...arguments);
    this.sizeOffset = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(1, 1, 1);
    this.worldScale = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
  }
  createShape() {
    this.object3d.getWorldScale(this.worldScale);
    this.shape = new cannon_es__WEBPACK_IMPORTED_MODULE_3__.Box(new cannon_es__WEBPACK_IMPORTED_MODULE_3__.Vec3(this.sizeOffset.x * (this.worldScale.x / 2), this.sizeOffset.y * (this.worldScale.y / 2), this.sizeOffset.z * (this.worldScale.z / 2)));
  }
}
__name(CannonBox, "CannonBox");
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Vector3")
], CannonBox.prototype, "sizeOffset", 2);
rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(CannonBox);


/***/ }),

/***/ "./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonCylinder.re.ts":
/*!***********************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonCylinder.re.ts ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CannonCylinder)
/* harmony export */ });
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rogue-engine */ "rogue-engine");
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rogue_engine__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ "three");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js");
/* harmony import */ var _CannonShape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CannonShape */ "./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonShape.ts");
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};




class CannonCylinder extends _CannonShape__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor() {
    super(...arguments);
    this.radiusTopOffset = 1;
    this.radiusBottomOffset = 1;
    this.heightOffset = 1;
    this.segments = 100;
    this.worldScale = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
  }
  createShape() {
    this.object3d.getWorldScale(this.worldScale);
    this.shape = new cannon_es__WEBPACK_IMPORTED_MODULE_3__.Cylinder(this.radiusTopOffset * this.worldScale.x, this.radiusBottomOffset * this.worldScale.x, this.heightOffset * this.worldScale.y, this.segments);
  }
}
__name(CannonCylinder, "CannonCylinder");
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonCylinder.prototype, "radiusTopOffset", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonCylinder.prototype, "radiusBottomOffset", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonCylinder.prototype, "heightOffset", 2);
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonCylinder.prototype, "segments", 2);
rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(CannonCylinder);


/***/ }),

/***/ "./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonShape.ts":
/*!*****************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonShape.ts ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CannonShape)
/* harmony export */ });
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rogue-engine */ "rogue-engine");
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rogue_engine__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ "three");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _CannonBody_re__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../CannonBody.re */ "./Assets/rogue_packages/rogue-cannon/Components/CannonBody.re.ts");
var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });




class CannonShape extends rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor() {
    super(...arguments);
    this.localPos = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
    this.worldPos = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
    this.localRot = new three__WEBPACK_IMPORTED_MODULE_1__.Quaternion();
    this.worldQuaternion = new three__WEBPACK_IMPORTED_MODULE_1__.Quaternion();
    this.matrixA = new three__WEBPACK_IMPORTED_MODULE_1__.Matrix4();
    this.matrixB = new three__WEBPACK_IMPORTED_MODULE_1__.Matrix4();
    this.matrixC = new three__WEBPACK_IMPORTED_MODULE_1__.Matrix4();
  }
  awake() {
    this.createShape();
  }
  start() {
    if (!this.shape)
      return;
    this.bodyComponent = this.getBodyComponent(this.object3d);
    if (!this.bodyComponent)
      return;
    this.body = this.bodyComponent.body;
    const bodyIsShape = this.object3d === this.bodyComponent.object3d;
    this.object3d.getWorldPosition(this.worldPos);
    this.localPos.copy(this.worldPos);
    this.bodyComponent.object3d.updateWorldMatrix(true, true);
    this.bodyComponent.object3d.worldToLocal(this.localPos);
    let position = new cannon_es__WEBPACK_IMPORTED_MODULE_3__.Vec3(this.localPos.x, this.localPos.y, this.localPos.z);
    this.object3d.updateWorldMatrix(true, true);
    this.object3d.getWorldQuaternion(this.worldQuaternion);
    this.matrixA.makeRotationFromQuaternion(this.worldQuaternion);
    this.object3d.updateWorldMatrix(true, true);
    this.matrixB.copy(this.bodyComponent.object3d.matrixWorld).invert();
    this.matrixC.extractRotation(this.matrixB);
    this.matrixA.premultiply(this.matrixC);
    this.localRot.setFromRotationMatrix(this.matrixA);
    let rotation = new cannon_es__WEBPACK_IMPORTED_MODULE_3__.Quaternion(this.localRot.x, this.localRot.y, this.localRot.z, this.localRot.w);
    if (bodyIsShape) {
      this.body.addShape(this.shape);
    } else {
      this.body.addShape(this.shape, position, rotation);
    }
  }
  getBodyComponent(object3d) {
    const bodyComponent = rogue_engine__WEBPACK_IMPORTED_MODULE_0__.getComponent(_CannonBody_re__WEBPACK_IMPORTED_MODULE_2__["default"], object3d);
    if (bodyComponent) {
      return bodyComponent;
    }
    if (!object3d.parent)
      return;
    return this.getBodyComponent(object3d.parent);
  }
  createShape() {
  }
}
__name(CannonShape, "CannonShape");


/***/ }),

/***/ "./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonSphere.re.ts":
/*!*********************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonSphere.re.ts ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CannonSphere)
/* harmony export */ });
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rogue-engine */ "rogue-engine");
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rogue_engine__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js");
/* harmony import */ var _CannonShape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CannonShape */ "./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonShape.ts");
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};



class CannonSphere extends _CannonShape__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor() {
    super(...arguments);
    this.radiusOffset = 1;
  }
  createShape() {
    const scale = this.object3d.scale;
    const maxSide = Math.max(scale.x, scale.y, scale.z);
    this.shape = new cannon_es__WEBPACK_IMPORTED_MODULE_2__.Sphere(this.radiusOffset * maxSide);
  }
}
__name(CannonSphere, "CannonSphere");
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Number")
], CannonSphere.prototype, "radiusOffset", 2);
rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(CannonSphere);


/***/ }),

/***/ "./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonTrimesh.re.ts":
/*!**********************************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonTrimesh.re.ts ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CannonTrimesh)
/* harmony export */ });
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rogue-engine */ "rogue-engine");
/* harmony import */ var rogue_engine__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rogue_engine__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ "three");
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js");
/* harmony import */ var _CannonShape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CannonShape */ "./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonShape.ts");
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};




class CannonTrimesh extends _CannonShape__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor() {
    super(...arguments);
    this.sizeOffset = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(1, 1, 1);
    this.worldScale = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
    this.worldPos = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();
    this.tmpVec0 = new cannon_es__WEBPACK_IMPORTED_MODULE_3__.Vec3();
    this.tmpVec1 = new cannon_es__WEBPACK_IMPORTED_MODULE_3__.Vec3();
    this.tmpVec2 = new cannon_es__WEBPACK_IMPORTED_MODULE_3__.Vec3();
    this.tmpQuat0 = new cannon_es__WEBPACK_IMPORTED_MODULE_3__.Vec3();
  }
  createShape() {
    if (!(this.object3d instanceof three__WEBPACK_IMPORTED_MODULE_1__.Mesh))
      return;
    this.object3d.updateWorldMatrix(true, true);
    this.object3d.getWorldScale(this.worldScale);
    this.object3d.getWorldPosition(this.worldPos);
    this.object3d.getWorldQuaternion(this.worldQuaternion);
    const mesh = this.object3d;
    let geometry = mesh.geometry;
    geometry.computeBoundingSphere();
    geometry.normalizeNormals();
    if (geometry.index !== null) {
      const nonIndexedGeo = geometry.toNonIndexed();
      geometry.copy(nonIndexedGeo);
    }
    const vertices = this.getVertices(geometry);
    if (!vertices.length)
      return;
    const indices = Object.keys(vertices).map(Number);
    this.shape = new cannon_es__WEBPACK_IMPORTED_MODULE_3__.Trimesh(vertices, indices);
  }
  getVertices(geometry) {
    const position = geometry.attributes.position;
    const vertices = new Float32Array(position.count * 3);
    for (let i = 0; i < position.count; i++) {
      vertices[i * 3] = position.getX(i) * this.worldScale.x;
      vertices[i * 3 + 1] = position.getY(i) * this.worldScale.y;
      vertices[i * 3 + 2] = position.getZ(i) * this.worldScale.z;
    }
    return vertices;
  }
}
__name(CannonTrimesh, "CannonTrimesh");
__decorateClass([
  rogue_engine__WEBPACK_IMPORTED_MODULE_0__.Prop("Vector3")
], CannonTrimesh.prototype, "sizeOffset", 2);
rogue_engine__WEBPACK_IMPORTED_MODULE_0__.registerComponent(CannonTrimesh);


/***/ }),

/***/ "./Assets/rogue_packages/rogue-cannon/Lib/RogueCannon.ts":
/*!***************************************************************!*\
  !*** ./Assets/rogue_packages/rogue-cannon/Lib/RogueCannon.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getWorld": () => (/* binding */ getWorld),
/* harmony export */   "setWorld": () => (/* binding */ setWorld)
/* harmony export */ });
/* harmony import */ var cannon_es__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cannon-es */ "./node_modules/cannon-es/dist/cannon-es.js");
var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

let world = new cannon_es__WEBPACK_IMPORTED_MODULE_0__.World();
function getWorld() {
  return world;
}
__name(getWorld, "getWorld");
function setWorld(newWorld) {
  world = newWorld;
}
__name(setWorld, "setWorld");


/***/ }),

/***/ "rogue-engine":
/*!******************************************************************************************************************!*\
  !*** external {"commonjs":"rogue-engine","commonjs2":"rogue-engine","amd":"rogue-engine","root":"rogue-engine"} ***!
  \******************************************************************************************************************/
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_MODULE_rogue_engine__;

/***/ }),

/***/ "three":
/*!**************************************************************************************!*\
  !*** external {"commonjs":"three","commonjs2":"three","amd":"three","root":"three"} ***!
  \**************************************************************************************/
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_MODULE_three__;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"rogue-engine-user-scripts": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk_name_"] = self["webpackChunk_name_"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	__webpack_require__("./Assets/Components/BasketballController.re.ts");
/******/ 	__webpack_require__("./Assets/Components/Bomb.re.ts");
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	__webpack_require__("./Assets/Components/BombTimer.re.ts");
/******/ 	__webpack_require__("./Assets/Components/CameraController.re.ts");
/******/ 	__webpack_require__("./Assets/Components/Explodable.re.ts");
/******/ 	__webpack_require__("./Assets/Components/FixColdStart.re.ts");
/******/ 	__webpack_require__("./Assets/Components/ProjectileObject.re.ts");
/******/ 	__webpack_require__("./Assets/Components/SceneManager.re.ts");
/******/ 	__webpack_require__("./Assets/Components/Static/DeviceUtils.ts");
/******/ 	__webpack_require__("./Assets/Components/UiManager.re.ts");
/******/ 	__webpack_require__("./Assets/Components/WebcamController.re.ts");
/******/ 	__webpack_require__("./Assets/Components/WebcamTexture.re.ts");
/******/ 	__webpack_require__("./Assets/rogue_packages/rogue-cannon/Components/CannonBody.re.ts");
/******/ 	__webpack_require__("./Assets/rogue_packages/rogue-cannon/Components/CannonConfig.re.ts");
/******/ 	__webpack_require__("./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonConstraint.ts");
/******/ 	__webpack_require__("./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonDistanceConstraint.re.ts");
/******/ 	__webpack_require__("./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonHingeConstraint.re.ts");
/******/ 	__webpack_require__("./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonLockConstraint.re.ts");
/******/ 	__webpack_require__("./Assets/rogue_packages/rogue-cannon/Components/Constraints/CannonPointToPointConstraint.re.ts");
/******/ 	__webpack_require__("./Assets/rogue_packages/rogue-cannon/Components/Controllers/CannonSimpleCharacterController.re.ts");
/******/ 	__webpack_require__("./Assets/rogue_packages/rogue-cannon/Components/Controllers/CannonVehicleController.re.ts");
/******/ 	__webpack_require__("./Assets/rogue_packages/rogue-cannon/Components/Material/CannonContactMaterial.re.ts");
/******/ 	__webpack_require__("./Assets/rogue_packages/rogue-cannon/Components/Material/CannonMaterial.re.ts");
/******/ 	__webpack_require__("./Assets/rogue_packages/rogue-cannon/Components/Material/SetCannonMaterial.re.ts");
/******/ 	__webpack_require__("./Assets/rogue_packages/rogue-cannon/Components/Objects/CannonRaycastVehicle.re.ts");
/******/ 	__webpack_require__("./Assets/rogue_packages/rogue-cannon/Components/Objects/CannonSpring.re.ts");
/******/ 	__webpack_require__("./Assets/rogue_packages/rogue-cannon/Components/Objects/CannonWheel.re.ts");
/******/ 	__webpack_require__("./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonBox.re.ts");
/******/ 	__webpack_require__("./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonCylinder.re.ts");
/******/ 	__webpack_require__("./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonShape.ts");
/******/ 	__webpack_require__("./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonSphere.re.ts");
/******/ 	__webpack_require__("./Assets/rogue_packages/rogue-cannon/Components/Shapes/CannonTrimesh.re.ts");
/******/ 	var __webpack_exports__ = __webpack_require__("./Assets/rogue_packages/rogue-cannon/Lib/RogueCannon.ts");
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=rogue-engine-user-scripts.js.map
window['rogue-engine'].App.play({"title":"Smash Cams - Self Destructo","scenes":[{"name":"VideoBlocks","uuid":"fabf81d6-3784-4933-85f3-0641f365e01b"},{"name":"AngryBomb","uuid":"a2793bba-fec4-42c6-a5ae-abb45fa76035"},{"name":"Basket","uuid":"5be947ac-95fa-4fc1-b9ac-511edecc82d1"}],"assetPaths":{"9FFAD76A-606D-4CE3-8F03-A92E0B6ABE1F":"AppData/9FFAD76A-606D-4CE3-8F03-A92E0B6ABE1F.rogueMaterial","05AA2CF3-42AF-4F7B-B197-B76DC747321C":"AppData/05AA2CF3-42AF-4F7B-B197-B76DC747321C.rogueMaterial","F444618A-066C-4BFD-ADBC-82DFEF229C09":"AppData/F444618A-066C-4BFD-ADBC-82DFEF229C09.roguePrefab","E165F1A4-B7E2-40E4-9263-C011FE25279C":"AppData/E165F1A4-B7E2-40E4-9263-C011FE25279C.png","3488DD94-9DAE-4EF4-8B64-A0B5C96B735B":"AppData/3488DD94-9DAE-4EF4-8B64-A0B5C96B735B.rogueMaterial","9252DBAA-A39F-4EA7-AE06-F35B29707138":"AppData/9252DBAA-A39F-4EA7-AE06-F35B29707138.roguePrefab","77E0C83C-AE44-4504-AC09-C7DD8AD49945":"AppData/77E0C83C-AE44-4504-AC09-C7DD8AD49945.jpg","56AD550F-D2AE-4843-B7D6-7B43705EEAA9":"AppData/56AD550F-D2AE-4843-B7D6-7B43705EEAA9.jpg","91C060A4-3941-4210-85F2-888C35B22948":"AppData/91C060A4-3941-4210-85F2-888C35B22948.rogueMaterial","AFAAE389-483A-4096-B964-9D43B209E58F":"AppData/AFAAE389-483A-4096-B964-9D43B209E58F.jpg","821FA357-BAF5-4FE3-837B-CED50500B029":"AppData/821FA357-BAF5-4FE3-837B-CED50500B029.rogueMaterial","02716EE0-105D-4407-A99F-E758964EA9F1":"AppData/02716EE0-105D-4407-A99F-E758964EA9F1.jpg","89B6BF4D-3150-48C3-88D8-90DCA3195D51":"AppData/89B6BF4D-3150-48C3-88D8-90DCA3195D51.rogueMaterial","0616E97E-B4A1-49BF-ABFB-D8C2CD6CF484":"AppData/0616E97E-B4A1-49BF-ABFB-D8C2CD6CF484.rogueMaterial","D2FDA8E0-3FD7-4451-81C2-575E3250F8AF":"AppData/D2FDA8E0-3FD7-4451-81C2-575E3250F8AF.rogueMaterial","fabf81d6-3784-4933-85f3-0641f365e01b":"AppData/fabf81d6-3784-4933-85f3-0641f365e01b.rogueScene","a2793bba-fec4-42c6-a5ae-abb45fa76035":"AppData/a2793bba-fec4-42c6-a5ae-abb45fa76035.rogueScene","5be947ac-95fa-4fc1-b9ac-511edecc82d1":"AppData/5be947ac-95fa-4fc1-b9ac-511edecc82d1.rogueScene"}});